function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
var parcelRequire = $parcel$global["parcelRequire9622"];
parcelRequire.register("d2Ttb", function(module, exports) {

$parcel$export(module.exports, "mdx", () => $97f67d6a0ec8bdc3$export$5beccd7059e5fba5);

var $5pYYS = parcelRequire("5pYYS");
function $97f67d6a0ec8bdc3$var$_defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function $97f67d6a0ec8bdc3$var$_extends() {
    $97f67d6a0ec8bdc3$var$_extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return $97f67d6a0ec8bdc3$var$_extends.apply(this, arguments);
}
function $97f67d6a0ec8bdc3$var$ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function $97f67d6a0ec8bdc3$var$_objectSpread2(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) $97f67d6a0ec8bdc3$var$ownKeys(Object(source), true).forEach(function(key) {
            $97f67d6a0ec8bdc3$var$_defineProperty(target, key, source[key]);
        });
        else if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        else $97f67d6a0ec8bdc3$var$ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function $97f67d6a0ec8bdc3$var$_objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function $97f67d6a0ec8bdc3$var$_objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = $97f67d6a0ec8bdc3$var$_objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
var $97f67d6a0ec8bdc3$var$isFunction = function isFunction(obj) {
    return typeof obj === "function";
};
var $97f67d6a0ec8bdc3$export$d7de0f1cab697634 = /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createContext({});
var $97f67d6a0ec8bdc3$export$aae81db1754c1e05 = function withMDXComponents(Component) {
    return function(props) {
        var allComponents = $97f67d6a0ec8bdc3$export$ba49c9ffd2310961(props.components);
        return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement(Component, $97f67d6a0ec8bdc3$var$_extends({}, props, {
            components: allComponents
        }));
    };
};
var $97f67d6a0ec8bdc3$export$ba49c9ffd2310961 = function useMDXComponents(components) {
    var contextComponents = (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).useContext($97f67d6a0ec8bdc3$export$d7de0f1cab697634);
    var allComponents = contextComponents;
    if (components) allComponents = $97f67d6a0ec8bdc3$var$isFunction(components) ? components(contextComponents) : $97f67d6a0ec8bdc3$var$_objectSpread2($97f67d6a0ec8bdc3$var$_objectSpread2({}, contextComponents), components);
    return allComponents;
};
var $97f67d6a0ec8bdc3$export$1cf78dad7550a52b = function MDXProvider(props) {
    var allComponents = $97f67d6a0ec8bdc3$export$ba49c9ffd2310961(props.components);
    return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement($97f67d6a0ec8bdc3$export$d7de0f1cab697634.Provider, {
        value: allComponents
    }, props.children);
};
var $97f67d6a0ec8bdc3$var$TYPE_PROP_NAME = "mdxType";
var $97f67d6a0ec8bdc3$var$DEFAULTS = {
    inlineCode: "code",
    wrapper: function wrapper(_ref) {
        var children = _ref.children;
        return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement((0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).Fragment, {}, children);
    }
};
var $97f67d6a0ec8bdc3$var$MDXCreateElement = /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).forwardRef(function(props, ref) {
    var propComponents = props.components, mdxType = props.mdxType, originalType = props.originalType, parentName = props.parentName, etc = $97f67d6a0ec8bdc3$var$_objectWithoutProperties(props, [
        "components",
        "mdxType",
        "originalType",
        "parentName"
    ]);
    var components = $97f67d6a0ec8bdc3$export$ba49c9ffd2310961(propComponents);
    var type = mdxType;
    var Component = components["".concat(parentName, ".").concat(type)] || components[type] || $97f67d6a0ec8bdc3$var$DEFAULTS[type] || originalType;
    if (propComponents) return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement(Component, $97f67d6a0ec8bdc3$var$_objectSpread2($97f67d6a0ec8bdc3$var$_objectSpread2({
        ref: ref
    }, etc), {}, {
        components: propComponents
    }));
    return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement(Component, $97f67d6a0ec8bdc3$var$_objectSpread2({
        ref: ref
    }, etc));
});
$97f67d6a0ec8bdc3$var$MDXCreateElement.displayName = "MDXCreateElement";
function $97f67d6a0ec8bdc3$export$5beccd7059e5fba5(type, props) {
    var args = arguments;
    var mdxType = props && props.mdxType;
    if (typeof type === "string" || mdxType) {
        var argsLength = args.length;
        var createElementArgArray = new Array(argsLength);
        createElementArgArray[0] = $97f67d6a0ec8bdc3$var$MDXCreateElement;
        var newProps = {};
        for(var key in props)if (hasOwnProperty.call(props, key)) newProps[key] = props[key];
        newProps.originalType = type;
        newProps[$97f67d6a0ec8bdc3$var$TYPE_PROP_NAME] = typeof type === "string" ? type : mdxType;
        createElementArgArray[1] = newProps;
        for(var i = 2; i < argsLength; i++)createElementArgArray[i] = args[i];
        return (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement.apply(null, createElementArgArray);
    }
    return (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement.apply(null, args);
}

});

parcelRequire.register("gxyH7", function(module, exports) {

$parcel$export(module.exports, "ReactHtmlRender", () => $65f663046e2f57d6$export$e8b6e6878a3b89a2);
$parcel$export(module.exports, "ReactSrcRender", () => $65f663046e2f57d6$export$caae81f80bc29ec1);

var $ls2pO = parcelRequire("ls2pO");
parcelRequire("k6j4s");
var $b87GI = parcelRequire("b87GI");

var $5pYYS = parcelRequire("5pYYS");

var $kw5CQ = parcelRequire("kw5CQ");

var $eZCyD = parcelRequire("eZCyD");
function $65f663046e2f57d6$export$e8b6e6878a3b89a2(props) {
    const ref = (0, $5pYYS.useRef)(null);
    (0, $5pYYS.useEffect)(()=>{
        if (ref.current) (0, $b87GI.render)(props.html, ref.current);
    }, [
        ref.current
    ]);
    const strings = props.html.strings;
    const linesWithContent = strings.join("").split("\n").filter((it)=>it.trim());
    const leftStart = Math.min(...linesWithContent?.map((it)=>it.replace(/\S.*/, "").length));
    const rawTemplate = strings.map((it, index)=>it + (index < strings.length - 1 ? props.html.values[index] : ""));
    const template = rawTemplate.join("").split("\n").map((it)=>it.substring(leftStart)).join("\n");
    return /*#__PURE__*/ (0, $ls2pO.jsxs)("div", {
        style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            gap: "1em"
        },
        children: [
            !props.hideSrc ? /*#__PURE__*/ (0, $ls2pO.jsx)("div", {
                style: {
                    display: "flex",
                    width: "50%",
                    justifyItems: "stretch",
                    flexDirection: "column"
                },
                children: /*#__PURE__*/ (0, $ls2pO.jsx)((0, $kw5CQ.default), {
                    language: "html",
                    style: (0, $eZCyD.default),
                    children: template.trimStart().trimEnd()
                })
            }) : undefined,
            /*#__PURE__*/ (0, $ls2pO.jsx)("div", {
                style: {
                    flexGrow: 1
                },
                ref: ref
            })
        ]
    });
}
function $65f663046e2f57d6$export$caae81f80bc29ec1(props) {
    return /*#__PURE__*/ (0, $ls2pO.jsx)("div", {
        style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            gap: "1em"
        },
        children: /*#__PURE__*/ (0, $ls2pO.jsx)((0, $kw5CQ.default), {
            language: props.language,
            style: (0, $eZCyD.default),
            children: props.src ?? ""
        })
    });
}

});
parcelRequire.register("k6j4s", function(module, exports) {
$parcel$export(module.exports, "html", () => (parcelRequire("b87GI")).html);
$parcel$export(module.exports, "render", () => (parcelRequire("b87GI")).render);
$parcel$export(module.exports, "noChange", () => (parcelRequire("b87GI")).noChange);
parcelRequire("gR0bR");
parcelRequire("b87GI");
parcelRequire("abcsE");

});
parcelRequire.register("gR0bR", function(module, exports) {

$parcel$export(module.exports, "ReactiveElement", () => $c451be62bc5546be$export$c7c07a37856565d);

var $bMDaU = parcelRequire("bMDaU");

var $bMDaU = parcelRequire("bMDaU");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var $c451be62bc5546be$var$s;
const $c451be62bc5546be$var$e = window.trustedTypes, $c451be62bc5546be$var$r = $c451be62bc5546be$var$e ? $c451be62bc5546be$var$e.emptyScript : "", $c451be62bc5546be$var$h = window.reactiveElementPolyfillSupport, $c451be62bc5546be$export$7312b35fbf521afb = {
    toAttribute (t1, i1) {
        switch(i1){
            case Boolean:
                t1 = t1 ? $c451be62bc5546be$var$r : null;
                break;
            case Object:
            case Array:
                t1 = null == t1 ? t1 : JSON.stringify(t1);
        }
        return t1;
    },
    fromAttribute (t2, i2) {
        let s1 = t2;
        switch(i2){
            case Boolean:
                s1 = null !== t2;
                break;
            case Number:
                s1 = null === t2 ? null : Number(t2);
                break;
            case Object:
            case Array:
                try {
                    s1 = JSON.parse(t2);
                } catch (t) {
                    s1 = null;
                }
        }
        return s1;
    }
}, $c451be62bc5546be$export$53a6892c50694894 = (t3, i3)=>i3 !== t3 && (i3 == i3 || t3 == t3), $c451be62bc5546be$var$l = {
    attribute: !0,
    type: String,
    converter: $c451be62bc5546be$export$7312b35fbf521afb,
    reflect: !1,
    hasChanged: $c451be62bc5546be$export$53a6892c50694894
};
class $c451be62bc5546be$export$c7c07a37856565d extends HTMLElement {
    constructor(){
        super(), this._$Ei = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this.u();
    }
    static addInitializer(t4) {
        var i4;
        null !== (i4 = this.h) && void 0 !== i4 || (this.h = []), this.h.push(t4);
    }
    static get observedAttributes() {
        this.finalize();
        const t5 = [];
        return this.elementProperties.forEach((i5, s2)=>{
            const e1 = this._$Ep(s2, i5);
            void 0 !== e1 && (this._$Ev.set(e1, s2), t5.push(e1));
        }), t5;
    }
    static createProperty(t6, i6 = $c451be62bc5546be$var$l) {
        if (i6.state && (i6.attribute = !1), this.finalize(), this.elementProperties.set(t6, i6), !i6.noAccessor && !this.prototype.hasOwnProperty(t6)) {
            const s3 = "symbol" == typeof t6 ? Symbol() : "__" + t6, e2 = this.getPropertyDescriptor(t6, s3, i6);
            void 0 !== e2 && Object.defineProperty(this.prototype, t6, e2);
        }
    }
    static getPropertyDescriptor(t7, i7, s4) {
        return {
            get () {
                return this[i7];
            },
            set (e3) {
                const r1 = this[t7];
                this[i7] = e3, this.requestUpdate(t7, r1, s4);
            },
            configurable: !0,
            enumerable: !0
        };
    }
    static getPropertyOptions(t8) {
        return this.elementProperties.get(t8) || $c451be62bc5546be$var$l;
    }
    static finalize() {
        if (this.hasOwnProperty("finalized")) return !1;
        this.finalized = !0;
        const t9 = Object.getPrototypeOf(this);
        if (t9.finalize(), this.elementProperties = new Map(t9.elementProperties), this._$Ev = new Map, this.hasOwnProperty("properties")) {
            const t10 = this.properties, i8 = [
                ...Object.getOwnPropertyNames(t10),
                ...Object.getOwnPropertySymbols(t10)
            ];
            for (const s5 of i8)this.createProperty(s5, t10[s5]);
        }
        return this.elementStyles = this.finalizeStyles(this.styles), !0;
    }
    static finalizeStyles(i9) {
        const s6 = [];
        if (Array.isArray(i9)) {
            const e4 = new Set(i9.flat(1 / 0).reverse());
            for (const i10 of e4)s6.unshift((0, $bMDaU.getCompatibleStyle)(i10));
        } else void 0 !== i9 && s6.push((0, $bMDaU.getCompatibleStyle)(i9));
        return s6;
    }
    static _$Ep(t11, i11) {
        const s7 = i11.attribute;
        return !1 === s7 ? void 0 : "string" == typeof s7 ? s7 : "string" == typeof t11 ? t11.toLowerCase() : void 0;
    }
    u() {
        var t12;
        this._$E_ = new Promise((t13)=>this.enableUpdating = t13), this._$AL = new Map, this._$Eg(), this.requestUpdate(), null === (t12 = this.constructor.h) || void 0 === t12 || t12.forEach((t14)=>t14(this));
    }
    addController(t15) {
        var i12, s8;
        (null !== (i12 = this._$ES) && void 0 !== i12 ? i12 : this._$ES = []).push(t15), void 0 !== this.renderRoot && this.isConnected && (null === (s8 = t15.hostConnected) || void 0 === s8 || s8.call(t15));
    }
    removeController(t16) {
        var i13;
        null === (i13 = this._$ES) || void 0 === i13 || i13.splice(this._$ES.indexOf(t16) >>> 0, 1);
    }
    _$Eg() {
        this.constructor.elementProperties.forEach((t, i14)=>{
            this.hasOwnProperty(i14) && (this._$Ei.set(i14, this[i14]), delete this[i14]);
        });
    }
    createRenderRoot() {
        var t17;
        const s9 = null !== (t17 = this.shadowRoot) && void 0 !== t17 ? t17 : this.attachShadow(this.constructor.shadowRootOptions);
        return (0, $bMDaU.adoptStyles)(s9, this.constructor.elementStyles), s9;
    }
    connectedCallback() {
        var t18;
        void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t18 = this._$ES) || void 0 === t18 || t18.forEach((t19)=>{
            var i15;
            return null === (i15 = t19.hostConnected) || void 0 === i15 ? void 0 : i15.call(t19);
        });
    }
    enableUpdating(t) {}
    disconnectedCallback() {
        var t20;
        null === (t20 = this._$ES) || void 0 === t20 || t20.forEach((t21)=>{
            var i16;
            return null === (i16 = t21.hostDisconnected) || void 0 === i16 ? void 0 : i16.call(t21);
        });
    }
    attributeChangedCallback(t22, i, s10) {
        this._$AK(t22, s10);
    }
    _$EO(t23, i17, s11 = $c451be62bc5546be$var$l) {
        var e5, r2;
        const h1 = this.constructor._$Ep(t23, s11);
        if (void 0 !== h1 && !0 === s11.reflect) {
            const n1 = (null !== (r2 = null === (e5 = s11.converter) || void 0 === e5 ? void 0 : e5.toAttribute) && void 0 !== r2 ? r2 : $c451be62bc5546be$export$7312b35fbf521afb.toAttribute)(i17, s11.type);
            this._$El = t23, null == n1 ? this.removeAttribute(h1) : this.setAttribute(h1, n1), this._$El = null;
        }
    }
    _$AK(t24, i18) {
        var s12, e6;
        const r3 = this.constructor, h2 = r3._$Ev.get(t24);
        if (void 0 !== h2 && this._$El !== h2) {
            const t25 = r3.getPropertyOptions(h2), n2 = t25.converter, l1 = null !== (e6 = null !== (s12 = null == n2 ? void 0 : n2.fromAttribute) && void 0 !== s12 ? s12 : "function" == typeof n2 ? n2 : null) && void 0 !== e6 ? e6 : $c451be62bc5546be$export$7312b35fbf521afb.fromAttribute;
            this._$El = h2, this[h2] = l1(i18, t25.type), this._$El = null;
        }
    }
    requestUpdate(t26, i19, s13) {
        let e7 = !0;
        void 0 !== t26 && (((s13 = s13 || this.constructor.getPropertyOptions(t26)).hasChanged || $c451be62bc5546be$export$53a6892c50694894)(this[t26], i19) ? (this._$AL.has(t26) || this._$AL.set(t26, i19), !0 === s13.reflect && this._$El !== t26 && (void 0 === this._$EC && (this._$EC = new Map), this._$EC.set(t26, s13))) : e7 = !1), !this.isUpdatePending && e7 && (this._$E_ = this._$Ej());
    }
    async _$Ej() {
        this.isUpdatePending = !0;
        try {
            await this._$E_;
        } catch (t27) {
            Promise.reject(t27);
        }
        const t28 = this.scheduleUpdate();
        return null != t28 && await t28, !this.isUpdatePending;
    }
    scheduleUpdate() {
        return this.performUpdate();
    }
    performUpdate() {
        var t29;
        if (!this.isUpdatePending) return;
        this.hasUpdated, this._$Ei && (this._$Ei.forEach((t30, i21)=>this[i21] = t30), this._$Ei = void 0);
        let i20 = !1;
        const s14 = this._$AL;
        try {
            i20 = this.shouldUpdate(s14), i20 ? (this.willUpdate(s14), null === (t29 = this._$ES) || void 0 === t29 || t29.forEach((t31)=>{
                var i22;
                return null === (i22 = t31.hostUpdate) || void 0 === i22 ? void 0 : i22.call(t31);
            }), this.update(s14)) : this._$Ek();
        } catch (t32) {
            throw i20 = !1, this._$Ek(), t32;
        }
        i20 && this._$AE(s14);
    }
    willUpdate(t) {}
    _$AE(t33) {
        var i23;
        null === (i23 = this._$ES) || void 0 === i23 || i23.forEach((t34)=>{
            var i24;
            return null === (i24 = t34.hostUpdated) || void 0 === i24 ? void 0 : i24.call(t34);
        }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t33)), this.updated(t33);
    }
    _$Ek() {
        this._$AL = new Map, this.isUpdatePending = !1;
    }
    get updateComplete() {
        return this.getUpdateComplete();
    }
    getUpdateComplete() {
        return this._$E_;
    }
    shouldUpdate(t) {
        return !0;
    }
    update(t35) {
        void 0 !== this._$EC && (this._$EC.forEach((t36, i25)=>this._$EO(i25, this[i25], t36)), this._$EC = void 0), this._$Ek();
    }
    updated(t) {}
    firstUpdated(t) {}
}
$c451be62bc5546be$export$c7c07a37856565d.finalized = !0, $c451be62bc5546be$export$c7c07a37856565d.elementProperties = new Map, $c451be62bc5546be$export$c7c07a37856565d.elementStyles = [], $c451be62bc5546be$export$c7c07a37856565d.shadowRootOptions = {
    mode: "open"
}, null == $c451be62bc5546be$var$h || $c451be62bc5546be$var$h({
    ReactiveElement: $c451be62bc5546be$export$c7c07a37856565d
}), (null !== ($c451be62bc5546be$var$s = globalThis.reactiveElementVersions) && void 0 !== $c451be62bc5546be$var$s ? $c451be62bc5546be$var$s : globalThis.reactiveElementVersions = []).push("1.3.3");

});
parcelRequire.register("bMDaU", function(module, exports) {

$parcel$export(module.exports, "adoptStyles", () => $894290b859ccd34e$export$2ca4a66ec4cecb90);
$parcel$export(module.exports, "getCompatibleStyle", () => $894290b859ccd34e$export$ee69dfd951e24778);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const $894290b859ccd34e$export$b4d10f6001c083c2 = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, $894290b859ccd34e$var$e = Symbol(), $894290b859ccd34e$var$n = new WeakMap;
class $894290b859ccd34e$export$505d1e8739bad805 {
    constructor(t1, n1, s1){
        if (this._$cssResult$ = !0, s1 !== $894290b859ccd34e$var$e) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t1, this.t = n1;
    }
    get styleSheet() {
        let e1 = this.o;
        const s2 = this.t;
        if ($894290b859ccd34e$export$b4d10f6001c083c2 && void 0 === e1) {
            const t2 = void 0 !== s2 && 1 === s2.length;
            t2 && (e1 = $894290b859ccd34e$var$n.get(s2)), void 0 === e1 && ((this.o = e1 = new CSSStyleSheet).replaceSync(this.cssText), t2 && $894290b859ccd34e$var$n.set(s2, e1));
        }
        return e1;
    }
    toString() {
        return this.cssText;
    }
}
const $894290b859ccd34e$export$8d80f9cac07cdb3 = (t3)=>new $894290b859ccd34e$export$505d1e8739bad805("string" == typeof t3 ? t3 : t3 + "", void 0, $894290b859ccd34e$var$e), $894290b859ccd34e$export$dbf350e5966cf602 = (t4, ...n2)=>{
    const o1 = 1 === t4.length ? t4[0] : n2.reduce((e2, n3, s3)=>e2 + ((t5)=>{
            if (!0 === t5._$cssResult$) return t5.cssText;
            if ("number" == typeof t5) return t5;
            throw Error("Value passed to 'css' function must be a 'css' function result: " + t5 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
        })(n3) + t4[s3 + 1], t4[0]);
    return new $894290b859ccd34e$export$505d1e8739bad805(o1, t4, $894290b859ccd34e$var$e);
}, $894290b859ccd34e$export$2ca4a66ec4cecb90 = (e3, n4)=>{
    $894290b859ccd34e$export$b4d10f6001c083c2 ? e3.adoptedStyleSheets = n4.map((t6)=>t6 instanceof CSSStyleSheet ? t6 : t6.styleSheet) : n4.forEach((t7)=>{
        const n5 = document.createElement("style"), s4 = window.litNonce;
        void 0 !== s4 && n5.setAttribute("nonce", s4), n5.textContent = t7.cssText, e3.appendChild(n5);
    });
}, $894290b859ccd34e$export$ee69dfd951e24778 = $894290b859ccd34e$export$b4d10f6001c083c2 ? (t8)=>t8 : (t9)=>t9 instanceof CSSStyleSheet ? ((t10)=>{
        let e4 = "";
        for (const n6 of t10.cssRules)e4 += n6.cssText;
        return $894290b859ccd34e$export$8d80f9cac07cdb3(e4);
    })(t9) : t9;

});


parcelRequire.register("b87GI", function(module, exports) {

$parcel$export(module.exports, "html", () => $81a667bd6400fe08$export$c0bb0b647f701bb5);
$parcel$export(module.exports, "noChange", () => $81a667bd6400fe08$export$9c068ae9cc5db4e8);
$parcel$export(module.exports, "render", () => $81a667bd6400fe08$export$b3890eb0ae9dca99);
$parcel$export(module.exports, "_$LH", () => $81a667bd6400fe08$export$8613d1ca9052b22e);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var $81a667bd6400fe08$var$t;
const $81a667bd6400fe08$var$i = globalThis.trustedTypes, $81a667bd6400fe08$var$s = $81a667bd6400fe08$var$i ? $81a667bd6400fe08$var$i.createPolicy("lit-html", {
    createHTML: (t1)=>t1
}) : void 0, $81a667bd6400fe08$var$e = `lit$${(Math.random() + "").slice(9)}$`, $81a667bd6400fe08$var$o = "?" + $81a667bd6400fe08$var$e, $81a667bd6400fe08$var$n = `<${$81a667bd6400fe08$var$o}>`, $81a667bd6400fe08$var$l = document, $81a667bd6400fe08$var$h = (t2 = "")=>$81a667bd6400fe08$var$l.createComment(t2), $81a667bd6400fe08$var$r = (t3)=>null === t3 || "object" != typeof t3 && "function" != typeof t3, $81a667bd6400fe08$var$d = Array.isArray, $81a667bd6400fe08$var$u = (t4)=>{
    var i1;
    return $81a667bd6400fe08$var$d(t4) || "function" == typeof (null === (i1 = t4) || void 0 === i1 ? void 0 : i1[Symbol.iterator]);
}, $81a667bd6400fe08$var$c = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, $81a667bd6400fe08$var$v = /-->/g, $81a667bd6400fe08$var$a = />/g, $81a667bd6400fe08$var$f = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g, $81a667bd6400fe08$var$_ = /'/g, $81a667bd6400fe08$var$m = /"/g, $81a667bd6400fe08$var$g = /^(?:script|style|textarea|title)$/i, $81a667bd6400fe08$var$p = (t5)=>(i2, ...s1)=>({
            _$litType$: t5,
            strings: i2,
            values: s1
        }), $81a667bd6400fe08$export$c0bb0b647f701bb5 = $81a667bd6400fe08$var$p(1), $81a667bd6400fe08$export$7ed1367e7fa1ad68 = $81a667bd6400fe08$var$p(2), $81a667bd6400fe08$export$9c068ae9cc5db4e8 = Symbol.for("lit-noChange"), $81a667bd6400fe08$export$45b790e32b2810ee = Symbol.for("lit-nothing"), $81a667bd6400fe08$var$T = new WeakMap, $81a667bd6400fe08$export$b3890eb0ae9dca99 = (t7, i3, s2)=>{
    var e1, o1;
    const n1 = null !== (e1 = null == s2 ? void 0 : s2.renderBefore) && void 0 !== e1 ? e1 : i3;
    let l1 = n1._$litPart$;
    if (void 0 === l1) {
        const t6 = null !== (o1 = null == s2 ? void 0 : s2.renderBefore) && void 0 !== o1 ? o1 : null;
        n1._$litPart$ = l1 = new $81a667bd6400fe08$var$N(i3.insertBefore($81a667bd6400fe08$var$h(), t6), t6, void 0, null != s2 ? s2 : {});
    }
    return l1._$AI(t7), l1;
}, $81a667bd6400fe08$var$A = $81a667bd6400fe08$var$l.createTreeWalker($81a667bd6400fe08$var$l, 129, null, !1), $81a667bd6400fe08$var$C = (t8, i5)=>{
    const o2 = t8.length - 1, l2 = [];
    let h1, r1 = 2 === i5 ? "<svg>" : "", d1 = $81a667bd6400fe08$var$c;
    for(let i4 = 0; i4 < o2; i4++){
        const s3 = t8[i4];
        let o3, u1, p1 = -1, $1 = 0;
        for(; $1 < s3.length && (d1.lastIndex = $1, u1 = d1.exec(s3), null !== u1);)$1 = d1.lastIndex, d1 === $81a667bd6400fe08$var$c ? "!--" === u1[1] ? d1 = $81a667bd6400fe08$var$v : void 0 !== u1[1] ? d1 = $81a667bd6400fe08$var$a : void 0 !== u1[2] ? ($81a667bd6400fe08$var$g.test(u1[2]) && (h1 = RegExp("</" + u1[2], "g")), d1 = $81a667bd6400fe08$var$f) : void 0 !== u1[3] && (d1 = $81a667bd6400fe08$var$f) : d1 === $81a667bd6400fe08$var$f ? ">" === u1[0] ? (d1 = null != h1 ? h1 : $81a667bd6400fe08$var$c, p1 = -1) : void 0 === u1[1] ? p1 = -2 : (p1 = d1.lastIndex - u1[2].length, o3 = u1[1], d1 = void 0 === u1[3] ? $81a667bd6400fe08$var$f : '"' === u1[3] ? $81a667bd6400fe08$var$m : $81a667bd6400fe08$var$_) : d1 === $81a667bd6400fe08$var$m || d1 === $81a667bd6400fe08$var$_ ? d1 = $81a667bd6400fe08$var$f : d1 === $81a667bd6400fe08$var$v || d1 === $81a667bd6400fe08$var$a ? d1 = $81a667bd6400fe08$var$c : (d1 = $81a667bd6400fe08$var$f, h1 = void 0);
        const y1 = d1 === $81a667bd6400fe08$var$f && t8[i4 + 1].startsWith("/>") ? " " : "";
        r1 += d1 === $81a667bd6400fe08$var$c ? s3 + $81a667bd6400fe08$var$n : p1 >= 0 ? (l2.push(o3), s3.slice(0, p1) + "$lit$" + s3.slice(p1) + $81a667bd6400fe08$var$e + y1) : s3 + $81a667bd6400fe08$var$e + (-2 === p1 ? (l2.push(void 0), i4) : y1);
    }
    const u2 = r1 + (t8[o2] || "<?>") + (2 === i5 ? "</svg>" : "");
    if (!Array.isArray(t8) || !t8.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return [
        void 0 !== $81a667bd6400fe08$var$s ? $81a667bd6400fe08$var$s.createHTML(u2) : u2,
        l2
    ];
};
class $81a667bd6400fe08$var$E {
    constructor({ strings: t9 , _$litType$: s4  }, n2){
        let l3;
        this.parts = [];
        let r2 = 0, d2 = 0;
        const u3 = t9.length - 1, c1 = this.parts, [v1, a1] = $81a667bd6400fe08$var$C(t9, s4);
        if (this.el = $81a667bd6400fe08$var$E.createElement(v1, n2), $81a667bd6400fe08$var$A.currentNode = this.el.content, 2 === s4) {
            const t10 = this.el.content, i6 = t10.firstChild;
            i6.remove(), t10.append(...i6.childNodes);
        }
        for(; null !== (l3 = $81a667bd6400fe08$var$A.nextNode()) && c1.length < u3;){
            if (1 === l3.nodeType) {
                if (l3.hasAttributes()) {
                    const t11 = [];
                    for (const i8 of l3.getAttributeNames())if (i8.endsWith("$lit$") || i8.startsWith($81a667bd6400fe08$var$e)) {
                        const s5 = a1[d2++];
                        if (t11.push(i8), void 0 !== s5) {
                            const t12 = l3.getAttribute(s5.toLowerCase() + "$lit$").split($81a667bd6400fe08$var$e), i9 = /([.?@])?(.*)/.exec(s5);
                            c1.push({
                                type: 1,
                                index: r2,
                                name: i9[2],
                                strings: t12,
                                ctor: "." === i9[1] ? $81a667bd6400fe08$var$M : "?" === i9[1] ? $81a667bd6400fe08$var$H : "@" === i9[1] ? $81a667bd6400fe08$var$I : $81a667bd6400fe08$var$S
                            });
                        } else c1.push({
                            type: 6,
                            index: r2
                        });
                    }
                    for (const i7 of t11)l3.removeAttribute(i7);
                }
                if ($81a667bd6400fe08$var$g.test(l3.tagName)) {
                    const t13 = l3.textContent.split($81a667bd6400fe08$var$e), s6 = t13.length - 1;
                    if (s6 > 0) {
                        l3.textContent = $81a667bd6400fe08$var$i ? $81a667bd6400fe08$var$i.emptyScript : "";
                        for(let i10 = 0; i10 < s6; i10++)l3.append(t13[i10], $81a667bd6400fe08$var$h()), $81a667bd6400fe08$var$A.nextNode(), c1.push({
                            type: 2,
                            index: ++r2
                        });
                        l3.append(t13[s6], $81a667bd6400fe08$var$h());
                    }
                }
            } else if (8 === l3.nodeType) {
                if (l3.data === $81a667bd6400fe08$var$o) c1.push({
                    type: 2,
                    index: r2
                });
                else {
                    let t14 = -1;
                    for(; -1 !== (t14 = l3.data.indexOf($81a667bd6400fe08$var$e, t14 + 1));)c1.push({
                        type: 7,
                        index: r2
                    }), t14 += $81a667bd6400fe08$var$e.length - 1;
                }
            }
            r2++;
        }
    }
    static createElement(t15, i) {
        const s7 = $81a667bd6400fe08$var$l.createElement("template");
        return s7.innerHTML = t15, s7;
    }
}
function $81a667bd6400fe08$var$P(t16, i15, s8 = t16, e2) {
    var o4, n3, l4, h2;
    if (i15 === $81a667bd6400fe08$export$9c068ae9cc5db4e8) return i15;
    let d3 = void 0 !== e2 ? null === (o4 = s8._$Cl) || void 0 === o4 ? void 0 : o4[e2] : s8._$Cu;
    const u4 = $81a667bd6400fe08$var$r(i15) ? void 0 : i15._$litDirective$;
    return (null == d3 ? void 0 : d3.constructor) !== u4 && (null === (n3 = null == d3 ? void 0 : d3._$AO) || void 0 === n3 || n3.call(d3, !1), void 0 === u4 ? d3 = void 0 : (d3 = new u4(t16), d3._$AT(t16, s8, e2)), void 0 !== e2 ? (null !== (l4 = (h2 = s8)._$Cl) && void 0 !== l4 ? l4 : h2._$Cl = [])[e2] = d3 : s8._$Cu = d3), void 0 !== d3 && (i15 = $81a667bd6400fe08$var$P(t16, d3._$AS(t16, i15.values), d3, e2)), i15;
}
class $81a667bd6400fe08$var$V {
    constructor(t17, i16){
        this.v = [], this._$AN = void 0, this._$AD = t17, this._$AM = i16;
    }
    get parentNode() {
        return this._$AM.parentNode;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    p(t18) {
        var i17;
        const { el: { content: s9  } , parts: e3  } = this._$AD, o5 = (null !== (i17 = null == t18 ? void 0 : t18.creationScope) && void 0 !== i17 ? i17 : $81a667bd6400fe08$var$l).importNode(s9, !0);
        $81a667bd6400fe08$var$A.currentNode = o5;
        let n4 = $81a667bd6400fe08$var$A.nextNode(), h3 = 0, r3 = 0, d4 = e3[0];
        for(; void 0 !== d4;){
            if (h3 === d4.index) {
                let i18;
                2 === d4.type ? i18 = new $81a667bd6400fe08$var$N(n4, n4.nextSibling, this, t18) : 1 === d4.type ? i18 = new d4.ctor(n4, d4.name, d4.strings, this, t18) : 6 === d4.type && (i18 = new $81a667bd6400fe08$var$L(n4, this, t18)), this.v.push(i18), d4 = e3[++r3];
            }
            h3 !== (null == d4 ? void 0 : d4.index) && (n4 = $81a667bd6400fe08$var$A.nextNode(), h3++);
        }
        return o5;
    }
    m(t19) {
        let i19 = 0;
        for (const s10 of this.v)void 0 !== s10 && (void 0 !== s10.strings ? (s10._$AI(t19, s10, i19), i19 += s10.strings.length - 2) : s10._$AI(t19[i19])), i19++;
    }
}
class $81a667bd6400fe08$var$N {
    constructor(t20, i20, s11, e4){
        var o6;
        this.type = 2, this._$AH = $81a667bd6400fe08$export$45b790e32b2810ee, this._$AN = void 0, this._$AA = t20, this._$AB = i20, this._$AM = s11, this.options = e4, this._$Cg = null === (o6 = null == e4 ? void 0 : e4.isConnected) || void 0 === o6 || o6;
    }
    get _$AU() {
        var t21, i21;
        return null !== (i21 = null === (t21 = this._$AM) || void 0 === t21 ? void 0 : t21._$AU) && void 0 !== i21 ? i21 : this._$Cg;
    }
    get parentNode() {
        let t22 = this._$AA.parentNode;
        const i22 = this._$AM;
        return void 0 !== i22 && 11 === t22.nodeType && (t22 = i22.parentNode), t22;
    }
    get startNode() {
        return this._$AA;
    }
    get endNode() {
        return this._$AB;
    }
    _$AI(t23, i23 = this) {
        t23 = $81a667bd6400fe08$var$P(this, t23, i23), $81a667bd6400fe08$var$r(t23) ? t23 === $81a667bd6400fe08$export$45b790e32b2810ee || null == t23 || "" === t23 ? (this._$AH !== $81a667bd6400fe08$export$45b790e32b2810ee && this._$AR(), this._$AH = $81a667bd6400fe08$export$45b790e32b2810ee) : t23 !== this._$AH && t23 !== $81a667bd6400fe08$export$9c068ae9cc5db4e8 && this.$(t23) : void 0 !== t23._$litType$ ? this.T(t23) : void 0 !== t23.nodeType ? this.k(t23) : $81a667bd6400fe08$var$u(t23) ? this.S(t23) : this.$(t23);
    }
    M(t24, i24 = this._$AB) {
        return this._$AA.parentNode.insertBefore(t24, i24);
    }
    k(t25) {
        this._$AH !== t25 && (this._$AR(), this._$AH = this.M(t25));
    }
    $(t26) {
        this._$AH !== $81a667bd6400fe08$export$45b790e32b2810ee && $81a667bd6400fe08$var$r(this._$AH) ? this._$AA.nextSibling.data = t26 : this.k($81a667bd6400fe08$var$l.createTextNode(t26)), this._$AH = t26;
    }
    T(t27) {
        var i25;
        const { values: s12 , _$litType$: e5  } = t27, o7 = "number" == typeof e5 ? this._$AC(t27) : (void 0 === e5.el && (e5.el = $81a667bd6400fe08$var$E.createElement(e5.h, this.options)), e5);
        if ((null === (i25 = this._$AH) || void 0 === i25 ? void 0 : i25._$AD) === o7) this._$AH.m(s12);
        else {
            const t28 = new $81a667bd6400fe08$var$V(o7, this), i26 = t28.p(this.options);
            t28.m(s12), this.k(i26), this._$AH = t28;
        }
    }
    _$AC(t29) {
        let i27 = $81a667bd6400fe08$var$T.get(t29.strings);
        return void 0 === i27 && $81a667bd6400fe08$var$T.set(t29.strings, i27 = new $81a667bd6400fe08$var$E(t29)), i27;
    }
    S(t30) {
        $81a667bd6400fe08$var$d(this._$AH) || (this._$AH = [], this._$AR());
        const i28 = this._$AH;
        let s13, e6 = 0;
        for (const o8 of t30)e6 === i28.length ? i28.push(s13 = new $81a667bd6400fe08$var$N(this.M($81a667bd6400fe08$var$h()), this.M($81a667bd6400fe08$var$h()), this, this.options)) : s13 = i28[e6], s13._$AI(o8), e6++;
        e6 < i28.length && (this._$AR(s13 && s13._$AB.nextSibling, e6), i28.length = e6);
    }
    _$AR(t31 = this._$AA.nextSibling, i29) {
        var s14;
        for(null === (s14 = this._$AP) || void 0 === s14 || s14.call(this, !1, !0, i29); t31 && t31 !== this._$AB;){
            const i30 = t31.nextSibling;
            t31.remove(), t31 = i30;
        }
    }
    setConnected(t32) {
        var i31;
        void 0 === this._$AM && (this._$Cg = t32, null === (i31 = this._$AP) || void 0 === i31 || i31.call(this, t32));
    }
}
class $81a667bd6400fe08$var$S {
    constructor(t33, i32, s15, e7, o9){
        this.type = 1, this._$AH = $81a667bd6400fe08$export$45b790e32b2810ee, this._$AN = void 0, this.element = t33, this.name = i32, this._$AM = e7, this.options = o9, s15.length > 2 || "" !== s15[0] || "" !== s15[1] ? (this._$AH = Array(s15.length - 1).fill(new String), this.strings = s15) : this._$AH = $81a667bd6400fe08$export$45b790e32b2810ee;
    }
    get tagName() {
        return this.element.tagName;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(t34, i33 = this, s16, e9) {
        const o10 = this.strings;
        let n5 = !1;
        if (void 0 === o10) t34 = $81a667bd6400fe08$var$P(this, t34, i33, 0), n5 = !$81a667bd6400fe08$var$r(t34) || t34 !== this._$AH && t34 !== $81a667bd6400fe08$export$9c068ae9cc5db4e8, n5 && (this._$AH = t34);
        else {
            const e8 = t34;
            let l5, h4;
            for(t34 = o10[0], l5 = 0; l5 < o10.length - 1; l5++)h4 = $81a667bd6400fe08$var$P(this, e8[s16 + l5], i33, l5), h4 === $81a667bd6400fe08$export$9c068ae9cc5db4e8 && (h4 = this._$AH[l5]), n5 || (n5 = !$81a667bd6400fe08$var$r(h4) || h4 !== this._$AH[l5]), h4 === $81a667bd6400fe08$export$45b790e32b2810ee ? t34 = $81a667bd6400fe08$export$45b790e32b2810ee : t34 !== $81a667bd6400fe08$export$45b790e32b2810ee && (t34 += (null != h4 ? h4 : "") + o10[l5 + 1]), this._$AH[l5] = h4;
        }
        n5 && !e9 && this.C(t34);
    }
    C(t35) {
        t35 === $81a667bd6400fe08$export$45b790e32b2810ee ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t35 ? t35 : "");
    }
}
class $81a667bd6400fe08$var$M extends $81a667bd6400fe08$var$S {
    constructor(){
        super(...arguments), this.type = 3;
    }
    C(t36) {
        this.element[this.name] = t36 === $81a667bd6400fe08$export$45b790e32b2810ee ? void 0 : t36;
    }
}
const $81a667bd6400fe08$var$k = $81a667bd6400fe08$var$i ? $81a667bd6400fe08$var$i.emptyScript : "";
class $81a667bd6400fe08$var$H extends $81a667bd6400fe08$var$S {
    constructor(){
        super(...arguments), this.type = 4;
    }
    C(t37) {
        t37 && t37 !== $81a667bd6400fe08$export$45b790e32b2810ee ? this.element.setAttribute(this.name, $81a667bd6400fe08$var$k) : this.element.removeAttribute(this.name);
    }
}
class $81a667bd6400fe08$var$I extends $81a667bd6400fe08$var$S {
    constructor(t38, i34, s17, e10, o11){
        super(t38, i34, s17, e10, o11), this.type = 5;
    }
    _$AI(t39, i35 = this) {
        var s18;
        if ((t39 = null !== (s18 = $81a667bd6400fe08$var$P(this, t39, i35, 0)) && void 0 !== s18 ? s18 : $81a667bd6400fe08$export$45b790e32b2810ee) === $81a667bd6400fe08$export$9c068ae9cc5db4e8) return;
        const e11 = this._$AH, o12 = t39 === $81a667bd6400fe08$export$45b790e32b2810ee && e11 !== $81a667bd6400fe08$export$45b790e32b2810ee || t39.capture !== e11.capture || t39.once !== e11.once || t39.passive !== e11.passive, n6 = t39 !== $81a667bd6400fe08$export$45b790e32b2810ee && (e11 === $81a667bd6400fe08$export$45b790e32b2810ee || o12);
        o12 && this.element.removeEventListener(this.name, this, e11), n6 && this.element.addEventListener(this.name, this, t39), this._$AH = t39;
    }
    handleEvent(t40) {
        var i36, s19;
        "function" == typeof this._$AH ? this._$AH.call(null !== (s19 = null === (i36 = this.options) || void 0 === i36 ? void 0 : i36.host) && void 0 !== s19 ? s19 : this.element, t40) : this._$AH.handleEvent(t40);
    }
}
class $81a667bd6400fe08$var$L {
    constructor(t41, i37, s20){
        this.element = t41, this.type = 6, this._$AN = void 0, this._$AM = i37, this.options = s20;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(t42) {
        $81a667bd6400fe08$var$P(this, t42);
    }
}
const $81a667bd6400fe08$export$8613d1ca9052b22e = {
    L: "$lit$",
    P: $81a667bd6400fe08$var$e,
    V: $81a667bd6400fe08$var$o,
    I: 1,
    N: $81a667bd6400fe08$var$C,
    R: $81a667bd6400fe08$var$V,
    j: $81a667bd6400fe08$var$u,
    D: $81a667bd6400fe08$var$P,
    H: $81a667bd6400fe08$var$N,
    F: $81a667bd6400fe08$var$S,
    O: $81a667bd6400fe08$var$H,
    W: $81a667bd6400fe08$var$I,
    B: $81a667bd6400fe08$var$M,
    Z: $81a667bd6400fe08$var$L
}, $81a667bd6400fe08$var$z = window.litHtmlPolyfillSupport;
null == $81a667bd6400fe08$var$z || $81a667bd6400fe08$var$z($81a667bd6400fe08$var$E, $81a667bd6400fe08$var$N), (null !== ($81a667bd6400fe08$var$t = globalThis.litHtmlVersions) && void 0 !== $81a667bd6400fe08$var$t ? $81a667bd6400fe08$var$t : globalThis.litHtmlVersions = []).push("2.2.6");

});

parcelRequire.register("abcsE", function(module, exports) {
$parcel$export(module.exports, "ReactiveElement", () => (parcelRequire("gR0bR")).ReactiveElement);
$parcel$export(module.exports, "html", () => (parcelRequire("b87GI")).html);
$parcel$export(module.exports, "render", () => (parcelRequire("b87GI")).render);
$parcel$export(module.exports, "noChange", () => (parcelRequire("b87GI")).noChange);

var $gR0bR = parcelRequire("gR0bR");

var $gR0bR = parcelRequire("gR0bR");

var $b87GI = parcelRequire("b87GI");

var $b87GI = parcelRequire("b87GI");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var $769498fb1d04e3ee$var$l, $769498fb1d04e3ee$var$o;
const $769498fb1d04e3ee$export$8bf27daf9e8907c9 = (0, $gR0bR.ReactiveElement);
class $769498fb1d04e3ee$export$3f2f9f5909897157 extends (0, $gR0bR.ReactiveElement) {
    constructor(){
        super(...arguments), this.renderOptions = {
            host: this
        }, this._$Do = void 0;
    }
    createRenderRoot() {
        var t1, e1;
        const i1 = super.createRenderRoot();
        return null !== (t1 = (e1 = this.renderOptions).renderBefore) && void 0 !== t1 || (e1.renderBefore = i1.firstChild), i1;
    }
    update(t2) {
        const i2 = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = (0, $b87GI.render)(i2, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
        var t3;
        super.connectedCallback(), null === (t3 = this._$Do) || void 0 === t3 || t3.setConnected(!0);
    }
    disconnectedCallback() {
        var t4;
        super.disconnectedCallback(), null === (t4 = this._$Do) || void 0 === t4 || t4.setConnected(!1);
    }
    render() {
        return 0, $b87GI.noChange;
    }
}
$769498fb1d04e3ee$export$3f2f9f5909897157.finalized = !0, $769498fb1d04e3ee$export$3f2f9f5909897157._$litElement$ = !0, null === ($769498fb1d04e3ee$var$l = globalThis.litElementHydrateSupport) || void 0 === $769498fb1d04e3ee$var$l || $769498fb1d04e3ee$var$l.call(globalThis, {
    LitElement: $769498fb1d04e3ee$export$3f2f9f5909897157
});
const $769498fb1d04e3ee$var$n = globalThis.litElementPolyfillSupport;
null == $769498fb1d04e3ee$var$n || $769498fb1d04e3ee$var$n({
    LitElement: $769498fb1d04e3ee$export$3f2f9f5909897157
});
const $769498fb1d04e3ee$export$f5c524615a7708d6 = {
    _$AK: (t5, e2, i3)=>{
        t5._$AK(e2, i3);
    },
    _$AL: (t6)=>t6._$AL
};
(null !== ($769498fb1d04e3ee$var$o = globalThis.litElementVersions) && void 0 !== $769498fb1d04e3ee$var$o ? $769498fb1d04e3ee$var$o : globalThis.litElementVersions = []).push("3.2.1");

});


parcelRequire.register("kw5CQ", function(module, exports) {

$parcel$export(module.exports, "default", () => $eefb28e7004b2ac2$export$2e2bcd8739ae039);

var $hWFdF = parcelRequire("hWFdF");

var $c79Es = parcelRequire("c79Es");

var $8VjOw = parcelRequire("8VjOw");

var $4ewR7 = parcelRequire("4ewR7");
var $eefb28e7004b2ac2$var$highlighter = (0, $hWFdF.default)((0, (/*@__PURE__*/$parcel$interopDefault($8VjOw))), (0, $c79Es.default));
$eefb28e7004b2ac2$var$highlighter.supportedLanguages = (0, $4ewR7.default);
var $eefb28e7004b2ac2$export$2e2bcd8739ae039 = $eefb28e7004b2ac2$var$highlighter;

});
parcelRequire.register("hWFdF", function(module, exports) {

$parcel$export(module.exports, "default", () => $d107d3cb6040c206$export$2e2bcd8739ae039);

var $3pdRn = parcelRequire("3pdRn");

var $1brxq = parcelRequire("1brxq");

var $9VMpY = parcelRequire("9VMpY");

var $5pYYS = parcelRequire("5pYYS");

var $2hNQe = parcelRequire("2hNQe");

var $dkNkF = parcelRequire("dkNkF");
var $d107d3cb6040c206$var$_excluded = [
    "language",
    "children",
    "style",
    "customStyle",
    "codeTagProps",
    "useInlineStyles",
    "showLineNumbers",
    "showInlineLineNumbers",
    "startingLineNumber",
    "lineNumberContainerStyle",
    "lineNumberStyle",
    "wrapLines",
    "wrapLongLines",
    "lineProps",
    "renderer",
    "PreTag",
    "CodeTag",
    "code",
    "astGenerator"
];
function $d107d3cb6040c206$var$ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function $d107d3cb6040c206$var$_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? $d107d3cb6040c206$var$ownKeys(Object(source), !0).forEach(function(key) {
            (0, (/*@__PURE__*/$parcel$interopDefault($9VMpY)))(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : $d107d3cb6040c206$var$ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
var $d107d3cb6040c206$var$newLineRegex = /\n/g;
function $d107d3cb6040c206$var$getNewLines(str) {
    return str.match($d107d3cb6040c206$var$newLineRegex);
}
function $d107d3cb6040c206$var$getAllLineNumbers(_ref) {
    var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style = _ref.style;
    return lines.map(function(_, i) {
        var number = i + startingLineNumber;
        return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement("span", {
            key: "line-".concat(i),
            className: "react-syntax-highlighter-line-number",
            style: typeof style === "function" ? style(number) : style
        }, "".concat(number, "\n"));
    });
}
function $d107d3cb6040c206$var$AllLineNumbers(_ref2) {
    var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
        "float": "left",
        paddingRight: "10px"
    } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
    return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement("code", {
        style: Object.assign({}, codeStyle, containerStyle)
    }, $d107d3cb6040c206$var$getAllLineNumbers({
        lines: codeString.replace(/\n$/, "").split("\n"),
        style: numberStyle,
        startingLineNumber: startingLineNumber
    }));
}
function $d107d3cb6040c206$var$getEmWidthOfNumber(num) {
    return "".concat(num.toString().length, ".25em");
}
function $d107d3cb6040c206$var$getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
    return {
        type: "element",
        tagName: "span",
        properties: {
            key: "line-number--".concat(lineNumber),
            className: [
                "comment",
                "linenumber",
                "react-syntax-highlighter-line-number"
            ],
            style: inlineLineNumberStyle
        },
        children: [
            {
                type: "text",
                value: lineNumber
            }
        ]
    };
}
function $d107d3cb6040c206$var$assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
    // minimally necessary styling for line numbers
    var defaultLineNumberStyle = {
        display: "inline-block",
        minWidth: $d107d3cb6040c206$var$getEmWidthOfNumber(largestLineNumber),
        paddingRight: "1em",
        textAlign: "right",
        userSelect: "none"
    }; // prep custom styling
    var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle; // combine
    var assembledStyle = $d107d3cb6040c206$var$_objectSpread($d107d3cb6040c206$var$_objectSpread({}, defaultLineNumberStyle), customLineNumberStyle);
    return assembledStyle;
}
function $d107d3cb6040c206$var$createLineElement(_ref3) {
    var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines;
    var properties = typeof lineProps === "function" ? lineProps(lineNumber) : lineProps;
    properties["className"] = className;
    if (lineNumber && showInlineLineNumbers) {
        var inlineLineNumberStyle = $d107d3cb6040c206$var$assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
        children.unshift($d107d3cb6040c206$var$getInlineLineNumber(lineNumber, inlineLineNumberStyle));
    }
    if (wrapLongLines & showLineNumbers) properties.style = $d107d3cb6040c206$var$_objectSpread($d107d3cb6040c206$var$_objectSpread({}, properties.style), {}, {
        display: "flex"
    });
    return {
        type: "element",
        tagName: "span",
        properties: properties,
        children: children
    };
}
function $d107d3cb6040c206$var$flattenCodeTree(tree) {
    var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var newTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    for(var i1 = 0; i1 < tree.length; i1++){
        var node = tree[i1];
        if (node.type === "text") newTree.push($d107d3cb6040c206$var$createLineElement({
            children: [
                node
            ],
            className: (0, (/*@__PURE__*/$parcel$interopDefault($1brxq)))(new Set(className))
        }));
        else if (node.children) {
            var classNames = className.concat(node.properties.className);
            $d107d3cb6040c206$var$flattenCodeTree(node.children, classNames).forEach(function(i) {
                return newTree.push(i);
            });
        }
    }
    return newTree;
}
function $d107d3cb6040c206$var$processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
    var _ref4;
    var tree = $d107d3cb6040c206$var$flattenCodeTree(codeTree.value);
    var newTree = [];
    var lastLineBreakIndex = -1;
    var index = 0;
    function createWrappedLine(children, lineNumber) {
        var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        return $d107d3cb6040c206$var$createLineElement({
            children: children,
            lineNumber: lineNumber,
            lineNumberStyle: lineNumberStyle,
            largestLineNumber: largestLineNumber,
            showInlineLineNumbers: showInlineLineNumbers,
            lineProps: lineProps,
            className: className,
            showLineNumbers: showLineNumbers,
            wrapLongLines: wrapLongLines
        });
    }
    function createUnwrappedLine(children, lineNumber) {
        if (showLineNumbers && lineNumber && showInlineLineNumbers) {
            var inlineLineNumberStyle = $d107d3cb6040c206$var$assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
            children.unshift($d107d3cb6040c206$var$getInlineLineNumber(lineNumber, inlineLineNumberStyle));
        }
        return children;
    }
    function createLine(children, lineNumber) {
        var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        return wrapLines || className.length > 0 ? createWrappedLine(children, lineNumber, className) : createUnwrappedLine(children, lineNumber);
    }
    var _loop = function _loop() {
        var node = tree[index];
        var value = node.children[0].value;
        var newLines = $d107d3cb6040c206$var$getNewLines(value);
        if (newLines) {
            var splitValue = value.split("\n");
            splitValue.forEach(function(text, i) {
                var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
                var newChild = {
                    type: "text",
                    value: "".concat(text, "\n")
                }; // if it's the first line
                if (i === 0) {
                    var _children = tree.slice(lastLineBreakIndex + 1, index).concat($d107d3cb6040c206$var$createLineElement({
                        children: [
                            newChild
                        ],
                        className: node.properties.className
                    }));
                    var _line = createLine(_children, lineNumber);
                    newTree.push(_line); // if it's the last line
                } else if (i === splitValue.length - 1) {
                    var stringChild = tree[index + 1] && tree[index + 1].children && tree[index + 1].children[0];
                    var lastLineInPreviousSpan = {
                        type: "text",
                        value: "".concat(text)
                    };
                    if (stringChild) {
                        var newElem = $d107d3cb6040c206$var$createLineElement({
                            children: [
                                lastLineInPreviousSpan
                            ],
                            className: node.properties.className
                        });
                        tree.splice(index + 1, 0, newElem);
                    } else {
                        var _children2 = [
                            lastLineInPreviousSpan
                        ];
                        var _line2 = createLine(_children2, lineNumber, node.properties.className);
                        newTree.push(_line2);
                    } // if it's neither the first nor the last line
                } else {
                    var _children3 = [
                        newChild
                    ];
                    var _line3 = createLine(_children3, lineNumber, node.properties.className);
                    newTree.push(_line3);
                }
            });
            lastLineBreakIndex = index;
        }
        index++;
    };
    while(index < tree.length)_loop();
    if (lastLineBreakIndex !== tree.length - 1) {
        var children1 = tree.slice(lastLineBreakIndex + 1, tree.length);
        if (children1 && children1.length) {
            var lineNumber1 = showLineNumbers && newTree.length + startingLineNumber;
            var line = createLine(children1, lineNumber1);
            newTree.push(line);
        }
    }
    return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function $d107d3cb6040c206$var$defaultRenderer(_ref5) {
    var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
    return rows.map(function(node, i) {
        return (0, $2hNQe.default)({
            node: node,
            stylesheet: stylesheet,
            useInlineStyles: useInlineStyles,
            key: "code-segement".concat(i)
        });
    });
} // only highlight.js has the highlightAuto method
function $d107d3cb6040c206$var$isHighlightJs(astGenerator) {
    return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
}
function $d107d3cb6040c206$var$getCodeTree(_ref6) {
    var astGenerator = _ref6.astGenerator, language = _ref6.language, code = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
    // figure out whether we're using lowlight/highlight or refractor/prism
    // then attempt highlighting accordingly
    // lowlight/highlight?
    if ($d107d3cb6040c206$var$isHighlightJs(astGenerator)) {
        var hasLanguage = (0, $dkNkF.default)(astGenerator, language);
        if (language === "text") return {
            value: defaultCodeValue,
            language: "text"
        };
        else if (hasLanguage) return astGenerator.highlight(language, code);
        else return astGenerator.highlightAuto(code);
    } // must be refractor/prism, then
    try {
        return language && language !== "text" ? {
            value: astGenerator.highlight(code, language)
        } : {
            value: defaultCodeValue
        };
    } catch (e) {
        return {
            value: defaultCodeValue
        };
    }
}
function $d107d3cb6040c206$export$2e2bcd8739ae039(defaultAstGenerator, defaultStyle) {
    return function SyntaxHighlighter(_ref7) {
        var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
            className: language ? "language-".concat(language) : undefined,
            style: $d107d3cb6040c206$var$_objectSpread($d107d3cb6040c206$var$_objectSpread({}, style['code[class*="language-"]']), style['code[class*="language-'.concat(language, '"]')])
        } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = (0, (/*@__PURE__*/$parcel$interopDefault($3pdRn)))(_ref7, $d107d3cb6040c206$var$_excluded);
        astGenerator = astGenerator || defaultAstGenerator;
        var allLineNumbers = showLineNumbers ? /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement($d107d3cb6040c206$var$AllLineNumbers, {
            containerStyle: lineNumberContainerStyle,
            codeStyle: codeTagProps.style || {},
            numberStyle: lineNumberStyle,
            startingLineNumber: startingLineNumber,
            codeString: code
        }) : null;
        var defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
            backgroundColor: "#fff"
        };
        var generatorClassName = $d107d3cb6040c206$var$isHighlightJs(astGenerator) ? "hljs" : "prismjs";
        var preProps = useInlineStyles ? Object.assign({}, rest, {
            style: Object.assign({}, defaultPreStyle, customStyle)
        }) : Object.assign({}, rest, {
            className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
            style: Object.assign({}, customStyle)
        });
        if (wrapLongLines) codeTagProps.style = $d107d3cb6040c206$var$_objectSpread($d107d3cb6040c206$var$_objectSpread({}, codeTagProps.style), {}, {
            whiteSpace: "pre-wrap"
        });
        else codeTagProps.style = $d107d3cb6040c206$var$_objectSpread($d107d3cb6040c206$var$_objectSpread({}, codeTagProps.style), {}, {
            whiteSpace: "pre"
        });
        if (!astGenerator) return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement(PreTag, preProps, allLineNumbers, /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement(CodeTag, codeTagProps, code));
        /*
     * Some custom renderers rely on individual row elements so we need to turn wrapLines on
     * if renderer is provided and wrapLines is undefined.
     */ if (wrapLines === undefined && renderer || wrapLongLines) wrapLines = true;
        renderer = renderer || $d107d3cb6040c206$var$defaultRenderer;
        var defaultCodeValue = [
            {
                type: "text",
                value: code
            }
        ];
        var codeTree = $d107d3cb6040c206$var$getCodeTree({
            astGenerator: astGenerator,
            language: language,
            code: code,
            defaultCodeValue: defaultCodeValue
        });
        if (codeTree.language === null) codeTree.value = defaultCodeValue;
         // determine largest line number so that we can force minWidth on all linenumber elements
        var largestLineNumber = codeTree.value.length + startingLineNumber;
        var rows = $d107d3cb6040c206$var$processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
        return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement(PreTag, preProps, /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
            rows: rows,
            stylesheet: style,
            useInlineStyles: useInlineStyles
        })));
    };
}

});
parcelRequire.register("3pdRn", function(module, exports) {

var $5C59w = parcelRequire("5C59w");
function $27ae7533d51b94dc$var$_objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = $5C59w(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
module.exports = $27ae7533d51b94dc$var$_objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;

});
parcelRequire.register("5C59w", function(module, exports) {
function $41647f8df8673357$var$_objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
module.exports = $41647f8df8673357$var$_objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;

});


parcelRequire.register("1brxq", function(module, exports) {

var $Qvp2N = parcelRequire("Qvp2N");

var $lHBDQ = parcelRequire("lHBDQ");

var $01Nsz = parcelRequire("01Nsz");

var $hNSUL = parcelRequire("hNSUL");
function $0dcc2e085ce9c70f$var$_toConsumableArray(arr) {
    return $Qvp2N(arr) || $lHBDQ(arr) || $01Nsz(arr) || $hNSUL();
}
module.exports = $0dcc2e085ce9c70f$var$_toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

});
parcelRequire.register("Qvp2N", function(module, exports) {

var $dFcjQ = parcelRequire("dFcjQ");
function $09dd376992894e26$var$_arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return $dFcjQ(arr);
}
module.exports = $09dd376992894e26$var$_arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

});
parcelRequire.register("dFcjQ", function(module, exports) {
function $9f28a8fc74755018$var$_arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
module.exports = $9f28a8fc74755018$var$_arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

});


parcelRequire.register("lHBDQ", function(module, exports) {
function $fccacff6e3db5dfc$var$_iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = $fccacff6e3db5dfc$var$_iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

});

parcelRequire.register("01Nsz", function(module, exports) {

var $dFcjQ = parcelRequire("dFcjQ");
function $005675cd27fb9dd8$var$_unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return $dFcjQ(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return $dFcjQ(o, minLen);
}
module.exports = $005675cd27fb9dd8$var$_unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

});

parcelRequire.register("hNSUL", function(module, exports) {
function $cf619c280c3ad6e0$var$_nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = $cf619c280c3ad6e0$var$_nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

});


parcelRequire.register("9VMpY", function(module, exports) {
function $73aefebc380ae7b6$var$_defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
module.exports = $73aefebc380ae7b6$var$_defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

});

parcelRequire.register("2hNQe", function(module, exports) {

$parcel$export(module.exports, "default", () => $1aa3d4c6cc6b2bab$export$2e2bcd8739ae039);

var $lwnIT = parcelRequire("lwnIT");

var $9VMpY = parcelRequire("9VMpY");

var $5pYYS = parcelRequire("5pYYS");
function $1aa3d4c6cc6b2bab$var$ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function $1aa3d4c6cc6b2bab$var$_objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? $1aa3d4c6cc6b2bab$var$ownKeys(Object(source), !0).forEach(function(key) {
            (0, (/*@__PURE__*/$parcel$interopDefault($9VMpY)))(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : $1aa3d4c6cc6b2bab$var$ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
//
// Super simple, non-algorithmic solution since the
// number of class names will not be greater than 4
function $1aa3d4c6cc6b2bab$var$powerSetPermutations(arr) {
    var arrLength = arr.length;
    if (arrLength === 0 || arrLength === 1) return arr;
    if (arrLength === 2) // prettier-ignore
    return [
        arr[0],
        arr[1],
        "".concat(arr[0], ".").concat(arr[1]),
        "".concat(arr[1], ".").concat(arr[0])
    ];
    if (arrLength === 3) return [
        arr[0],
        arr[1],
        arr[2],
        "".concat(arr[0], ".").concat(arr[1]),
        "".concat(arr[0], ".").concat(arr[2]),
        "".concat(arr[1], ".").concat(arr[0]),
        "".concat(arr[1], ".").concat(arr[2]),
        "".concat(arr[2], ".").concat(arr[0]),
        "".concat(arr[2], ".").concat(arr[1]),
        "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]),
        "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]),
        "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]),
        "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]),
        "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]),
        "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])
    ];
    if (arrLength >= 4) // Currently does not support more than 4 extra
    // class names (after `.token` has been removed)
    return [
        arr[0],
        arr[1],
        arr[2],
        arr[3],
        "".concat(arr[0], ".").concat(arr[1]),
        "".concat(arr[0], ".").concat(arr[2]),
        "".concat(arr[0], ".").concat(arr[3]),
        "".concat(arr[1], ".").concat(arr[0]),
        "".concat(arr[1], ".").concat(arr[2]),
        "".concat(arr[1], ".").concat(arr[3]),
        "".concat(arr[2], ".").concat(arr[0]),
        "".concat(arr[2], ".").concat(arr[1]),
        "".concat(arr[2], ".").concat(arr[3]),
        "".concat(arr[3], ".").concat(arr[0]),
        "".concat(arr[3], ".").concat(arr[1]),
        "".concat(arr[3], ".").concat(arr[2]),
        "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]),
        "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]),
        "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]),
        "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]),
        "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]),
        "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]),
        "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]),
        "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]),
        "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]),
        "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]),
        "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]),
        "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]),
        "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]),
        "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]),
        "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]),
        "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]),
        "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]),
        "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]),
        "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]),
        "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]),
        "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]),
        "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]),
        "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]),
        "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]),
        "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]),
        "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]),
        "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]),
        "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]),
        "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]),
        "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]),
        "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]),
        "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]),
        "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]),
        "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]),
        "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]),
        "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]),
        "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]),
        "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]),
        "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]),
        "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]),
        "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]),
        "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]),
        "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]),
        "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]),
        "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]),
        "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]),
        "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]),
        "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])
    ];
}
var $1aa3d4c6cc6b2bab$var$classNameCombinations = {};
function $1aa3d4c6cc6b2bab$var$getClassNameCombinations(classNames) {
    if (classNames.length === 0 || classNames.length === 1) return classNames;
    var key = classNames.join(".");
    if (!$1aa3d4c6cc6b2bab$var$classNameCombinations[key]) $1aa3d4c6cc6b2bab$var$classNameCombinations[key] = $1aa3d4c6cc6b2bab$var$powerSetPermutations(classNames);
    return $1aa3d4c6cc6b2bab$var$classNameCombinations[key];
}
function $1aa3d4c6cc6b2bab$export$28a8c6cb018dfadc(classNames) {
    var elementStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var stylesheet = arguments.length > 2 ? arguments[2] : undefined;
    var nonTokenClassNames = classNames.filter(function(className) {
        return className !== "token";
    });
    var classNamesCombinations = $1aa3d4c6cc6b2bab$var$getClassNameCombinations(nonTokenClassNames);
    return classNamesCombinations.reduce(function(styleObject, className) {
        return $1aa3d4c6cc6b2bab$var$_objectSpread($1aa3d4c6cc6b2bab$var$_objectSpread({}, styleObject), stylesheet[className]);
    }, elementStyle);
}
function $1aa3d4c6cc6b2bab$export$d0f1f443a3b7b5(classNames) {
    return classNames.join(" ");
}
function $1aa3d4c6cc6b2bab$export$86fb3c3a621e8db6(stylesheet, useInlineStyles) {
    var childrenCount = 0;
    return function(children) {
        childrenCount += 1;
        return children.map(function(child, i) {
            return $1aa3d4c6cc6b2bab$export$2e2bcd8739ae039({
                node: child,
                stylesheet: stylesheet,
                useInlineStyles: useInlineStyles,
                key: "code-segment-".concat(childrenCount, "-").concat(i)
            });
        });
    };
}
function $1aa3d4c6cc6b2bab$export$2e2bcd8739ae039(_ref) {
    var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key;
    var properties = node.properties, type = node.type, TagName = node.tagName, value = node.value;
    if (type === "text") return value;
    else if (TagName) {
        var childrenCreator = $1aa3d4c6cc6b2bab$export$86fb3c3a621e8db6(stylesheet, useInlineStyles);
        var props;
        if (!useInlineStyles) props = $1aa3d4c6cc6b2bab$var$_objectSpread($1aa3d4c6cc6b2bab$var$_objectSpread({}, properties), {}, {
            className: $1aa3d4c6cc6b2bab$export$d0f1f443a3b7b5(properties.className)
        });
        else {
            var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
                selector.split(".").forEach(function(className) {
                    if (!classes.includes(className)) classes.push(className);
                });
                return classes;
            }, []); // For compatibility with older versions of react-syntax-highlighter
            var startingClassName = properties.className && properties.className.includes("token") ? [
                "token"
            ] : [];
            var className1 = properties.className && startingClassName.concat(properties.className.filter(function(className) {
                return !allStylesheetSelectors.includes(className);
            }));
            props = $1aa3d4c6cc6b2bab$var$_objectSpread($1aa3d4c6cc6b2bab$var$_objectSpread({}, properties), {}, {
                className: $1aa3d4c6cc6b2bab$export$d0f1f443a3b7b5(className1) || undefined,
                style: $1aa3d4c6cc6b2bab$export$28a8c6cb018dfadc(properties.className, Object.assign({}, properties.style, style), stylesheet)
            });
        }
        var children = childrenCreator(node.children);
        return /*#__PURE__*/ (0, (/*@__PURE__*/$parcel$interopDefault($5pYYS))).createElement(TagName, (0, (/*@__PURE__*/$parcel$interopDefault($lwnIT)))({
            key: key
        }, props), children);
    }
}

});
parcelRequire.register("lwnIT", function(module, exports) {
function $faaefd04adc65c7f$var$_extends() {
    module.exports = $faaefd04adc65c7f$var$_extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return $faaefd04adc65c7f$var$_extends.apply(this, arguments);
}
module.exports = $faaefd04adc65c7f$var$_extends, module.exports.__esModule = true, module.exports["default"] = module.exports;

});


parcelRequire.register("dkNkF", function(module, exports) {

$parcel$export(module.exports, "default", () => $9b536900cede0d5b$export$2e2bcd8739ae039);
var $9b536900cede0d5b$export$2e2bcd8739ae039 = function(astGenerator, language) {
    var langs = astGenerator.listLanguages();
    return langs.indexOf(language) !== -1;
};

});


parcelRequire.register("c79Es", function(module, exports) {

$parcel$export(module.exports, "default", () => $8d1da00f735f14fa$export$2e2bcd8739ae039);
var $8d1da00f735f14fa$export$2e2bcd8739ae039 = {
    'code[class*="language-"]': {
        "color": "black",
        "background": "none",
        "textShadow": "0 1px white",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
    },
    'pre[class*="language-"]': {
        "color": "black",
        "background": "#f5f2f0",
        "textShadow": "0 1px white",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
    },
    'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
    },
    'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
    },
    'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
    },
    'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
    },
    'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
    },
    'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
    },
    'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
    },
    'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
    },
    ':not(pre) > code[class*="language-"]': {
        "background": "#f5f2f0",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
    },
    "comment": {
        "color": "slategray"
    },
    "prolog": {
        "color": "slategray"
    },
    "doctype": {
        "color": "slategray"
    },
    "cdata": {
        "color": "slategray"
    },
    "punctuation": {
        "color": "#999"
    },
    "namespace": {
        "Opacity": ".7"
    },
    "property": {
        "color": "#905"
    },
    "tag": {
        "color": "#905"
    },
    "boolean": {
        "color": "#905"
    },
    "number": {
        "color": "#905"
    },
    "constant": {
        "color": "#905"
    },
    "symbol": {
        "color": "#905"
    },
    "deleted": {
        "color": "#905"
    },
    "selector": {
        "color": "#690"
    },
    "attr-name": {
        "color": "#690"
    },
    "string": {
        "color": "#690"
    },
    "char": {
        "color": "#690"
    },
    "builtin": {
        "color": "#690"
    },
    "inserted": {
        "color": "#690"
    },
    "operator": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
    },
    "entity": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)",
        "cursor": "help"
    },
    "url": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
    },
    ".language-css .token.string": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
    },
    ".style .token.string": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
    },
    "atrule": {
        "color": "#07a"
    },
    "attr-value": {
        "color": "#07a"
    },
    "keyword": {
        "color": "#07a"
    },
    "function": {
        "color": "#DD4A68"
    },
    "class-name": {
        "color": "#DD4A68"
    },
    "regex": {
        "color": "#e90"
    },
    "important": {
        "color": "#e90",
        "fontWeight": "bold"
    },
    "variable": {
        "color": "#e90"
    },
    "bold": {
        "fontWeight": "bold"
    },
    "italic": {
        "fontStyle": "italic"
    }
};

});

parcelRequire.register("8VjOw", function(module, exports) {
"use strict";

var $3VGFS = parcelRequire("3VGFS");
module.exports = $3VGFS;

$3VGFS.register((parcelRequire("fi71t")));

$3VGFS.register((parcelRequire("iujtG")));

$3VGFS.register((parcelRequire("hjZpN")));

$3VGFS.register((parcelRequire("fgO6L")));

$3VGFS.register((parcelRequire("exifC")));

$3VGFS.register((parcelRequire("ffwdt")));

$3VGFS.register((parcelRequire("bI0aE")));

$3VGFS.register((parcelRequire("3nqcw")));

$3VGFS.register((parcelRequire("iJBrn")));

$3VGFS.register((parcelRequire("wyHrg")));

$3VGFS.register((parcelRequire("3j0kU")));

$3VGFS.register((parcelRequire("do0hG")));

$3VGFS.register((parcelRequire("8DXgx")));

$3VGFS.register((parcelRequire("4eI86")));

$3VGFS.register((parcelRequire("k3iwd")));

$3VGFS.register((parcelRequire("dgJEm")));

$3VGFS.register((parcelRequire("79CB4")));

$3VGFS.register((parcelRequire("10dhr")));

$3VGFS.register((parcelRequire("3VPhx")));

$3VGFS.register((parcelRequire("3ETBO")));

$3VGFS.register((parcelRequire("em7s9")));

$3VGFS.register((parcelRequire("8sFpc")));

$3VGFS.register((parcelRequire("adjC6")));

$3VGFS.register((parcelRequire("8M8zk")));

$3VGFS.register((parcelRequire("4RP6Z")));

$3VGFS.register((parcelRequire("killR")));

$3VGFS.register((parcelRequire("1rJbI")));

$3VGFS.register((parcelRequire("58ao8")));

$3VGFS.register((parcelRequire("2ZmdF")));

$3VGFS.register((parcelRequire("8jiFM")));

$3VGFS.register((parcelRequire("4wFtN")));

$3VGFS.register((parcelRequire("9cYPk")));

$3VGFS.register((parcelRequire("3ttFf")));

$3VGFS.register((parcelRequire("4eYlO")));

$3VGFS.register((parcelRequire("bEqqd")));

$3VGFS.register((parcelRequire("8R9GL")));

$3VGFS.register((parcelRequire("53QAh")));

$3VGFS.register((parcelRequire("9WThB")));

$3VGFS.register((parcelRequire("eznHT")));

$3VGFS.register((parcelRequire("bNqmj")));

$3VGFS.register((parcelRequire("ks1mO")));

$3VGFS.register((parcelRequire("1ZTxl")));

$3VGFS.register((parcelRequire("ljEvW")));

$3VGFS.register((parcelRequire("am5Uf")));

$3VGFS.register((parcelRequire("eLG4G")));

$3VGFS.register((parcelRequire("ccC8d")));

$3VGFS.register((parcelRequire("jcO3t")));

$3VGFS.register((parcelRequire("lRSwv")));

$3VGFS.register((parcelRequire("9fBX5")));

$3VGFS.register((parcelRequire("lcjlB")));

$3VGFS.register((parcelRequire("j3wdq")));

$3VGFS.register((parcelRequire("bF7f6")));

$3VGFS.register((parcelRequire("do4FZ")));

$3VGFS.register((parcelRequire("fyYUS")));

$3VGFS.register((parcelRequire("lLIBf")));

$3VGFS.register((parcelRequire("5Al2z")));

$3VGFS.register((parcelRequire("68APj")));

$3VGFS.register((parcelRequire("8TwTj")));

$3VGFS.register((parcelRequire("hEhTx")));

$3VGFS.register((parcelRequire("6XDX9")));

$3VGFS.register((parcelRequire("9ue9I")));

$3VGFS.register((parcelRequire("eFvuO")));

$3VGFS.register((parcelRequire("lXmhB")));

$3VGFS.register((parcelRequire("6jL0P")));

$3VGFS.register((parcelRequire("l43Wf")));

$3VGFS.register((parcelRequire("5P2FD")));

$3VGFS.register((parcelRequire("aFA8R")));

$3VGFS.register((parcelRequire("2Tmt4")));

$3VGFS.register((parcelRequire("4nhIU")));

$3VGFS.register((parcelRequire("4nIBi")));

$3VGFS.register((parcelRequire("eiDOE")));

$3VGFS.register((parcelRequire("fwAI7")));

$3VGFS.register((parcelRequire("i5zwz")));

$3VGFS.register((parcelRequire("blHrv")));

$3VGFS.register((parcelRequire("kyvzx")));

$3VGFS.register((parcelRequire("aUrcT")));

$3VGFS.register((parcelRequire("iqi0o")));

$3VGFS.register((parcelRequire("d8oi6")));

$3VGFS.register((parcelRequire("2AzYV")));

$3VGFS.register((parcelRequire("cak77")));

$3VGFS.register((parcelRequire("kDavc")));

$3VGFS.register((parcelRequire("kZazw")));

$3VGFS.register((parcelRequire("e6KPe")));

$3VGFS.register((parcelRequire("juR1k")));

$3VGFS.register((parcelRequire("PDZAl")));

$3VGFS.register((parcelRequire("e0r83")));

$3VGFS.register((parcelRequire("97zzY")));

$3VGFS.register((parcelRequire("4wGAC")));

$3VGFS.register((parcelRequire("hriul")));

$3VGFS.register((parcelRequire("47CJF")));

$3VGFS.register((parcelRequire("aIJdK")));

$3VGFS.register((parcelRequire("g2hj8")));

$3VGFS.register((parcelRequire("erJ4y")));

$3VGFS.register((parcelRequire("4Xokg")));

$3VGFS.register((parcelRequire("2X73H")));

$3VGFS.register((parcelRequire("88lVj")));

$3VGFS.register((parcelRequire("4djgk")));

$3VGFS.register((parcelRequire("crcxS")));

$3VGFS.register((parcelRequire("8HAPU")));

$3VGFS.register((parcelRequire("5LEXG")));

$3VGFS.register((parcelRequire("eK8Jr")));

$3VGFS.register((parcelRequire("8tt6J")));

$3VGFS.register((parcelRequire("aBVFT")));

$3VGFS.register((parcelRequire("b87lY")));

$3VGFS.register((parcelRequire("fIpze")));

$3VGFS.register((parcelRequire("dhBfq")));

$3VGFS.register((parcelRequire("ignak")));

$3VGFS.register((parcelRequire("etUwY")));

$3VGFS.register((parcelRequire("aiic4")));

$3VGFS.register((parcelRequire("5z5AY")));

$3VGFS.register((parcelRequire("iiNcT")));

$3VGFS.register((parcelRequire("b80S6")));

$3VGFS.register((parcelRequire("4co4r")));

$3VGFS.register((parcelRequire("jvX8S")));

$3VGFS.register((parcelRequire("krlJ1")));

$3VGFS.register((parcelRequire("1vwxQ")));

$3VGFS.register((parcelRequire("i2ayO")));

$3VGFS.register((parcelRequire("ewimh")));

$3VGFS.register((parcelRequire("awkUj")));

$3VGFS.register((parcelRequire("5PXvh")));

$3VGFS.register((parcelRequire("2l5ju")));

$3VGFS.register((parcelRequire("9fh53")));

$3VGFS.register((parcelRequire("foj5y")));

$3VGFS.register((parcelRequire("eOFsZ")));

$3VGFS.register((parcelRequire("50bhI")));

$3VGFS.register((parcelRequire("7uLIf")));

$3VGFS.register((parcelRequire("059OA")));

$3VGFS.register((parcelRequire("iYfv3")));

$3VGFS.register((parcelRequire("egaM8")));

$3VGFS.register((parcelRequire("fi74q")));

$3VGFS.register((parcelRequire("7a9de")));

$3VGFS.register((parcelRequire("eeAnV")));

$3VGFS.register((parcelRequire("eOXdT")));

$3VGFS.register((parcelRequire("arXqb")));

$3VGFS.register((parcelRequire("lVwRg")));

$3VGFS.register((parcelRequire("dh8tA")));

$3VGFS.register((parcelRequire("6TZG2")));

$3VGFS.register((parcelRequire("0v4qf")));

$3VGFS.register((parcelRequire("dl2ma")));

$3VGFS.register((parcelRequire("kpHun")));

$3VGFS.register((parcelRequire("7PhLK")));

$3VGFS.register((parcelRequire("9lsgl")));

$3VGFS.register((parcelRequire("kkEiL")));

$3VGFS.register((parcelRequire("1rmoN")));

$3VGFS.register((parcelRequire("gf0AF")));

$3VGFS.register((parcelRequire("e9LrW")));

$3VGFS.register((parcelRequire("5k2L6")));

$3VGFS.register((parcelRequire("cekeD")));

$3VGFS.register((parcelRequire("lSxtO")));

$3VGFS.register((parcelRequire("iMMJF")));

$3VGFS.register((parcelRequire("hyGu8")));

$3VGFS.register((parcelRequire("lRMCr")));

$3VGFS.register((parcelRequire("b6Pkx")));

$3VGFS.register((parcelRequire("593Eo")));

$3VGFS.register((parcelRequire("2cqwT")));

$3VGFS.register((parcelRequire("jM2KR")));

$3VGFS.register((parcelRequire("22sMC")));

$3VGFS.register((parcelRequire("8kz8s")));

$3VGFS.register((parcelRequire("36CmC")));

$3VGFS.register((parcelRequire("kJBmc")));

$3VGFS.register((parcelRequire("YDp9F")));

$3VGFS.register((parcelRequire("bS79M")));

$3VGFS.register((parcelRequire("9vpPI")));

$3VGFS.register((parcelRequire("6SbCL")));

$3VGFS.register((parcelRequire("1eIXh")));

$3VGFS.register((parcelRequire("f0nKm")));

$3VGFS.register((parcelRequire("lN64z")));

$3VGFS.register((parcelRequire("k8Tvy")));

$3VGFS.register((parcelRequire("asjxC")));

$3VGFS.register((parcelRequire("iyxZt")));

$3VGFS.register((parcelRequire("g2ebv")));

$3VGFS.register((parcelRequire("eaPDu")));

$3VGFS.register((parcelRequire("tsZWK")));

$3VGFS.register((parcelRequire("9qa8H")));

$3VGFS.register((parcelRequire("dt7cG")));

$3VGFS.register((parcelRequire("23vWE")));

$3VGFS.register((parcelRequire("fNIXI")));

$3VGFS.register((parcelRequire("fdICy")));

$3VGFS.register((parcelRequire("jJhZG")));

$3VGFS.register((parcelRequire("dRcHg")));

$3VGFS.register((parcelRequire("dgm8B")));

$3VGFS.register((parcelRequire("2houC")));

$3VGFS.register((parcelRequire("6yqDR")));

$3VGFS.register((parcelRequire("i3e0j")));

$3VGFS.register((parcelRequire("gd1jl")));

$3VGFS.register((parcelRequire("15Hsz")));

$3VGFS.register((parcelRequire("itl0F")));

$3VGFS.register((parcelRequire("1L4gm")));

$3VGFS.register((parcelRequire("kdUpF")));

$3VGFS.register((parcelRequire("60NY8")));

$3VGFS.register((parcelRequire("eqStk")));

$3VGFS.register((parcelRequire("eqlwD")));

$3VGFS.register((parcelRequire("2wbKO")));

$3VGFS.register((parcelRequire("4mMja")));

$3VGFS.register((parcelRequire("dZvrI")));

$3VGFS.register((parcelRequire("gjCLb")));

$3VGFS.register((parcelRequire("gXzeq")));

$3VGFS.register((parcelRequire("7tonk")));

$3VGFS.register((parcelRequire("gEhMo")));

$3VGFS.register((parcelRequire("jNUof")));

$3VGFS.register((parcelRequire("01CQo")));

$3VGFS.register((parcelRequire("6FtrL")));

$3VGFS.register((parcelRequire("35zeA")));

$3VGFS.register((parcelRequire("28LIl")));

$3VGFS.register((parcelRequire("5FbEK")));

$3VGFS.register((parcelRequire("gCBjT")));

$3VGFS.register((parcelRequire("dmaYA")));

$3VGFS.register((parcelRequire("hIJZK")));

$3VGFS.register((parcelRequire("c6Moq")));

$3VGFS.register((parcelRequire("3G0XG")));

$3VGFS.register((parcelRequire("2x7Z1")));

$3VGFS.register((parcelRequire("46l9U")));

$3VGFS.register((parcelRequire("8DI2y")));

$3VGFS.register((parcelRequire("2H4A6")));

$3VGFS.register((parcelRequire("9kpWi")));

$3VGFS.register((parcelRequire("lbKMZ")));

$3VGFS.register((parcelRequire("7AD6t")));

$3VGFS.register((parcelRequire("bsvoe")));

$3VGFS.register((parcelRequire("haSCJ")));

$3VGFS.register((parcelRequire("dx9Q9")));

$3VGFS.register((parcelRequire("87mWg")));

$3VGFS.register((parcelRequire("jaOa5")));

$3VGFS.register((parcelRequire("3NOQn")));

$3VGFS.register((parcelRequire("k7UGg")));

$3VGFS.register((parcelRequire("lTlZu")));

$3VGFS.register((parcelRequire("mjKIY")));

$3VGFS.register((parcelRequire("fpQ6N")));

$3VGFS.register((parcelRequire("78veX")));

$3VGFS.register((parcelRequire("4sJYz")));

$3VGFS.register((parcelRequire("aeREZ")));

$3VGFS.register((parcelRequire("gPT25")));

$3VGFS.register((parcelRequire("9XxMv")));

$3VGFS.register((parcelRequire("6dZVI")));

$3VGFS.register((parcelRequire("cQCVq")));

$3VGFS.register((parcelRequire("4GsZj")));

$3VGFS.register((parcelRequire("cXo0G")));

$3VGFS.register((parcelRequire("bNRXQ")));

$3VGFS.register((parcelRequire("2E3aL")));

$3VGFS.register((parcelRequire("7QNW1")));

$3VGFS.register((parcelRequire("mCGa7")));

$3VGFS.register((parcelRequire("4Hhqh")));

$3VGFS.register((parcelRequire("2uxje")));

$3VGFS.register((parcelRequire("39Nm4")));

$3VGFS.register((parcelRequire("kuFmD")));

$3VGFS.register((parcelRequire("i6g85")));

$3VGFS.register((parcelRequire("aFTf2")));

$3VGFS.register((parcelRequire("hWAZy")));

$3VGFS.register((parcelRequire("aQinA")));

$3VGFS.register((parcelRequire("3Oh9p")));

$3VGFS.register((parcelRequire("8GCY6")));

$3VGFS.register((parcelRequire("5EjtJ")));

$3VGFS.register((parcelRequire("e7Gip")));

$3VGFS.register((parcelRequire("1T7YT")));

$3VGFS.register((parcelRequire("aXVod")));

$3VGFS.register((parcelRequire("60WOi")));

$3VGFS.register((parcelRequire("3nS95")));

$3VGFS.register((parcelRequire("9Itlp")));

$3VGFS.register((parcelRequire("ehHiz")));

$3VGFS.register((parcelRequire("g1P8Z")));

$3VGFS.register((parcelRequire("vtJFz")));

$3VGFS.register((parcelRequire("jzDEV")));

$3VGFS.register((parcelRequire("hiR4N")));

$3VGFS.register((parcelRequire("dhnWt")));

$3VGFS.register((parcelRequire("khnHL")));

$3VGFS.register((parcelRequire("elW05")));

$3VGFS.register((parcelRequire("eAvOt")));

$3VGFS.register((parcelRequire("dZzMb")));

$3VGFS.register((parcelRequire("lmtug")));

$3VGFS.register((parcelRequire("h2JX7")));

$3VGFS.register((parcelRequire("hoLge")));

$3VGFS.register((parcelRequire("fPZa6")));

$3VGFS.register((parcelRequire("ke4lE")));

$3VGFS.register((parcelRequire("dmftH")));

});
parcelRequire.register("3VGFS", function(module, exports) {
"use strict";
/* global window, self */ // istanbul ignore next - Don't allow Prism to run on page load in browser or
// to start messaging from workers.
var $2dc7cc3b723ac168$var$ctx = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof $parcel$global === "object" ? $parcel$global : {};
var $2dc7cc3b723ac168$var$restore = $2dc7cc3b723ac168$var$capture();
$2dc7cc3b723ac168$var$ctx.Prism = {
    manual: true,
    disableWorkerMessageHandler: true
};

var $djJtF = parcelRequire("djJtF");

var $aqMEU = parcelRequire("aqMEU");

var $jQbe3 = parcelRequire("jQbe3");

var $kXqLl = parcelRequire("kXqLl");

var $lXGdk = parcelRequire("lXGdk");

var $5SC8r = parcelRequire("5SC8r");

var $kPxhR = parcelRequire("kPxhR");
$2dc7cc3b723ac168$var$restore();
var $2dc7cc3b723ac168$var$own = {}.hasOwnProperty;
// Inherit.
function $2dc7cc3b723ac168$var$Refractor() {}
$2dc7cc3b723ac168$var$Refractor.prototype = $jQbe3;
// Construct.
var $2dc7cc3b723ac168$var$refract = new $2dc7cc3b723ac168$var$Refractor();
// Expose.
module.exports = $2dc7cc3b723ac168$var$refract;
// Create.
$2dc7cc3b723ac168$var$refract.highlight = $2dc7cc3b723ac168$var$highlight;
$2dc7cc3b723ac168$var$refract.register = $2dc7cc3b723ac168$var$register;
$2dc7cc3b723ac168$var$refract.alias = $2dc7cc3b723ac168$var$alias;
$2dc7cc3b723ac168$var$refract.registered = $2dc7cc3b723ac168$var$registered;
$2dc7cc3b723ac168$var$refract.listLanguages = $2dc7cc3b723ac168$var$listLanguages;
// Register bundled grammars.
$2dc7cc3b723ac168$var$register($kXqLl);
$2dc7cc3b723ac168$var$register($lXGdk);
$2dc7cc3b723ac168$var$register($5SC8r);
$2dc7cc3b723ac168$var$register($kPxhR);
$2dc7cc3b723ac168$var$refract.util.encode = $2dc7cc3b723ac168$var$encode;
$2dc7cc3b723ac168$var$refract.Token.stringify = $2dc7cc3b723ac168$var$stringify;
function $2dc7cc3b723ac168$var$register(grammar) {
    if (typeof grammar !== "function" || !grammar.displayName) throw new Error("Expected `function` for `grammar`, got `" + grammar + "`");
    // Do not duplicate registrations.
    if ($2dc7cc3b723ac168$var$refract.languages[grammar.displayName] === undefined) grammar($2dc7cc3b723ac168$var$refract);
}
function $2dc7cc3b723ac168$var$alias(name, alias1) {
    var languages = $2dc7cc3b723ac168$var$refract.languages;
    var map = name;
    var key;
    var list;
    var length;
    var index;
    if (alias1) {
        map = {};
        map[name] = alias1;
    }
    for(key in map){
        list = map[key];
        list = typeof list === "string" ? [
            list
        ] : list;
        length = list.length;
        index = -1;
        while(++index < length)languages[list[index]] = languages[key];
    }
}
function $2dc7cc3b723ac168$var$highlight(value, name) {
    var sup = $jQbe3.highlight;
    var grammar;
    if (typeof value !== "string") throw new Error("Expected `string` for `value`, got `" + value + "`");
    // `name` is a grammar object.
    if ($2dc7cc3b723ac168$var$refract.util.type(name) === "Object") {
        grammar = name;
        name = null;
    } else {
        if (typeof name !== "string") throw new Error("Expected `string` for `name`, got `" + name + "`");
        if ($2dc7cc3b723ac168$var$own.call($2dc7cc3b723ac168$var$refract.languages, name)) grammar = $2dc7cc3b723ac168$var$refract.languages[name];
        else throw new Error("Unknown language: `" + name + "` is not registered");
    }
    return sup.call(this, value, grammar, name);
}
function $2dc7cc3b723ac168$var$registered(language) {
    if (typeof language !== "string") throw new Error("Expected `string` for `language`, got `" + language + "`");
    return $2dc7cc3b723ac168$var$own.call($2dc7cc3b723ac168$var$refract.languages, language);
}
function $2dc7cc3b723ac168$var$listLanguages() {
    var languages = $2dc7cc3b723ac168$var$refract.languages;
    var list = [];
    var language;
    for(language in languages)if ($2dc7cc3b723ac168$var$own.call(languages, language) && typeof languages[language] === "object") list.push(language);
    return list;
}
function $2dc7cc3b723ac168$var$stringify(value, language, parent) {
    var env;
    if (typeof value === "string") return {
        type: "text",
        value: value
    };
    if ($2dc7cc3b723ac168$var$refract.util.type(value) === "Array") return $2dc7cc3b723ac168$var$stringifyAll(value, language);
    env = {
        type: value.type,
        content: $2dc7cc3b723ac168$var$refract.Token.stringify(value.content, language, parent),
        tag: "span",
        classes: [
            "token",
            value.type
        ],
        attributes: {},
        language: language,
        parent: parent
    };
    if (value.alias) env.classes = env.classes.concat(value.alias);
    $2dc7cc3b723ac168$var$refract.hooks.run("wrap", env);
    return $djJtF(env.tag + "." + env.classes.join("."), $2dc7cc3b723ac168$var$attributes(env.attributes), env.content);
}
function $2dc7cc3b723ac168$var$stringifyAll(values, language) {
    var result = [];
    var length = values.length;
    var index = -1;
    var value;
    while(++index < length){
        value = values[index];
        if (value !== "" && value !== null && value !== undefined) result.push(value);
    }
    index = -1;
    length = result.length;
    while(++index < length){
        value = result[index];
        result[index] = $2dc7cc3b723ac168$var$refract.Token.stringify(value, language, result);
    }
    return result;
}
function $2dc7cc3b723ac168$var$encode(tokens) {
    return tokens;
}
function $2dc7cc3b723ac168$var$attributes(attrs) {
    var key;
    for(key in attrs)attrs[key] = $aqMEU(attrs[key]);
    return attrs;
}
function $2dc7cc3b723ac168$var$capture() {
    var defined = "Prism" in $2dc7cc3b723ac168$var$ctx;
    /* istanbul ignore next */ var current = defined ? $2dc7cc3b723ac168$var$ctx.Prism : undefined;
    return restore1;
    function restore1() {
        /* istanbul ignore else - Clean leaks after Prism. */ if (defined) {
            $2dc7cc3b723ac168$var$ctx.Prism = current;
        } else {
            delete $2dc7cc3b723ac168$var$ctx.Prism;
        }
        defined = undefined;
        current = undefined;
    }
}

});
parcelRequire.register("djJtF", function(module, exports) {
"use strict";

module.exports = (parcelRequire("jrBDr"));

});
parcelRequire.register("jrBDr", function(module, exports) {
"use strict";

var $2WCBW = parcelRequire("2WCBW");

var $fLbnY = parcelRequire("fLbnY");
var $e27dbb7a00e0acdf$var$html = $fLbnY($2WCBW, "div");
$e27dbb7a00e0acdf$var$html.displayName = "html";
module.exports = $e27dbb7a00e0acdf$var$html;

});
parcelRequire.register("2WCBW", function(module, exports) {
"use strict";

var $2lO5a = parcelRequire("2lO5a");

var $cYn3K = parcelRequire("cYn3K");

var $HcqPI = parcelRequire("HcqPI");

var $3lPK3 = parcelRequire("3lPK3");

var $8lI3h = parcelRequire("8lI3h");

var $8CHk4 = parcelRequire("8CHk4");
module.exports = $2lO5a([
    $HcqPI,
    $cYn3K,
    $3lPK3,
    $8lI3h,
    $8CHk4
]);

});
parcelRequire.register("2lO5a", function(module, exports) {
"use strict";

var $7O5XV = parcelRequire("7O5XV");

var $5PtOV = parcelRequire("5PtOV");
module.exports = $1b6464420cc0986c$var$merge;
function $1b6464420cc0986c$var$merge(definitions) {
    var length = definitions.length;
    var property = [];
    var normal = [];
    var index = -1;
    var info;
    var space;
    while(++index < length){
        info = definitions[index];
        property.push(info.property);
        normal.push(info.normal);
        space = info.space;
    }
    return new $5PtOV($7O5XV.apply(null, property), $7O5XV.apply(null, normal), space);
}

});
parcelRequire.register("7O5XV", function(module, exports) {
module.exports = $5af1d48b219bb277$var$extend;
var $5af1d48b219bb277$var$hasOwnProperty = Object.prototype.hasOwnProperty;
function $5af1d48b219bb277$var$extend() {
    var target = {};
    for(var i = 0; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source)if ($5af1d48b219bb277$var$hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
}

});

parcelRequire.register("5PtOV", function(module, exports) {
"use strict";
module.exports = $43e8d8e20e4b25b9$var$Schema;
var $43e8d8e20e4b25b9$var$proto = $43e8d8e20e4b25b9$var$Schema.prototype;
$43e8d8e20e4b25b9$var$proto.space = null;
$43e8d8e20e4b25b9$var$proto.normal = {};
$43e8d8e20e4b25b9$var$proto.property = {};
function $43e8d8e20e4b25b9$var$Schema(property, normal, space) {
    this.property = property;
    this.normal = normal;
    if (space) this.space = space;
}

});


parcelRequire.register("cYn3K", function(module, exports) {
"use strict";

var $9SSZl = parcelRequire("9SSZl");
module.exports = $9SSZl({
    space: "xlink",
    transform: $971cf9c3f79e54dc$var$xlinkTransform,
    properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
    }
});
function $971cf9c3f79e54dc$var$xlinkTransform(_, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
}

});
parcelRequire.register("9SSZl", function(module, exports) {
"use strict";

var $5b21o = parcelRequire("5b21o");

var $5PtOV = parcelRequire("5PtOV");

var $fwdsj = parcelRequire("fwdsj");
module.exports = $7323cfc5234f9bcc$var$create;
function $7323cfc5234f9bcc$var$create(definition) {
    var space = definition.space;
    var mustUseProperty = definition.mustUseProperty || [];
    var attributes = definition.attributes || {};
    var props = definition.properties;
    var transform = definition.transform;
    var property = {};
    var normal = {};
    var prop;
    var info;
    for(prop in props){
        info = new $fwdsj(prop, transform(attributes, prop), props[prop], space);
        if (mustUseProperty.indexOf(prop) !== -1) info.mustUseProperty = true;
        property[prop] = info;
        normal[$5b21o(prop)] = prop;
        normal[$5b21o(info.attribute)] = prop;
    }
    return new $5PtOV(property, normal, space);
}

});
parcelRequire.register("5b21o", function(module, exports) {
"use strict";
module.exports = $3c4f8c45a8cc52c8$var$normalize;
function $3c4f8c45a8cc52c8$var$normalize(value) {
    return value.toLowerCase();
}

});

parcelRequire.register("fwdsj", function(module, exports) {
"use strict";

var $3DqAZ = parcelRequire("3DqAZ");

var $9IG3n = parcelRequire("9IG3n");
module.exports = $b4c4482f13f49d25$var$DefinedInfo;
$b4c4482f13f49d25$var$DefinedInfo.prototype = new $3DqAZ();
$b4c4482f13f49d25$var$DefinedInfo.prototype.defined = true;
var $b4c4482f13f49d25$var$checks = [
    "boolean",
    "booleanish",
    "overloadedBoolean",
    "number",
    "commaSeparated",
    "spaceSeparated",
    "commaOrSpaceSeparated"
];
var $b4c4482f13f49d25$var$checksLength = $b4c4482f13f49d25$var$checks.length;
function $b4c4482f13f49d25$var$DefinedInfo(property, attribute, mask, space) {
    var index = -1;
    var check;
    $b4c4482f13f49d25$var$mark(this, "space", space);
    $3DqAZ.call(this, property, attribute);
    while(++index < $b4c4482f13f49d25$var$checksLength){
        check = $b4c4482f13f49d25$var$checks[index];
        $b4c4482f13f49d25$var$mark(this, check, (mask & $9IG3n[check]) === $9IG3n[check]);
    }
}
function $b4c4482f13f49d25$var$mark(values, key, value) {
    if (value) values[key] = value;
}

});
parcelRequire.register("3DqAZ", function(module, exports) {
"use strict";
module.exports = $2a59a4f3c4d9ed91$var$Info;
var $2a59a4f3c4d9ed91$var$proto = $2a59a4f3c4d9ed91$var$Info.prototype;
$2a59a4f3c4d9ed91$var$proto.space = null;
$2a59a4f3c4d9ed91$var$proto.attribute = null;
$2a59a4f3c4d9ed91$var$proto.property = null;
$2a59a4f3c4d9ed91$var$proto.boolean = false;
$2a59a4f3c4d9ed91$var$proto.booleanish = false;
$2a59a4f3c4d9ed91$var$proto.overloadedBoolean = false;
$2a59a4f3c4d9ed91$var$proto.number = false;
$2a59a4f3c4d9ed91$var$proto.commaSeparated = false;
$2a59a4f3c4d9ed91$var$proto.spaceSeparated = false;
$2a59a4f3c4d9ed91$var$proto.commaOrSpaceSeparated = false;
$2a59a4f3c4d9ed91$var$proto.mustUseProperty = false;
$2a59a4f3c4d9ed91$var$proto.defined = false;
function $2a59a4f3c4d9ed91$var$Info(property, attribute) {
    this.property = property;
    this.attribute = attribute;
}

});

parcelRequire.register("9IG3n", function(module, exports) {

$parcel$export(module.exports, "boolean", () => $7138d80dc9648a8e$export$4a21f16c33752377, (v) => $7138d80dc9648a8e$export$4a21f16c33752377 = v);
$parcel$export(module.exports, "booleanish", () => $7138d80dc9648a8e$export$55e9e1fbc638dc8f, (v) => $7138d80dc9648a8e$export$55e9e1fbc638dc8f = v);
$parcel$export(module.exports, "overloadedBoolean", () => $7138d80dc9648a8e$export$242ac3d3042558aa, (v) => $7138d80dc9648a8e$export$242ac3d3042558aa = v);
$parcel$export(module.exports, "number", () => $7138d80dc9648a8e$export$98e628dec113755e, (v) => $7138d80dc9648a8e$export$98e628dec113755e = v);
$parcel$export(module.exports, "spaceSeparated", () => $7138d80dc9648a8e$export$ab8645c862eb5a3e, (v) => $7138d80dc9648a8e$export$ab8645c862eb5a3e = v);
$parcel$export(module.exports, "commaSeparated", () => $7138d80dc9648a8e$export$9c8d678629b3d3, (v) => $7138d80dc9648a8e$export$9c8d678629b3d3 = v);
$parcel$export(module.exports, "commaOrSpaceSeparated", () => $7138d80dc9648a8e$export$2ad25cfebf36cacd, (v) => $7138d80dc9648a8e$export$2ad25cfebf36cacd = v);
var $7138d80dc9648a8e$export$4a21f16c33752377;
var $7138d80dc9648a8e$export$55e9e1fbc638dc8f;
var $7138d80dc9648a8e$export$242ac3d3042558aa;
var $7138d80dc9648a8e$export$98e628dec113755e;
var $7138d80dc9648a8e$export$ab8645c862eb5a3e;
var $7138d80dc9648a8e$export$9c8d678629b3d3;
var $7138d80dc9648a8e$export$2ad25cfebf36cacd;
"use strict";
var $7138d80dc9648a8e$var$powers = 0;
$7138d80dc9648a8e$export$4a21f16c33752377 = $7138d80dc9648a8e$var$increment();
$7138d80dc9648a8e$export$55e9e1fbc638dc8f = $7138d80dc9648a8e$var$increment();
$7138d80dc9648a8e$export$242ac3d3042558aa = $7138d80dc9648a8e$var$increment();
$7138d80dc9648a8e$export$98e628dec113755e = $7138d80dc9648a8e$var$increment();
$7138d80dc9648a8e$export$ab8645c862eb5a3e = $7138d80dc9648a8e$var$increment();
$7138d80dc9648a8e$export$9c8d678629b3d3 = $7138d80dc9648a8e$var$increment();
$7138d80dc9648a8e$export$2ad25cfebf36cacd = $7138d80dc9648a8e$var$increment();
function $7138d80dc9648a8e$var$increment() {
    return Math.pow(2, ++$7138d80dc9648a8e$var$powers);
}

});




parcelRequire.register("HcqPI", function(module, exports) {
"use strict";

var $9SSZl = parcelRequire("9SSZl");
module.exports = $9SSZl({
    space: "xml",
    transform: $081da8f633270ad0$var$xmlTransform,
    properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
    }
});
function $081da8f633270ad0$var$xmlTransform(_, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
}

});

parcelRequire.register("3lPK3", function(module, exports) {
"use strict";

var $9SSZl = parcelRequire("9SSZl");

var $6G9Gi = parcelRequire("6G9Gi");
module.exports = $9SSZl({
    space: "xmlns",
    attributes: {
        xmlnsxlink: "xmlns:xlink"
    },
    transform: $6G9Gi,
    properties: {
        xmlns: null,
        xmlnsXLink: null
    }
});

});
parcelRequire.register("6G9Gi", function(module, exports) {
"use strict";

var $ictej = parcelRequire("ictej");
module.exports = $014142c98e9846d7$var$caseInsensitiveTransform;
function $014142c98e9846d7$var$caseInsensitiveTransform(attributes, property) {
    return $ictej(attributes, property.toLowerCase());
}

});
parcelRequire.register("ictej", function(module, exports) {
"use strict";
module.exports = $d4000569f54dcb71$var$caseSensitiveTransform;
function $d4000569f54dcb71$var$caseSensitiveTransform(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
}

});



parcelRequire.register("8lI3h", function(module, exports) {
"use strict";

var $9IG3n = parcelRequire("9IG3n");

var $9SSZl = parcelRequire("9SSZl");
var $614274b0d06f5010$var$booleanish = $9IG3n.booleanish;
var $614274b0d06f5010$var$number = $9IG3n.number;
var $614274b0d06f5010$var$spaceSeparated = $9IG3n.spaceSeparated;
module.exports = $9SSZl({
    transform: $614274b0d06f5010$var$ariaTransform,
    properties: {
        ariaActiveDescendant: null,
        ariaAtomic: $614274b0d06f5010$var$booleanish,
        ariaAutoComplete: null,
        ariaBusy: $614274b0d06f5010$var$booleanish,
        ariaChecked: $614274b0d06f5010$var$booleanish,
        ariaColCount: $614274b0d06f5010$var$number,
        ariaColIndex: $614274b0d06f5010$var$number,
        ariaColSpan: $614274b0d06f5010$var$number,
        ariaControls: $614274b0d06f5010$var$spaceSeparated,
        ariaCurrent: null,
        ariaDescribedBy: $614274b0d06f5010$var$spaceSeparated,
        ariaDetails: null,
        ariaDisabled: $614274b0d06f5010$var$booleanish,
        ariaDropEffect: $614274b0d06f5010$var$spaceSeparated,
        ariaErrorMessage: null,
        ariaExpanded: $614274b0d06f5010$var$booleanish,
        ariaFlowTo: $614274b0d06f5010$var$spaceSeparated,
        ariaGrabbed: $614274b0d06f5010$var$booleanish,
        ariaHasPopup: null,
        ariaHidden: $614274b0d06f5010$var$booleanish,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: $614274b0d06f5010$var$spaceSeparated,
        ariaLevel: $614274b0d06f5010$var$number,
        ariaLive: null,
        ariaModal: $614274b0d06f5010$var$booleanish,
        ariaMultiLine: $614274b0d06f5010$var$booleanish,
        ariaMultiSelectable: $614274b0d06f5010$var$booleanish,
        ariaOrientation: null,
        ariaOwns: $614274b0d06f5010$var$spaceSeparated,
        ariaPlaceholder: null,
        ariaPosInSet: $614274b0d06f5010$var$number,
        ariaPressed: $614274b0d06f5010$var$booleanish,
        ariaReadOnly: $614274b0d06f5010$var$booleanish,
        ariaRelevant: null,
        ariaRequired: $614274b0d06f5010$var$booleanish,
        ariaRoleDescription: $614274b0d06f5010$var$spaceSeparated,
        ariaRowCount: $614274b0d06f5010$var$number,
        ariaRowIndex: $614274b0d06f5010$var$number,
        ariaRowSpan: $614274b0d06f5010$var$number,
        ariaSelected: $614274b0d06f5010$var$booleanish,
        ariaSetSize: $614274b0d06f5010$var$number,
        ariaSort: null,
        ariaValueMax: $614274b0d06f5010$var$number,
        ariaValueMin: $614274b0d06f5010$var$number,
        ariaValueNow: $614274b0d06f5010$var$number,
        ariaValueText: null,
        role: null
    }
});
function $614274b0d06f5010$var$ariaTransform(_, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
}

});

parcelRequire.register("8CHk4", function(module, exports) {
"use strict";

var $9IG3n = parcelRequire("9IG3n");

var $9SSZl = parcelRequire("9SSZl");

var $6G9Gi = parcelRequire("6G9Gi");
var $64737a4e2e94905f$var$boolean = $9IG3n.boolean;
var $64737a4e2e94905f$var$overloadedBoolean = $9IG3n.overloadedBoolean;
var $64737a4e2e94905f$var$booleanish = $9IG3n.booleanish;
var $64737a4e2e94905f$var$number = $9IG3n.number;
var $64737a4e2e94905f$var$spaceSeparated = $9IG3n.spaceSeparated;
var $64737a4e2e94905f$var$commaSeparated = $9IG3n.commaSeparated;
module.exports = $9SSZl({
    space: "html",
    attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
    },
    transform: $6G9Gi,
    mustUseProperty: [
        "checked",
        "multiple",
        "muted",
        "selected"
    ],
    properties: {
        // Standard Properties.
        abbr: null,
        accept: $64737a4e2e94905f$var$commaSeparated,
        acceptCharset: $64737a4e2e94905f$var$spaceSeparated,
        accessKey: $64737a4e2e94905f$var$spaceSeparated,
        action: null,
        allow: null,
        allowFullScreen: $64737a4e2e94905f$var$boolean,
        allowPaymentRequest: $64737a4e2e94905f$var$boolean,
        allowUserMedia: $64737a4e2e94905f$var$boolean,
        alt: null,
        as: null,
        async: $64737a4e2e94905f$var$boolean,
        autoCapitalize: null,
        autoComplete: $64737a4e2e94905f$var$spaceSeparated,
        autoFocus: $64737a4e2e94905f$var$boolean,
        autoPlay: $64737a4e2e94905f$var$boolean,
        capture: $64737a4e2e94905f$var$boolean,
        charSet: null,
        checked: $64737a4e2e94905f$var$boolean,
        cite: null,
        className: $64737a4e2e94905f$var$spaceSeparated,
        cols: $64737a4e2e94905f$var$number,
        colSpan: null,
        content: null,
        contentEditable: $64737a4e2e94905f$var$booleanish,
        controls: $64737a4e2e94905f$var$boolean,
        controlsList: $64737a4e2e94905f$var$spaceSeparated,
        coords: $64737a4e2e94905f$var$number | $64737a4e2e94905f$var$commaSeparated,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: $64737a4e2e94905f$var$boolean,
        defer: $64737a4e2e94905f$var$boolean,
        dir: null,
        dirName: null,
        disabled: $64737a4e2e94905f$var$boolean,
        download: $64737a4e2e94905f$var$overloadedBoolean,
        draggable: $64737a4e2e94905f$var$booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: $64737a4e2e94905f$var$boolean,
        formTarget: null,
        headers: $64737a4e2e94905f$var$spaceSeparated,
        height: $64737a4e2e94905f$var$number,
        hidden: $64737a4e2e94905f$var$boolean,
        high: $64737a4e2e94905f$var$number,
        href: null,
        hrefLang: null,
        htmlFor: $64737a4e2e94905f$var$spaceSeparated,
        httpEquiv: $64737a4e2e94905f$var$spaceSeparated,
        id: null,
        imageSizes: null,
        imageSrcSet: $64737a4e2e94905f$var$commaSeparated,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: $64737a4e2e94905f$var$boolean,
        itemId: null,
        itemProp: $64737a4e2e94905f$var$spaceSeparated,
        itemRef: $64737a4e2e94905f$var$spaceSeparated,
        itemScope: $64737a4e2e94905f$var$boolean,
        itemType: $64737a4e2e94905f$var$spaceSeparated,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: $64737a4e2e94905f$var$boolean,
        low: $64737a4e2e94905f$var$number,
        manifest: null,
        max: null,
        maxLength: $64737a4e2e94905f$var$number,
        media: null,
        method: null,
        min: null,
        minLength: $64737a4e2e94905f$var$number,
        multiple: $64737a4e2e94905f$var$boolean,
        muted: $64737a4e2e94905f$var$boolean,
        name: null,
        nonce: null,
        noModule: $64737a4e2e94905f$var$boolean,
        noValidate: $64737a4e2e94905f$var$boolean,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextMenu: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: $64737a4e2e94905f$var$boolean,
        optimum: $64737a4e2e94905f$var$number,
        pattern: null,
        ping: $64737a4e2e94905f$var$spaceSeparated,
        placeholder: null,
        playsInline: $64737a4e2e94905f$var$boolean,
        poster: null,
        preload: null,
        readOnly: $64737a4e2e94905f$var$boolean,
        referrerPolicy: null,
        rel: $64737a4e2e94905f$var$spaceSeparated,
        required: $64737a4e2e94905f$var$boolean,
        reversed: $64737a4e2e94905f$var$boolean,
        rows: $64737a4e2e94905f$var$number,
        rowSpan: $64737a4e2e94905f$var$number,
        sandbox: $64737a4e2e94905f$var$spaceSeparated,
        scope: null,
        scoped: $64737a4e2e94905f$var$boolean,
        seamless: $64737a4e2e94905f$var$boolean,
        selected: $64737a4e2e94905f$var$boolean,
        shape: null,
        size: $64737a4e2e94905f$var$number,
        sizes: null,
        slot: null,
        span: $64737a4e2e94905f$var$number,
        spellCheck: $64737a4e2e94905f$var$booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: $64737a4e2e94905f$var$commaSeparated,
        start: $64737a4e2e94905f$var$number,
        step: null,
        style: null,
        tabIndex: $64737a4e2e94905f$var$number,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: $64737a4e2e94905f$var$boolean,
        useMap: null,
        value: $64737a4e2e94905f$var$booleanish,
        width: $64737a4e2e94905f$var$number,
        wrap: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        aLink: null,
        archive: $64737a4e2e94905f$var$spaceSeparated,
        axis: null,
        background: null,
        bgColor: null,
        border: $64737a4e2e94905f$var$number,
        borderColor: null,
        bottomMargin: $64737a4e2e94905f$var$number,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: $64737a4e2e94905f$var$boolean,
        declare: $64737a4e2e94905f$var$boolean,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: $64737a4e2e94905f$var$number,
        leftMargin: $64737a4e2e94905f$var$number,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: $64737a4e2e94905f$var$number,
        marginWidth: $64737a4e2e94905f$var$number,
        noResize: $64737a4e2e94905f$var$boolean,
        noHref: $64737a4e2e94905f$var$boolean,
        noShade: $64737a4e2e94905f$var$boolean,
        noWrap: $64737a4e2e94905f$var$boolean,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: $64737a4e2e94905f$var$number,
        rules: null,
        scheme: null,
        scrolling: $64737a4e2e94905f$var$booleanish,
        standby: null,
        summary: null,
        text: null,
        topMargin: $64737a4e2e94905f$var$number,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: $64737a4e2e94905f$var$number,
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: $64737a4e2e94905f$var$boolean,
        disableRemotePlayback: $64737a4e2e94905f$var$boolean,
        prefix: null,
        property: null,
        results: $64737a4e2e94905f$var$number,
        security: null,
        unselectable: null
    }
});

});


parcelRequire.register("fLbnY", function(module, exports) {
"use strict";

var $cjszp = parcelRequire("cjszp");

var $5b21o = parcelRequire("5b21o");

var $6fIb2 = parcelRequire("6fIb2");

var $bTnxE = parcelRequire("bTnxE");
var $b79413c053620107$require$spaces = $bTnxE.parse;

var $2Ja5D = parcelRequire("2Ja5D");
var $b79413c053620107$require$commas = $2Ja5D.parse;
module.exports = $b79413c053620107$var$factory;
var $b79413c053620107$var$own = {}.hasOwnProperty;
function $b79413c053620107$var$factory(schema, defaultTagName, caseSensitive) {
    var adjust = caseSensitive ? $b79413c053620107$var$createAdjustMap(caseSensitive) : null;
    return h;
    // Hyperscript compatible DSL for creating virtual hast trees.
    function h(selector, properties) {
        var node = $6fIb2(selector, defaultTagName);
        var children = Array.prototype.slice.call(arguments, 2);
        var name = node.tagName.toLowerCase();
        var property;
        node.tagName = adjust && $b79413c053620107$var$own.call(adjust, name) ? adjust[name] : name;
        if (properties && $b79413c053620107$var$isChildren(properties, node)) {
            children.unshift(properties);
            properties = null;
        }
        if (properties) {
            for(property in properties){
                addProperty(node.properties, property, properties[property]);
            }
        }
        $b79413c053620107$var$addChild(node.children, children);
        if (node.tagName === "template") {
            node.content = {
                type: "root",
                children: node.children
            };
            node.children = [];
        }
        return node;
    }
    function addProperty(properties, key, value) {
        var info;
        var property;
        var result;
        // Ignore nullish and NaN values.
        if (value === null || value === undefined || value !== value) {
            return;
        }
        info = $cjszp(schema, key);
        property = info.property;
        result = value;
        // Handle list values.
        if (typeof result === "string") {
            if (info.spaceSeparated) {
                result = $b79413c053620107$require$spaces(result);
            } else if (info.commaSeparated) {
                result = $b79413c053620107$require$commas(result);
            } else if (info.commaOrSpaceSeparated) {
                result = $b79413c053620107$require$spaces($b79413c053620107$require$commas(result).join(" "));
            }
        }
        // Accept `object` on style.
        if (property === "style" && typeof value !== "string") {
            result = $b79413c053620107$var$style(result);
        }
        // Class-names (which can be added both on the `selector` and here).
        if (property === "className" && properties.className) {
            result = properties.className.concat(result);
        }
        properties[property] = $b79413c053620107$var$parsePrimitives(info, property, result);
    }
}
function $b79413c053620107$var$isChildren(value, node) {
    return typeof value === "string" || "length" in value || $b79413c053620107$var$isNode(node.tagName, value);
}
function $b79413c053620107$var$isNode(tagName, value) {
    var type = value.type;
    if (tagName === "input" || !type || typeof type !== "string") return false;
    if (typeof value.children === "object" && "length" in value.children) return true;
    type = type.toLowerCase();
    if (tagName === "button") return type !== "menu" && type !== "submit" && type !== "reset" && type !== "button";
    return "value" in value;
}
function $b79413c053620107$var$addChild(nodes, value) {
    var index;
    var length;
    if (typeof value === "string" || typeof value === "number") {
        nodes.push({
            type: "text",
            value: String(value)
        });
        return;
    }
    if (typeof value === "object" && "length" in value) {
        index = -1;
        length = value.length;
        while(++index < length)$b79413c053620107$var$addChild(nodes, value[index]);
        return;
    }
    if (typeof value !== "object" || !("type" in value)) throw new Error("Expected node, nodes, or string, got `" + value + "`");
    nodes.push(value);
}
// Parse a (list of) primitives.
function $b79413c053620107$var$parsePrimitives(info, name, value) {
    var index;
    var length;
    var result;
    if (typeof value !== "object" || !("length" in value)) return $b79413c053620107$var$parsePrimitive(info, name, value);
    length = value.length;
    index = -1;
    result = [];
    while(++index < length)result[index] = $b79413c053620107$var$parsePrimitive(info, name, value[index]);
    return result;
}
// Parse a single primitives.
function $b79413c053620107$var$parsePrimitive(info, name, value) {
    var result = value;
    if (info.number || info.positiveNumber) {
        if (!isNaN(result) && result !== "") result = Number(result);
    } else if (info.boolean || info.overloadedBoolean) // Accept `boolean` and `string`.
    {
        if (typeof result === "string" && (result === "" || $5b21o(value) === $5b21o(name))) result = true;
    }
    return result;
}
function $b79413c053620107$var$style(value) {
    var result = [];
    var key;
    for(key in value)result.push([
        key,
        value[key]
    ].join(": "));
    return result.join("; ");
}
function $b79413c053620107$var$createAdjustMap(values) {
    var length = values.length;
    var index = -1;
    var result = {};
    var value;
    while(++index < length){
        value = values[index];
        result[value.toLowerCase()] = value;
    }
    return result;
}

});
parcelRequire.register("cjszp", function(module, exports) {
"use strict";

var $5b21o = parcelRequire("5b21o");

var $fwdsj = parcelRequire("fwdsj");

var $3DqAZ = parcelRequire("3DqAZ");
var $8f6d6bd29eb7e687$var$data = "data";
module.exports = $8f6d6bd29eb7e687$var$find;
var $8f6d6bd29eb7e687$var$valid = /^data[-\w.:]+$/i;
var $8f6d6bd29eb7e687$var$dash = /-[a-z]/g;
var $8f6d6bd29eb7e687$var$cap = /[A-Z]/g;
function $8f6d6bd29eb7e687$var$find(schema, value) {
    var normal = $5b21o(value);
    var prop = value;
    var Type = $3DqAZ;
    if (normal in schema.normal) return schema.property[schema.normal[normal]];
    if (normal.length > 4 && normal.slice(0, 4) === $8f6d6bd29eb7e687$var$data && $8f6d6bd29eb7e687$var$valid.test(value)) {
        // Attribute or property.
        if (value.charAt(4) === "-") prop = $8f6d6bd29eb7e687$var$datasetToProperty(value);
        else value = $8f6d6bd29eb7e687$var$datasetToAttribute(value);
        Type = $fwdsj;
    }
    return new Type(prop, value);
}
function $8f6d6bd29eb7e687$var$datasetToProperty(attribute) {
    var value = attribute.slice(5).replace($8f6d6bd29eb7e687$var$dash, $8f6d6bd29eb7e687$var$camelcase);
    return $8f6d6bd29eb7e687$var$data + value.charAt(0).toUpperCase() + value.slice(1);
}
function $8f6d6bd29eb7e687$var$datasetToAttribute(property) {
    var value = property.slice(4);
    if ($8f6d6bd29eb7e687$var$dash.test(value)) return property;
    value = value.replace($8f6d6bd29eb7e687$var$cap, $8f6d6bd29eb7e687$var$kebab);
    if (value.charAt(0) !== "-") value = "-" + value;
    return $8f6d6bd29eb7e687$var$data + value;
}
function $8f6d6bd29eb7e687$var$kebab($0) {
    return "-" + $0.toLowerCase();
}
function $8f6d6bd29eb7e687$var$camelcase($0) {
    return $0.charAt(1).toUpperCase();
}

});

parcelRequire.register("6fIb2", function(module, exports) {
"use strict";
module.exports = $48d6696ee5b16078$var$parse;
var $48d6696ee5b16078$var$search = /[#.]/g;
// Create a hast element from a simple CSS selector.
function $48d6696ee5b16078$var$parse(selector, defaultTagName) {
    var value = selector || "";
    var name = defaultTagName || "div";
    var props = {};
    var start = 0;
    var subvalue;
    var previous;
    var match;
    while(start < value.length){
        $48d6696ee5b16078$var$search.lastIndex = start;
        match = $48d6696ee5b16078$var$search.exec(value);
        subvalue = value.slice(start, match ? match.index : value.length);
        if (subvalue) {
            if (!previous) name = subvalue;
            else if (previous === "#") props.id = subvalue;
            else if (props.className) props.className.push(subvalue);
            else props.className = [
                subvalue
            ];
            start += subvalue.length;
        }
        if (match) {
            previous = match[0];
            start++;
        }
    }
    return {
        type: "element",
        tagName: name,
        properties: props,
        children: []
    };
}

});

parcelRequire.register("bTnxE", function(module, exports) {

$parcel$export(module.exports, "parse", () => $8a8717b0c6d47745$export$98e6a39c04603d36, (v) => $8a8717b0c6d47745$export$98e6a39c04603d36 = v);
var $8a8717b0c6d47745$export$98e6a39c04603d36;
var $8a8717b0c6d47745$export$fac44ee5b035f737;
"use strict";
$8a8717b0c6d47745$export$98e6a39c04603d36 = $8a8717b0c6d47745$var$parse;
$8a8717b0c6d47745$export$fac44ee5b035f737 = $8a8717b0c6d47745$var$stringify;
var $8a8717b0c6d47745$var$empty = "";
var $8a8717b0c6d47745$var$space = " ";
var $8a8717b0c6d47745$var$whiteSpace = /[ \t\n\r\f]+/g;
function $8a8717b0c6d47745$var$parse(value) {
    var input = String(value || $8a8717b0c6d47745$var$empty).trim();
    return input === $8a8717b0c6d47745$var$empty ? [] : input.split($8a8717b0c6d47745$var$whiteSpace);
}
function $8a8717b0c6d47745$var$stringify(values) {
    return values.join($8a8717b0c6d47745$var$space).trim();
}

});

parcelRequire.register("2Ja5D", function(module, exports) {

$parcel$export(module.exports, "parse", () => $1fc79c672bdf49b3$export$98e6a39c04603d36, (v) => $1fc79c672bdf49b3$export$98e6a39c04603d36 = v);
var $1fc79c672bdf49b3$export$98e6a39c04603d36;
var $1fc79c672bdf49b3$export$fac44ee5b035f737;
"use strict";
$1fc79c672bdf49b3$export$98e6a39c04603d36 = $1fc79c672bdf49b3$var$parse;
$1fc79c672bdf49b3$export$fac44ee5b035f737 = $1fc79c672bdf49b3$var$stringify;
var $1fc79c672bdf49b3$var$comma = ",";
var $1fc79c672bdf49b3$var$space = " ";
var $1fc79c672bdf49b3$var$empty = "";
// Parse comma-separated tokens to an array.
function $1fc79c672bdf49b3$var$parse(value) {
    var values = [];
    var input = String(value || $1fc79c672bdf49b3$var$empty);
    var index = input.indexOf($1fc79c672bdf49b3$var$comma);
    var lastIndex = 0;
    var end = false;
    var val;
    while(!end){
        if (index === -1) {
            index = input.length;
            end = true;
        }
        val = input.slice(lastIndex, index).trim();
        if (val || !end) values.push(val);
        lastIndex = index + 1;
        index = input.indexOf($1fc79c672bdf49b3$var$comma, lastIndex);
    }
    return values;
}
// Compile an array to comma-separated tokens.
// `options.padLeft` (default: `true`) pads a space left of each token, and
// `options.padRight` (default: `false`) pads a space to the right of each token.
function $1fc79c672bdf49b3$var$stringify(values, options) {
    var settings = options || {};
    var left = settings.padLeft === false ? $1fc79c672bdf49b3$var$empty : $1fc79c672bdf49b3$var$space;
    var right = settings.padRight ? $1fc79c672bdf49b3$var$space : $1fc79c672bdf49b3$var$empty;
    // Ensure the last empty entry is seen.
    if (values[values.length - 1] === $1fc79c672bdf49b3$var$empty) values = values.concat($1fc79c672bdf49b3$var$empty);
    return values.join(right + $1fc79c672bdf49b3$var$comma + left).trim();
}

});




parcelRequire.register("aqMEU", function(module, exports) {
"use strict";

var $aKgz1 = parcelRequire("aKgz1");

var $aHY3h = parcelRequire("aHY3h");

var $3xQ7L = parcelRequire("3xQ7L");

var $jhxM2 = parcelRequire("jhxM2");

var $lCCrz = parcelRequire("lCCrz");

var $dfKkp = parcelRequire("dfKkp");
module.exports = $798213b50cebbc19$var$parseEntities;
var $798213b50cebbc19$var$own = {}.hasOwnProperty;
var $798213b50cebbc19$var$fromCharCode = String.fromCharCode;
var $798213b50cebbc19$var$noop = Function.prototype;
// Default settings.
var $798213b50cebbc19$var$defaults = {
    warning: null,
    reference: null,
    text: null,
    warningContext: null,
    referenceContext: null,
    textContext: null,
    position: {},
    additional: null,
    attribute: false,
    nonTerminated: true
};
// Characters.
var $798213b50cebbc19$var$tab = 9 // '\t'
;
var $798213b50cebbc19$var$lineFeed = 10 // '\n'
;
var $798213b50cebbc19$var$formFeed = 12 // '\f'
;
var $798213b50cebbc19$var$space = 32 // ' '
;
var $798213b50cebbc19$var$ampersand = 38 // '&'
;
var $798213b50cebbc19$var$semicolon = 59 // ';'
;
var $798213b50cebbc19$var$lessThan = 60 // '<'
;
var $798213b50cebbc19$var$equalsTo = 61 // '='
;
var $798213b50cebbc19$var$numberSign = 35 // '#'
;
var $798213b50cebbc19$var$uppercaseX = 88 // 'X'
;
var $798213b50cebbc19$var$lowercaseX = 120 // 'x'
;
var $798213b50cebbc19$var$replacementCharacter = 65533 // '�'
;
// Reference types.
var $798213b50cebbc19$var$name = "named";
var $798213b50cebbc19$var$hexa = "hexadecimal";
var $798213b50cebbc19$var$deci = "decimal";
// Map of bases.
var $798213b50cebbc19$var$bases = {};
$798213b50cebbc19$var$bases[$798213b50cebbc19$var$hexa] = 16;
$798213b50cebbc19$var$bases[$798213b50cebbc19$var$deci] = 10;
// Map of types to tests.
// Each type of character reference accepts different characters.
// This test is used to detect whether a reference has ended (as the semicolon
// is not strictly needed).
var $798213b50cebbc19$var$tests = {};
$798213b50cebbc19$var$tests[$798213b50cebbc19$var$name] = $lCCrz;
$798213b50cebbc19$var$tests[$798213b50cebbc19$var$deci] = $3xQ7L;
$798213b50cebbc19$var$tests[$798213b50cebbc19$var$hexa] = $jhxM2;
// Warning types.
var $798213b50cebbc19$var$namedNotTerminated = 1;
var $798213b50cebbc19$var$numericNotTerminated = 2;
var $798213b50cebbc19$var$namedEmpty = 3;
var $798213b50cebbc19$var$numericEmpty = 4;
var $798213b50cebbc19$var$namedUnknown = 5;
var $798213b50cebbc19$var$numericDisallowed = 6;
var $798213b50cebbc19$var$numericProhibited = 7;
// Warning messages.
var $798213b50cebbc19$var$messages = {};
$798213b50cebbc19$var$messages[$798213b50cebbc19$var$namedNotTerminated] = "Named character references must be terminated by a semicolon";
$798213b50cebbc19$var$messages[$798213b50cebbc19$var$numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
$798213b50cebbc19$var$messages[$798213b50cebbc19$var$namedEmpty] = "Named character references cannot be empty";
$798213b50cebbc19$var$messages[$798213b50cebbc19$var$numericEmpty] = "Numeric character references cannot be empty";
$798213b50cebbc19$var$messages[$798213b50cebbc19$var$namedUnknown] = "Named character references must be known";
$798213b50cebbc19$var$messages[$798213b50cebbc19$var$numericDisallowed] = "Numeric character references cannot be disallowed";
$798213b50cebbc19$var$messages[$798213b50cebbc19$var$numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
// Wrap to ensure clean parameters are given to `parse`.
function $798213b50cebbc19$var$parseEntities(value, options) {
    var settings = {};
    var option;
    var key;
    if (!options) options = {};
    for(key in $798213b50cebbc19$var$defaults){
        option = options[key];
        settings[key] = option === null || option === undefined ? $798213b50cebbc19$var$defaults[key] : option;
    }
    if (settings.position.indent || settings.position.start) {
        settings.indent = settings.position.indent || [];
        settings.position = settings.position.start;
    }
    return $798213b50cebbc19$var$parse(value, settings);
}
// Parse entities.
// eslint-disable-next-line complexity
function $798213b50cebbc19$var$parse(value, settings) {
    var additional = settings.additional;
    var nonTerminated = settings.nonTerminated;
    var handleText = settings.text;
    var handleReference = settings.reference;
    var handleWarning = settings.warning;
    var textContext = settings.textContext;
    var referenceContext = settings.referenceContext;
    var warningContext = settings.warningContext;
    var pos = settings.position;
    var indent = settings.indent || [];
    var length = value.length;
    var index = 0;
    var lines = -1;
    var column = pos.column || 1;
    var line = pos.line || 1;
    var queue = "";
    var result = [];
    var entityCharacters;
    var namedEntity;
    var terminated;
    var characters;
    var character;
    var reference;
    var following;
    var warning;
    var reason;
    var output;
    var entity;
    var begin;
    var start;
    var type;
    var test;
    var prev;
    var next;
    var diff;
    var end;
    if (typeof additional === "string") additional = additional.charCodeAt(0);
    // Cache the current point.
    prev = now();
    // Wrap `handleWarning`.
    warning = handleWarning ? parseError : $798213b50cebbc19$var$noop;
    // Ensure the algorithm walks over the first character and the end
    // (inclusive).
    index--;
    length++;
    while(++index < length){
        // If the previous character was a newline.
        if (character === $798213b50cebbc19$var$lineFeed) column = indent[lines] || 1;
        character = value.charCodeAt(index);
        if (character === $798213b50cebbc19$var$ampersand) {
            following = value.charCodeAt(index + 1);
            // The behaviour depends on the identity of the next character.
            if (following === $798213b50cebbc19$var$tab || following === $798213b50cebbc19$var$lineFeed || following === $798213b50cebbc19$var$formFeed || following === $798213b50cebbc19$var$space || following === $798213b50cebbc19$var$ampersand || following === $798213b50cebbc19$var$lessThan || following !== following || additional && following === additional) {
                // Not a character reference.
                // No characters are consumed, and nothing is returned.
                // This is not an error, either.
                queue += $798213b50cebbc19$var$fromCharCode(character);
                column++;
                continue;
            }
            start = index + 1;
            begin = start;
            end = start;
            if (following === $798213b50cebbc19$var$numberSign) {
                // Numerical entity.
                end = ++begin;
                // The behaviour further depends on the next character.
                following = value.charCodeAt(end);
                if (following === $798213b50cebbc19$var$uppercaseX || following === $798213b50cebbc19$var$lowercaseX) {
                    // ASCII hex digits.
                    type = $798213b50cebbc19$var$hexa;
                    end = ++begin;
                } else // ASCII digits.
                type = $798213b50cebbc19$var$deci;
            } else // Named entity.
            type = $798213b50cebbc19$var$name;
            entityCharacters = "";
            entity = "";
            characters = "";
            test = $798213b50cebbc19$var$tests[type];
            end--;
            while(++end < length){
                following = value.charCodeAt(end);
                if (!test(following)) break;
                characters += $798213b50cebbc19$var$fromCharCode(following);
                // Check if we can match a legacy named reference.
                // If so, we cache that as the last viable named reference.
                // This ensures we do not need to walk backwards later.
                if (type === $798213b50cebbc19$var$name && $798213b50cebbc19$var$own.call($aKgz1, characters)) {
                    entityCharacters = characters;
                    entity = $aKgz1[characters];
                }
            }
            terminated = value.charCodeAt(end) === $798213b50cebbc19$var$semicolon;
            if (terminated) {
                end++;
                namedEntity = type === $798213b50cebbc19$var$name ? $dfKkp(characters) : false;
                if (namedEntity) {
                    entityCharacters = characters;
                    entity = namedEntity;
                }
            }
            diff = 1 + end - start;
            if (!terminated && !nonTerminated) ;
            else if (!characters) // An empty (possible) entity is valid, unless it’s numeric (thus an
            // ampersand followed by an octothorp).
            {
                if (type !== $798213b50cebbc19$var$name) warning($798213b50cebbc19$var$numericEmpty, diff);
            } else if (type === $798213b50cebbc19$var$name) {
                // An ampersand followed by anything unknown, and not terminated, is
                // invalid.
                if (terminated && !entity) warning($798213b50cebbc19$var$namedUnknown, 1);
                else {
                    // If theres something after an entity name which is not known, cap
                    // the reference.
                    if (entityCharacters !== characters) {
                        end = begin + entityCharacters.length;
                        diff = 1 + end - begin;
                        terminated = false;
                    }
                    // If the reference is not terminated, warn.
                    if (!terminated) {
                        reason = entityCharacters ? $798213b50cebbc19$var$namedNotTerminated : $798213b50cebbc19$var$namedEmpty;
                        if (settings.attribute) {
                            following = value.charCodeAt(end);
                            if (following === $798213b50cebbc19$var$equalsTo) {
                                warning(reason, diff);
                                entity = null;
                            } else if ($lCCrz(following)) entity = null;
                            else warning(reason, diff);
                        } else warning(reason, diff);
                    }
                }
                reference = entity;
            } else {
                if (!terminated) // All non-terminated numeric entities are not rendered, and trigger a
                // warning.
                warning($798213b50cebbc19$var$numericNotTerminated, diff);
                // When terminated and number, parse as either hexadecimal or decimal.
                reference = parseInt(characters, $798213b50cebbc19$var$bases[type]);
                // Trigger a warning when the parsed number is prohibited, and replace
                // with replacement character.
                if ($798213b50cebbc19$var$prohibited(reference)) {
                    warning($798213b50cebbc19$var$numericProhibited, diff);
                    reference = $798213b50cebbc19$var$fromCharCode($798213b50cebbc19$var$replacementCharacter);
                } else if (reference in $aHY3h) {
                    // Trigger a warning when the parsed number is disallowed, and replace
                    // by an alternative.
                    warning($798213b50cebbc19$var$numericDisallowed, diff);
                    reference = $aHY3h[reference];
                } else {
                    // Parse the number.
                    output = "";
                    // Trigger a warning when the parsed number should not be used.
                    if ($798213b50cebbc19$var$disallowed(reference)) warning($798213b50cebbc19$var$numericDisallowed, diff);
                    // Stringify the number.
                    if (reference > 0xffff) {
                        reference -= 0x10000;
                        output += $798213b50cebbc19$var$fromCharCode(reference >>> 10 | 0xd800);
                        reference = 0xdc00 | reference & 0x3ff;
                    }
                    reference = output + $798213b50cebbc19$var$fromCharCode(reference);
                }
            }
            // Found it!
            // First eat the queued characters as normal text, then eat an entity.
            if (reference) {
                flush();
                prev = now();
                index = end - 1;
                column += end - start + 1;
                result.push(reference);
                next = now();
                next.offset++;
                if (handleReference) handleReference.call(referenceContext, reference, {
                    start: prev,
                    end: next
                }, value.slice(start - 1, end));
                prev = next;
            } else {
                // If we could not find a reference, queue the checked characters (as
                // normal characters), and move the pointer to their end.
                // This is possible because we can be certain neither newlines nor
                // ampersands are included.
                characters = value.slice(start - 1, end);
                queue += characters;
                column += characters.length;
                index = end - 1;
            }
        } else {
            // Handle anything other than an ampersand, including newlines and EOF.
            if (character === 10 // Line feed
            ) {
                line++;
                lines++;
                column = 0;
            }
            if (character === character) {
                queue += $798213b50cebbc19$var$fromCharCode(character);
                column++;
            } else flush();
        }
    }
    // Return the reduced nodes.
    return result.join("");
    // Get current position.
    function now() {
        return {
            line: line,
            column: column,
            offset: index + (pos.offset || 0)
        };
    }
    // “Throw” a parse-error: a warning.
    function parseError(code, offset) {
        var position = now();
        position.column += offset;
        position.offset += offset;
        handleWarning.call(warningContext, $798213b50cebbc19$var$messages[code], position, code);
    }
    // Flush `queue` (normal text).
    // Macro invoked before each entity and at the end of `value`.
    // Does nothing when `queue` is empty.
    function flush() {
        if (queue) {
            result.push(queue);
            if (handleText) {
                handleText.call(textContext, queue, {
                    start: prev,
                    end: now()
                });
            }
            queue = "";
        }
    }
}
// Check if `character` is outside the permissible unicode range.
function $798213b50cebbc19$var$prohibited(code) {
    return code >= 0xd800 && code <= 0xdfff || code > 0x10ffff;
}
// Check if `character` is disallowed.
function $798213b50cebbc19$var$disallowed(code) {
    return code >= 0x0001 && code <= 0x0008 || code === 0x000b || code >= 0x000d && code <= 0x001f || code >= 0x007f && code <= 0x009f || code >= 0xfdd0 && code <= 0xfdef || (code & 0xffff) === 0xffff || (code & 0xffff) === 0xfffe;
}

});
parcelRequire.register("aKgz1", function(module, exports) {
module.exports = JSON.parse('{"AElig":"\xc6","AMP":"&","Aacute":"\xc1","Acirc":"\xc2","Agrave":"\xc0","Aring":"\xc5","Atilde":"\xc3","Auml":"\xc4","COPY":"\xa9","Ccedil":"\xc7","ETH":"\xd0","Eacute":"\xc9","Ecirc":"\xca","Egrave":"\xc8","Euml":"\xcb","GT":">","Iacute":"\xcd","Icirc":"\xce","Igrave":"\xcc","Iuml":"\xcf","LT":"<","Ntilde":"\xd1","Oacute":"\xd3","Ocirc":"\xd4","Ograve":"\xd2","Oslash":"\xd8","Otilde":"\xd5","Ouml":"\xd6","QUOT":"\\"","REG":"\xae","THORN":"\xde","Uacute":"\xda","Ucirc":"\xdb","Ugrave":"\xd9","Uuml":"\xdc","Yacute":"\xdd","aacute":"\xe1","acirc":"\xe2","acute":"\xb4","aelig":"\xe6","agrave":"\xe0","amp":"&","aring":"\xe5","atilde":"\xe3","auml":"\xe4","brvbar":"\xa6","ccedil":"\xe7","cedil":"\xb8","cent":"\xa2","copy":"\xa9","curren":"\xa4","deg":"\xb0","divide":"\xf7","eacute":"\xe9","ecirc":"\xea","egrave":"\xe8","eth":"\xf0","euml":"\xeb","frac12":"\xbd","frac14":"\xbc","frac34":"\xbe","gt":">","iacute":"\xed","icirc":"\xee","iexcl":"\xa1","igrave":"\xec","iquest":"\xbf","iuml":"\xef","laquo":"\xab","lt":"<","macr":"\xaf","micro":"\xb5","middot":"\xb7","nbsp":"\xa0","not":"\xac","ntilde":"\xf1","oacute":"\xf3","ocirc":"\xf4","ograve":"\xf2","ordf":"\xaa","ordm":"\xba","oslash":"\xf8","otilde":"\xf5","ouml":"\xf6","para":"\xb6","plusmn":"\xb1","pound":"\xa3","quot":"\\"","raquo":"\xbb","reg":"\xae","sect":"\xa7","shy":"\xad","sup1":"\xb9","sup2":"\xb2","sup3":"\xb3","szlig":"\xdf","thorn":"\xfe","times":"\xd7","uacute":"\xfa","ucirc":"\xfb","ugrave":"\xf9","uml":"\xa8","uuml":"\xfc","yacute":"\xfd","yen":"\xa5","yuml":"\xff"}');

});

parcelRequire.register("aHY3h", function(module, exports) {
module.exports = JSON.parse('{"0":"\uFFFD","128":"\u20AC","130":"\u201A","131":"\u0192","132":"\u201E","133":"\u2026","134":"\u2020","135":"\u2021","136":"\u02C6","137":"\u2030","138":"\u0160","139":"\u2039","140":"\u0152","142":"\u017D","145":"\u2018","146":"\u2019","147":"\u201C","148":"\u201D","149":"\u2022","150":"\u2013","151":"\u2014","152":"\u02DC","153":"\u2122","154":"\u0161","155":"\u203A","156":"\u0153","158":"\u017E","159":"\u0178"}');

});

parcelRequire.register("3xQ7L", function(module, exports) {
"use strict";
module.exports = $294ce2f7c2d1009f$var$decimal;
// Check if the given character code, or the character code at the first
// character, is decimal.
function $294ce2f7c2d1009f$var$decimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 48 && code <= 57 /* 0-9 */ ;
}

});

parcelRequire.register("jhxM2", function(module, exports) {
"use strict";
module.exports = $e099cda34d9c5506$var$hexadecimal;
// Check if the given character code, or the character code at the first
// character, is hexadecimal.
function $e099cda34d9c5506$var$hexadecimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 /* a */  && code <= 102 || code >= 65 /* A */  && code <= 70 || code >= 48 /* A */  && code <= 57;
}

});

parcelRequire.register("lCCrz", function(module, exports) {
"use strict";

var $9PYCL = parcelRequire("9PYCL");

var $3xQ7L = parcelRequire("3xQ7L");
module.exports = $fbdaf7ae4deaa073$var$alphanumerical;
// Check if the given character code, or the character code at the first
// character, is alphanumerical.
function $fbdaf7ae4deaa073$var$alphanumerical(character) {
    return $9PYCL(character) || $3xQ7L(character);
}

});
parcelRequire.register("9PYCL", function(module, exports) {
"use strict";
module.exports = $7297e73410498a4e$var$alphabetical;
// Check if the given character code, or the character code at the first
// character, is alphabetical.
function $7297e73410498a4e$var$alphabetical(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}

});


parcelRequire.register("dfKkp", function(module, exports) {
"use strict";
/* eslint-env browser */ var $9a609ce3b8bc4761$var$el;
var $9a609ce3b8bc4761$var$semicolon = 59 //  ';'
;
module.exports = $9a609ce3b8bc4761$var$decodeEntity;
function $9a609ce3b8bc4761$var$decodeEntity(characters) {
    var entity = "&" + characters + ";";
    var char;
    $9a609ce3b8bc4761$var$el = $9a609ce3b8bc4761$var$el || document.createElement("i");
    $9a609ce3b8bc4761$var$el.innerHTML = entity;
    char = $9a609ce3b8bc4761$var$el.textContent;
    // Some entities do not require the closing semicolon (`&not` - for instance),
    // which leads to situations where parsing the assumed entity of &notit; will
    // result in the string `¬it;`.  When we encounter a trailing semicolon after
    // parsing and the entity to decode was not a semicolon (`&semi;`), we can
    // assume that the matching was incomplete
    if (char.charCodeAt(char.length - 1) === $9a609ce3b8bc4761$var$semicolon && characters !== "semi") return false;
    // If the decoded string is equal to the input, the entity was not valid
    return char === entity ? false : char;
}

});


parcelRequire.register("jQbe3", function(module, exports) {
/// <reference lib="WebWorker"/>
var $e71b94d923314dab$var$_self = typeof window !== "undefined" ? window // if in browser
 : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self // if in worker
 : {} // if in node js
;
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */ var $e71b94d923314dab$var$Prism = function(_self1) {
    // Private helper vars
    var lang1 = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    // The grammar object for plaintext
    var plainTextGrammar = {};
    var _ = {
        /**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */ manual: _self1.Prism && _self1.Prism.manual,
        /**
		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
		 * own worker, you don't want it to do this.
		 *
		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
		 *
		 * You obviously have to change this value before Prism executes. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.disableWorkerMessageHandler = true;
		 * // Load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */ disableWorkerMessageHandler: _self1.Prism && _self1.Prism.disableWorkerMessageHandler,
        /**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */ util: {
            encode: function encode(tokens) {
                if (tokens instanceof Token) return new Token(tokens.type, encode(tokens.content), tokens.alias);
                else if (Array.isArray(tokens)) return tokens.map(encode);
                else return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            },
            /**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */ type: function(o) {
                return Object.prototype.toString.call(o).slice(8, -1);
            },
            /**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */ objId: function(obj) {
                if (!obj["__id"]) Object.defineProperty(obj, "__id", {
                    value: ++uniqueId
                });
                return obj["__id"];
            },
            /**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */ clone: function deepClone(o, visited) {
                visited = visited || {};
                var clone;
                var id;
                switch(_.util.type(o)){
                    case "Object":
                        id = _.util.objId(o);
                        if (visited[id]) return visited[id];
                        clone = {};
                        visited[id] = clone;
                        for(var key in o)if (o.hasOwnProperty(key)) clone[key] = deepClone(o[key], visited);
                        return clone;
                    case "Array":
                        id = _.util.objId(o);
                        if (visited[id]) return visited[id];
                        clone = [];
                        visited[id] = clone;
                        o.forEach(function(v, i) {
                            clone[i] = deepClone(v, visited);
                        });
                        return clone;
                    default:
                        return o;
                }
            },
            /**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */ getLanguage: function(element) {
                while(element){
                    var m = lang1.exec(element.className);
                    if (m) return m[1].toLowerCase();
                    element = element.parentElement;
                }
                return "none";
            },
            /**
			 * Sets the Prism `language-xxxx` class of the given element.
			 *
			 * @param {Element} element
			 * @param {string} language
			 * @returns {void}
			 */ setLanguage: function(element, language) {
                // remove all `language-xxxx` classes
                // (this might leave behind a leading space)
                element.className = element.className.replace(RegExp(lang1, "gi"), "");
                // add the new `language-xxxx` class
                // (using `classList` will automatically clean up spaces for us)
                element.classList.add("language-" + language);
            },
            /**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */ currentScript: function() {
                if (typeof document === "undefined") return null;
                if ("currentScript" in document && true /* hack to trip TS' flow analysis */ ) return document.currentScript;
                // IE11 workaround
                // we'll get the src of the current script by parsing IE11's error stack trace
                // this will not work for inline scripts
                try {
                    throw new Error();
                } catch (err) {
                    // Get file src url from stack. Specifically works with the format of stack traces in IE.
                    // A stack will look like this:
                    //
                    // Error
                    //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
                    //    at Global code (http://localhost/components/prism-core.js:606:1)
                    var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                    if (src) {
                        var scripts = document.getElementsByTagName("script");
                        for(var i in scripts){
                            if (scripts[i].src == src) return scripts[i];
                        }
                    }
                    return null;
                }
            },
            /**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */ isActive: function(element, className, defaultActivation) {
                var no = "no-" + className;
                while(element){
                    var classList = element.classList;
                    if (classList.contains(className)) return true;
                    if (classList.contains(no)) return false;
                    element = element.parentElement;
                }
                return !!defaultActivation;
            }
        },
        /**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */ languages: {
            /**
			 * The grammar for plain, unformatted text.
			 */ plain: plainTextGrammar,
            plaintext: plainTextGrammar,
            text: plainTextGrammar,
            txt: plainTextGrammar,
            /**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */ extend: function(id, redef) {
                var lang = _.util.clone(_.languages[id]);
                for(var key in redef)lang[key] = redef[key];
                return lang;
            },
            /**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */ insertBefore: function(inside, before, insert, root) {
                root = root || _.languages;
                var grammar = root[inside];
                /** @type {Grammar} */ var ret = {};
                for(var token in grammar)if (grammar.hasOwnProperty(token)) {
                    if (token == before) {
                        for(var newToken in insert)if (insert.hasOwnProperty(newToken)) ret[newToken] = insert[newToken];
                    }
                    // Do not insert token which also occur in insert. See #1525
                    if (!insert.hasOwnProperty(token)) ret[token] = grammar[token];
                }
                var old = root[inside];
                root[inside] = ret;
                // Update references in other language definitions
                _.languages.DFS(_.languages, function(key, value) {
                    if (value === old && key != inside) this[key] = ret;
                });
                return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o, callback, type, visited) {
                visited = visited || {};
                var objId = _.util.objId;
                for(var i in o)if (o.hasOwnProperty(i)) {
                    callback.call(o, i, o[i], type || i);
                    var property = o[i];
                    var propertyType = _.util.type(property);
                    if (propertyType === "Object" && !visited[objId(property)]) {
                        visited[objId(property)] = true;
                        DFS(property, callback, null, visited);
                    } else if (propertyType === "Array" && !visited[objId(property)]) {
                        visited[objId(property)] = true;
                        DFS(property, callback, i, visited);
                    }
                }
            }
        },
        plugins: {},
        /**
		 * This is the most high-level function in Prism’s API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */ highlightAll: function(async, callback) {
            _.highlightAllUnder(document, async, callback);
        },
        /**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */ highlightAllUnder: function(container, async, callback) {
            var env = {
                callback: callback,
                container: container,
                selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _.hooks.run("before-highlightall", env);
            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
            _.hooks.run("before-all-elements-highlight", env);
            for(var i = 0, element; element = env.elements[i++];)_.highlightElement(element, async === true, env.callback);
        },
        /**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */ highlightElement: function(element, async, callback) {
            // Find language
            var language = _.util.getLanguage(element);
            var grammar = _.languages[language];
            // Set language on the element, if not present
            _.util.setLanguage(element, language);
            // Set language on the parent, for styling
            var parent = element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre") _.util.setLanguage(parent, language);
            var code = element.textContent;
            var env = {
                element: element,
                language: language,
                grammar: grammar,
                code: code
            };
            function insertHighlightedCode(highlightedCode) {
                env.highlightedCode = highlightedCode;
                _.hooks.run("before-insert", env);
                env.element.innerHTML = env.highlightedCode;
                _.hooks.run("after-highlight", env);
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
            }
            _.hooks.run("before-sanity-check", env);
            // plugins may change/add the parent/element
            parent = env.element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) parent.setAttribute("tabindex", "0");
            if (!env.code) {
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
                return;
            }
            _.hooks.run("before-highlight", env);
            if (!env.grammar) {
                insertHighlightedCode(_.util.encode(env.code));
                return;
            }
            if (async && _self1.Worker) {
                var worker = new Worker(_.filename);
                worker.onmessage = function(evt) {
                    insertHighlightedCode(evt.data);
                };
                worker.postMessage(JSON.stringify({
                    language: env.language,
                    code: env.code,
                    immediateClose: true
                }));
            } else insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
        },
        /**
		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */ highlight: function(text, grammar, language) {
            var env = {
                code: text,
                grammar: grammar,
                language: language
            };
            _.hooks.run("before-tokenize", env);
            if (!env.grammar) throw new Error('The language "' + env.language + '" has no grammar.');
            env.tokens = _.tokenize(env.code, env.grammar);
            _.hooks.run("after-tokenize", env);
            return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */ tokenize: function(text, grammar) {
            var rest = grammar.rest;
            if (rest) {
                for(var token in rest)grammar[token] = rest[token];
                delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text);
            matchGrammar(text, tokenList, grammar, tokenList.head, 0);
            return toArray(tokenList);
        },
        /**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */ hooks: {
            all: {},
            /**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */ add: function(name, callback) {
                var hooks = _.hooks.all;
                hooks[name] = hooks[name] || [];
                hooks[name].push(callback);
            },
            /**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */ run: function(name, env) {
                var callbacks = _.hooks.all[name];
                if (!callbacks || !callbacks.length) return;
                for(var i = 0, callback; callback = callbacks[i++];)callback(env);
            }
        },
        Token: Token
    };
    _self1.Prism = _;
    // Typescript note:
    // The following can be used to import the Token type in JSDoc:
    //
    //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
    /**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */ function Token(type, content, alias, matchedStr) {
        /**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */ this.type = type;
        /**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */ this.content = content;
        /**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */ this.alias = alias;
        // Copy of the full string this token was created from
        this.length = (matchedStr || "").length | 0;
    }
    /**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */ /**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */ Token.stringify = function stringify(o, language) {
        if (typeof o == "string") return o;
        if (Array.isArray(o)) {
            var s = "";
            o.forEach(function(e) {
                s += stringify(e, language);
            });
            return s;
        }
        var env = {
            type: o.type,
            content: stringify(o.content, language),
            tag: "span",
            classes: [
                "token",
                o.type
            ],
            attributes: {},
            language: language
        };
        var aliases = o.alias;
        if (aliases) {
            if (Array.isArray(aliases)) Array.prototype.push.apply(env.classes, aliases);
            else env.classes.push(aliases);
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for(var name in env.attributes)attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    /**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */ function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
            // change the match to remove the text matched by the Prism lookbehind group
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
        }
        return match;
    }
    /**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */ function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for(var token in grammar){
            if (!grammar.hasOwnProperty(token) || !grammar[token]) continue;
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [
                patterns
            ];
            for(var j = 0; j < patterns.length; ++j){
                if (rematch && rematch.cause == token + "," + j) return;
                var patternObj = patterns[j];
                var inside = patternObj.inside;
                var lookbehind = !!patternObj.lookbehind;
                var greedy = !!patternObj.greedy;
                var alias = patternObj.alias;
                if (greedy && !patternObj.pattern.global) {
                    // Without the global flag, lastIndex won't work
                    var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                    patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
                }
                /** @type {RegExp} */ var pattern = patternObj.pattern || patternObj;
                for(var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next){
                    if (rematch && pos >= rematch.reach) break;
                    var str = currentNode.value;
                    if (tokenList.length > text.length) // Something went terribly wrong, ABORT, ABORT!
                    return;
                    if (str instanceof Token) continue;
                    var removeCount = 1; // this is the to parameter of removeBetween
                    var match;
                    if (greedy) {
                        match = matchPattern(pattern, pos, text, lookbehind);
                        if (!match || match.index >= text.length) break;
                        var from = match.index;
                        var to = match.index + match[0].length;
                        var p = pos;
                        // find the node that contains the match
                        p += currentNode.value.length;
                        while(from >= p){
                            currentNode = currentNode.next;
                            p += currentNode.value.length;
                        }
                        // adjust pos (and p)
                        p -= currentNode.value.length;
                        pos = p;
                        // the current node is a Token, then the match starts inside another Token, which is invalid
                        if (currentNode.value instanceof Token) continue;
                        // find the last node which is affected by this match
                        for(var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next){
                            removeCount++;
                            p += k.value.length;
                        }
                        removeCount--;
                        // replace with the new match
                        str = text.slice(pos, p);
                        match.index -= pos;
                    } else {
                        match = matchPattern(pattern, 0, str, lookbehind);
                        if (!match) continue;
                    }
                    // eslint-disable-next-line no-redeclare
                    var from = match.index;
                    var matchStr = match[0];
                    var before = str.slice(0, from);
                    var after = str.slice(from + matchStr.length);
                    var reach = pos + str.length;
                    if (rematch && reach > rematch.reach) rematch.reach = reach;
                    var removeFrom = currentNode.prev;
                    if (before) {
                        removeFrom = addAfter(tokenList, removeFrom, before);
                        pos += before.length;
                    }
                    removeRange(tokenList, removeFrom, removeCount);
                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                    currentNode = addAfter(tokenList, removeFrom, wrapped);
                    if (after) addAfter(tokenList, currentNode, after);
                    if (removeCount > 1) {
                        // at least one Token object was removed, so we have to do some rematching
                        // this can only happen if the current pattern is greedy
                        /** @type {RematchOptions} */ var nestedRematch = {
                            cause: token + "," + j,
                            reach: reach
                        };
                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                        // the reach might have been extended because of the rematching
                        if (rematch && nestedRematch.reach > rematch.reach) rematch.reach = nestedRematch.reach;
                    }
                }
            }
        }
    }
    /**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */ /**
	 * @template T
	 * @private
	 */ function LinkedList() {
        /** @type {LinkedListNode<T>} */ var head = {
            value: null,
            prev: null,
            next: null
        };
        /** @type {LinkedListNode<T>} */ var tail = {
            value: null,
            prev: head,
            next: null
        };
        head.next = tail;
        /** @type {LinkedListNode<T>} */ this.head = head;
        /** @type {LinkedListNode<T>} */ this.tail = tail;
        this.length = 0;
    }
    /**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */ function addAfter(list, node, value) {
        // assumes that node != list.tail && values.length >= 0
        var next = node.next;
        var newNode = {
            value: value,
            prev: node,
            next: next
        };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
    }
    /**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */ function removeRange(list, node, count) {
        var next = node.next;
        for(var i = 0; i < count && next !== list.tail; i++)next = next.next;
        node.next = next;
        next.prev = node;
        list.length -= i;
    }
    /**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */ function toArray(list) {
        var array = [];
        var node = list.head.next;
        while(node !== list.tail){
            array.push(node.value);
            node = node.next;
        }
        return array;
    }
    if (!_self1.document) {
        if (!_self1.addEventListener) // in Node.js
        return _;
        if (!_.disableWorkerMessageHandler) // In worker
        _self1.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self1.postMessage(_.highlight(code, _.languages[lang], lang));
            if (immediateClose) _self1.close();
        }, false);
        return _;
    }
    // Get current script and highlight
    var script = _.util.currentScript();
    if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) _.manual = true;
    }
    function highlightAutomaticallyCallback() {
        if (!_.manual) _.highlightAll();
    }
    if (!_.manual) {
        // If the document state is "loading", then we'll use DOMContentLoaded.
        // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
        // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
        // might take longer one animation frame to execute which can create a race condition where only some plugins have
        // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
        // See https://github.com/PrismJS/prism/issues/2102
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        else if (window.requestAnimationFrame) window.requestAnimationFrame(highlightAutomaticallyCallback);
        else window.setTimeout(highlightAutomaticallyCallback, 16);
    }
    return _;
}($e71b94d923314dab$var$_self);
if (module.exports) module.exports = $e71b94d923314dab$var$Prism;
// hack for components to work correctly in node.js
if (typeof $parcel$global !== "undefined") $parcel$global.Prism = $e71b94d923314dab$var$Prism;
 // some additional documentation/types
 /**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */  /**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */  /**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */  /**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */ 

});

parcelRequire.register("kXqLl", function(module, exports) {
"use strict";
module.exports = $f41e13d44819049b$var$markup;
$f41e13d44819049b$var$markup.displayName = "markup";
$f41e13d44819049b$var$markup.aliases = [
    "html",
    "mathml",
    "svg",
    "xml",
    "ssml",
    "atom",
    "rss"
];
function $f41e13d44819049b$var$markup(Prism) {
    Prism.languages.markup = {
        comment: {
            pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
            greedy: true
        },
        prolog: {
            pattern: /<\?[\s\S]+?\?>/,
            greedy: true
        },
        doctype: {
            // https://www.w3.org/TR/xml/#NT-doctypedecl
            pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
            greedy: true,
            inside: {
                "internal-subset": {
                    pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                    lookbehind: true,
                    greedy: true,
                    inside: null // see below
                },
                string: {
                    pattern: /"[^"]*"|'[^']*'/,
                    greedy: true
                },
                punctuation: /^<!|>$|[[\]]/,
                "doctype-tag": /^DOCTYPE/i,
                name: /[^\s<>'"]+/
            }
        },
        cdata: {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            greedy: true
        },
        tag: {
            pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
            greedy: true,
            inside: {
                tag: {
                    pattern: /^<\/?[^\s>\/]+/,
                    inside: {
                        punctuation: /^<\/?/,
                        namespace: /^[^\s>\/:]+:/
                    }
                },
                "special-attr": [],
                "attr-value": {
                    pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                    inside: {
                        punctuation: [
                            {
                                pattern: /^=/,
                                alias: "attr-equals"
                            },
                            /"|'/
                        ]
                    }
                },
                punctuation: /\/?>/,
                "attr-name": {
                    pattern: /[^\s>\/]+/,
                    inside: {
                        namespace: /^[^\s>\/:]+:/
                    }
                }
            }
        },
        entity: [
            {
                pattern: /&[\da-z]{1,8};/i,
                alias: "named-entity"
            },
            /&#x?[\da-f]{1,8};/i
        ]
    };
    Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
    Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup // Plugin to make entity title show the real entity, idea by Roman Komarov
    ;
    Prism.hooks.add("wrap", function(env) {
        if (env.type === "entity") env.attributes["title"] = env.content.value.replace(/&amp;/, "&");
    });
    Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
        /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */ value: function addInlined(tagName, lang) {
            var includedCdataInside = {};
            includedCdataInside["language-" + lang] = {
                pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
                lookbehind: true,
                inside: Prism.languages[lang]
            };
            includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
            var inside = {
                "included-cdata": {
                    pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                    inside: includedCdataInside
                }
            };
            inside["language-" + lang] = {
                pattern: /[\s\S]+/,
                inside: Prism.languages[lang]
            };
            var def = {};
            def[tagName] = {
                pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
                    return tagName;
                }), "i"),
                lookbehind: true,
                greedy: true,
                inside: inside
            };
            Prism.languages.insertBefore("markup", "cdata", def);
        }
    });
    Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
        /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */ value: function(attrName, lang) {
            Prism.languages.markup.tag.inside["special-attr"].push({
                pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
                lookbehind: true,
                inside: {
                    "attr-name": /^[^\s=]+/,
                    "attr-value": {
                        pattern: /=[\s\S]+/,
                        inside: {
                            value: {
                                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                                lookbehind: true,
                                alias: [
                                    lang,
                                    "language-" + lang
                                ],
                                inside: Prism.languages[lang]
                            },
                            punctuation: [
                                {
                                    pattern: /^=/,
                                    alias: "attr-equals"
                                },
                                /"|'/
                            ]
                        }
                    }
                }
            });
        }
    });
    Prism.languages.html = Prism.languages.markup;
    Prism.languages.mathml = Prism.languages.markup;
    Prism.languages.svg = Prism.languages.markup;
    Prism.languages.xml = Prism.languages.extend("markup", {});
    Prism.languages.ssml = Prism.languages.xml;
    Prism.languages.atom = Prism.languages.xml;
    Prism.languages.rss = Prism.languages.xml;
}

});

parcelRequire.register("lXGdk", function(module, exports) {
"use strict";
module.exports = $ffcfda7520bec0af$var$css;
$ffcfda7520bec0af$var$css.displayName = "css";
$ffcfda7520bec0af$var$css.aliases = [];
function $ffcfda7520bec0af$var$css(Prism1) {
    (function(Prism) {
        var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        Prism.languages.css = {
            comment: /\/\*[\s\S]*?\*\//,
            atrule: {
                pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
                inside: {
                    rule: /^@[\w-]+/,
                    "selector-function-argument": {
                        pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                        lookbehind: true,
                        alias: "selector"
                    },
                    keyword: {
                        pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                        lookbehind: true
                    } // See rest below
                }
            },
            url: {
                // https://drafts.csswg.org/css-values-3/#urls
                pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
                greedy: true,
                inside: {
                    function: /^url/i,
                    punctuation: /^\(|\)$/,
                    string: {
                        pattern: RegExp("^" + string.source + "$"),
                        alias: "url"
                    }
                }
            },
            selector: {
                pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|" + string.source + ")*(?=\\s*\\{)"),
                lookbehind: true
            },
            string: {
                pattern: string,
                greedy: true
            },
            property: {
                pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
                lookbehind: true
            },
            important: /!important\b/i,
            function: {
                pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
                lookbehind: true
            },
            punctuation: /[(){};:,]/
        };
        Prism.languages.css["atrule"].inside.rest = Prism.languages.css;
        var markup = Prism.languages.markup;
        if (markup) {
            markup.tag.addInlined("style", "css");
            markup.tag.addAttribute("style", "css");
        }
    })(Prism1);
}

});

parcelRequire.register("5SC8r", function(module, exports) {
"use strict";
module.exports = $447f93c4197a5ba2$var$clike;
$447f93c4197a5ba2$var$clike.displayName = "clike";
$447f93c4197a5ba2$var$clike.aliases = [];
function $447f93c4197a5ba2$var$clike(Prism) {
    Prism.languages.clike = {
        comment: [
            {
                pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                lookbehind: true,
                greedy: true
            },
            {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        "class-name": {
            pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
            lookbehind: true,
            inside: {
                punctuation: /[.\\]/
            }
        },
        keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
        boolean: /\b(?:false|true)\b/,
        function: /\b\w+(?=\()/,
        number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        punctuation: /[{}[\];(),.:]/
    };
}

});

parcelRequire.register("kPxhR", function(module, exports) {
"use strict";
module.exports = $f2a2642e160268dd$var$javascript;
$f2a2642e160268dd$var$javascript.displayName = "javascript";
$f2a2642e160268dd$var$javascript.aliases = [
    "js"
];
function $f2a2642e160268dd$var$javascript(Prism) {
    Prism.languages.javascript = Prism.languages.extend("clike", {
        "class-name": [
            Prism.languages.clike["class-name"],
            {
                pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
                lookbehind: true
            }
        ],
        keyword: [
            {
                pattern: /((?:^|\})\s*)catch\b/,
                lookbehind: true
            },
            {
                pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
                lookbehind: true
            }
        ],
        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
        function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        number: {
            pattern: RegExp(/(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
            lookbehind: true
        },
        operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism.languages.insertBefore("javascript", "keyword", {
        regex: {
            // eslint-disable-next-line regexp/no-dupe-characters-character-class
            pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
            lookbehind: true,
            greedy: true,
            inside: {
                "regex-source": {
                    pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                    lookbehind: true,
                    alias: "language-regex",
                    inside: Prism.languages.regex
                },
                "regex-delimiter": /^\/|\/$/,
                "regex-flags": /^[a-z]+$/
            }
        },
        // This must be declared before keyword because we use "function" inside the look-forward
        "function-variable": {
            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
            alias: "function"
        },
        parameter: [
            {
                pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            {
                pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
                lookbehind: true,
                inside: Prism.languages.javascript
            }
        ],
        constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism.languages.insertBefore("javascript", "string", {
        hashbang: {
            pattern: /^#!.*/,
            greedy: true,
            alias: "comment"
        },
        "template-string": {
            pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
            greedy: true,
            inside: {
                "template-punctuation": {
                    pattern: /^`|`$/,
                    alias: "string"
                },
                interpolation: {
                    pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                    lookbehind: true,
                    inside: {
                        "interpolation-punctuation": {
                            pattern: /^\$\{|\}$/,
                            alias: "punctuation"
                        },
                        rest: Prism.languages.javascript
                    }
                },
                string: /[\s\S]+/
            }
        },
        "string-property": {
            pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
            lookbehind: true,
            greedy: true,
            alias: "property"
        }
    });
    Prism.languages.insertBefore("javascript", "operator", {
        "literal-property": {
            pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
            lookbehind: true,
            alias: "property"
        }
    });
    if (Prism.languages.markup) {
        Prism.languages.markup.tag.addInlined("script", "javascript") // add attribute support for all DOM events.
        ;
        // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
        Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
    }
    Prism.languages.js = Prism.languages.javascript;
}

});


parcelRequire.register("fi71t", function(module, exports) {
"use strict";
module.exports = $b21dfc072052528c$var$abap;
$b21dfc072052528c$var$abap.displayName = "abap";
$b21dfc072052528c$var$abap.aliases = [];
function $b21dfc072052528c$var$abap(Prism) {
    Prism.languages.abap = {
        comment: /^\*.*/m,
        string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        "string-template": {
            pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
            lookbehind: true,
            alias: "string"
        },
        /* End Of Line comments should not interfere with strings when the
quote character occurs within them. We assume a string being highlighted
inside an EOL comment is more acceptable than the opposite.
*/ "eol-comment": {
            pattern: /(^|\s)".*/m,
            lookbehind: true,
            alias: "comment"
        },
        keyword: {
            pattern: /(\s|\.|^)(?:SCIENTIFIC_WITH_LEADING_ZERO|SCALE_PRESERVING_SCIENTIFIC|RMC_COMMUNICATION_FAILURE|END-ENHANCEMENT-SECTION|MULTIPLY-CORRESPONDING|SUBTRACT-CORRESPONDING|VERIFICATION-MESSAGE|DIVIDE-CORRESPONDING|ENHANCEMENT-SECTION|CURRENCY_CONVERSION|RMC_SYSTEM_FAILURE|START-OF-SELECTION|MOVE-CORRESPONDING|RMC_INVALID_STATUS|CUSTOMER-FUNCTION|END-OF-DEFINITION|ENHANCEMENT-POINT|SYSTEM-EXCEPTIONS|ADD-CORRESPONDING|SCALE_PRESERVING|SELECTION-SCREEN|CURSOR-SELECTION|END-OF-SELECTION|LOAD-OF-PROGRAM|SCROLL-BOUNDARY|SELECTION-TABLE|EXCEPTION-TABLE|IMPLEMENTATIONS|PARAMETER-TABLE|RIGHT-JUSTIFIED|UNIT_CONVERSION|AUTHORITY-CHECK|LIST-PROCESSING|SIGN_AS_POSTFIX|COL_BACKGROUND|IMPLEMENTATION|INTERFACE-POOL|TRANSFORMATION|IDENTIFICATION|ENDENHANCEMENT|LINE-SELECTION|INITIALIZATION|LEFT-JUSTIFIED|SELECT-OPTIONS|SELECTION-SETS|COMMUNICATION|CORRESPONDING|DECIMAL_SHIFT|PRINT-CONTROL|VALUE-REQUEST|CHAIN-REQUEST|FUNCTION-POOL|FIELD-SYMBOLS|FUNCTIONALITY|INVERTED-DATE|SELECTION-SET|CLASS-METHODS|OUTPUT-LENGTH|CLASS-CODING|COL_NEGATIVE|ERRORMESSAGE|FIELD-GROUPS|HELP-REQUEST|NO-EXTENSION|NO-TOPOFPAGE|REDEFINITION|DISPLAY-MODE|ENDINTERFACE|EXIT-COMMAND|FIELD-SYMBOL|NO-SCROLLING|SHORTDUMP-ID|ACCESSPOLICY|CLASS-EVENTS|COL_POSITIVE|DECLARATIONS|ENHANCEMENTS|FILTER-TABLE|SWITCHSTATES|SYNTAX-CHECK|TRANSPORTING|ASYNCHRONOUS|SYNTAX-TRACE|TOKENIZATION|USER-COMMAND|WITH-HEADING|ABAP-SOURCE|BREAK-POINT|CHAIN-INPUT|COMPRESSION|FIXED-POINT|NEW-SECTION|NON-UNICODE|OCCURRENCES|RESPONSIBLE|SYSTEM-CALL|TRACE-TABLE|ABBREVIATED|CHAR-TO-HEX|END-OF-FILE|ENDFUNCTION|ENVIRONMENT|ASSOCIATION|COL_HEADING|EDITOR-CALL|END-OF-PAGE|ENGINEERING|IMPLEMENTED|INTENSIFIED|RADIOBUTTON|SYSTEM-EXIT|TOP-OF-PAGE|TRANSACTION|APPLICATION|CONCATENATE|DESTINATION|ENHANCEMENT|IMMEDIATELY|NO-GROUPING|PRECOMPILED|REPLACEMENT|TITLE-LINES|ACTIVATION|BYTE-ORDER|CLASS-POOL|CONNECTION|CONVERSION|DEFINITION|DEPARTMENT|EXPIRATION|INHERITING|MESSAGE-ID|NO-HEADING|PERFORMING|QUEUE-ONLY|RIGHTSPACE|SCIENTIFIC|STATUSINFO|STRUCTURES|SYNCPOINTS|WITH-TITLE|ATTRIBUTES|BOUNDARIES|CLASS-DATA|COL_NORMAL|DD\/MM\/YYYY|DESCENDING|INTERFACES|LINE-COUNT|MM\/DD\/YYYY|NON-UNIQUE|PRESERVING|SELECTIONS|STATEMENTS|SUBROUTINE|TRUNCATION|TYPE-POOLS|ARITHMETIC|BACKGROUND|ENDPROVIDE|EXCEPTIONS|IDENTIFIER|INDEX-LINE|OBLIGATORY|PARAMETERS|PERCENTAGE|PUSHBUTTON|RESOLUTION|COMPONENTS|DEALLOCATE|DISCONNECT|DUPLICATES|FIRST-LINE|HEAD-LINES|NO-DISPLAY|OCCURRENCE|RESPECTING|RETURNCODE|SUBMATCHES|TRACE-FILE|ASCENDING|BYPASSING|ENDMODULE|EXCEPTION|EXCLUDING|EXPORTING|INCREMENT|MATCHCODE|PARAMETER|PARTIALLY|PREFERRED|REFERENCE|REPLACING|RETURNING|SELECTION|SEPARATED|SPECIFIED|STATEMENT|TIMESTAMP|TYPE-POOL|ACCEPTING|APPENDAGE|ASSIGNING|COL_GROUP|COMPARING|CONSTANTS|DANGEROUS|IMPORTING|INSTANCES|LEFTSPACE|LOG-POINT|QUICKINFO|READ-ONLY|SCROLLING|SQLSCRIPT|STEP-LOOP|TOP-LINES|TRANSLATE|APPENDING|AUTHORITY|CHARACTER|COMPONENT|CONDITION|DIRECTORY|DUPLICATE|MESSAGING|RECEIVING|SUBSCREEN|ACCORDING|COL_TOTAL|END-LINES|ENDMETHOD|ENDSELECT|EXPANDING|EXTENSION|INCLUDING|INFOTYPES|INTERFACE|INTERVALS|LINE-SIZE|PF-STATUS|PROCEDURE|PROTECTED|REQUESTED|RESUMABLE|RIGHTPLUS|SAP-SPOOL|SECONDARY|STRUCTURE|SUBSTRING|TABLEVIEW|NUMOFCHAR|ADJACENT|ANALYSIS|ASSIGNED|BACKWARD|CHANNELS|CHECKBOX|CONTINUE|CRITICAL|DATAINFO|DD\/MM\/YY|DURATION|ENCODING|ENDCLASS|FUNCTION|LEFTPLUS|LINEFEED|MM\/DD\/YY|OVERFLOW|RECEIVED|SKIPPING|SORTABLE|STANDARD|SUBTRACT|SUPPRESS|TABSTRIP|TITLEBAR|TRUNCATE|UNASSIGN|WHENEVER|ANALYZER|COALESCE|COMMENTS|CONDENSE|DECIMALS|DEFERRED|ENDWHILE|EXPLICIT|KEYWORDS|MESSAGES|POSITION|PRIORITY|RECEIVER|RENAMING|TIMEZONE|TRAILING|ALLOCATE|CENTERED|CIRCULAR|CONTROLS|CURRENCY|DELETING|DESCRIBE|DISTANCE|ENDCATCH|EXPONENT|EXTENDED|GENERATE|IGNORING|INCLUDES|INTERNAL|MAJOR-ID|MODIFIER|NEW-LINE|OPTIONAL|PROPERTY|ROLLBACK|STARTING|SUPPLIED|ABSTRACT|CHANGING|CONTEXTS|CREATING|CUSTOMER|DATABASE|DAYLIGHT|DEFINING|DISTINCT|DIVISION|ENABLING|ENDCHAIN|ESCAPING|HARMLESS|IMPLICIT|INACTIVE|LANGUAGE|MINOR-ID|MULTIPLY|NEW-PAGE|NO-TITLE|POS_HIGH|SEPARATE|TEXTPOOL|TRANSFER|SELECTOR|DBMAXLEN|ITERATOR|ARCHIVE|BIT-XOR|BYTE-CO|COLLECT|COMMENT|CURRENT|DEFAULT|DISPLAY|ENDFORM|EXTRACT|LEADING|LISTBOX|LOCATOR|MEMBERS|METHODS|NESTING|POS_LOW|PROCESS|PROVIDE|RAISING|RESERVE|SECONDS|SUMMARY|VISIBLE|BETWEEN|BIT-AND|BYTE-CS|CLEANUP|COMPUTE|CONTROL|CONVERT|DATASET|ENDCASE|FORWARD|HEADERS|HOTSPOT|INCLUDE|INVERSE|KEEPING|NO-ZERO|OBJECTS|OVERLAY|PADDING|PATTERN|PROGRAM|REFRESH|SECTION|SUMMING|TESTING|VERSION|WINDOWS|WITHOUT|BIT-NOT|BYTE-CA|BYTE-NA|CASTING|CONTEXT|COUNTRY|DYNAMIC|ENABLED|ENDLOOP|EXECUTE|FRIENDS|HANDLER|HEADING|INITIAL|\*-INPUT|LOGFILE|MAXIMUM|MINIMUM|NO-GAPS|NO-SIGN|PRAGMAS|PRIMARY|PRIVATE|REDUCED|REPLACE|REQUEST|RESULTS|UNICODE|WARNING|ALIASES|BYTE-CN|BYTE-NS|CALLING|COL_KEY|COLUMNS|CONNECT|ENDEXEC|ENTRIES|EXCLUDE|FILTERS|FURTHER|HELP-ID|LOGICAL|MAPPING|MESSAGE|NAMETAB|OPTIONS|PACKAGE|PERFORM|RECEIVE|STATICS|VARYING|BINDING|CHARLEN|GREATER|XSTRLEN|ACCEPT|APPEND|DETAIL|ELSEIF|ENDING|ENDTRY|FORMAT|FRAMES|GIVING|HASHED|HEADER|IMPORT|INSERT|MARGIN|MODULE|NATIVE|OBJECT|OFFSET|REMOTE|RESUME|SAVING|SIMPLE|SUBMIT|TABBED|TOKENS|UNIQUE|UNPACK|UPDATE|WINDOW|YELLOW|ACTUAL|ASPECT|CENTER|CURSOR|DELETE|DIALOG|DIVIDE|DURING|ERRORS|EVENTS|EXTEND|FILTER|HANDLE|HAVING|IGNORE|LITTLE|MEMORY|NO-GAP|OCCURS|OPTION|PERSON|PLACES|PUBLIC|REDUCE|REPORT|RESULT|SINGLE|SORTED|SWITCH|SYNTAX|TARGET|VALUES|WRITER|ASSERT|BLOCKS|BOUNDS|BUFFER|CHANGE|COLUMN|COMMIT|CONCAT|COPIES|CREATE|DDMMYY|DEFINE|ENDIAN|ESCAPE|EXPAND|KERNEL|LAYOUT|LEGACY|LEVELS|MMDDYY|NUMBER|OUTPUT|RANGES|READER|RETURN|SCREEN|SEARCH|SELECT|SHARED|SOURCE|STABLE|STATIC|SUBKEY|SUFFIX|TABLES|UNWIND|YYMMDD|ASSIGN|BACKUP|BEFORE|BINARY|BIT-OR|BLANKS|CLIENT|CODING|COMMON|DEMAND|DYNPRO|EXCEPT|EXISTS|EXPORT|FIELDS|GLOBAL|GROUPS|LENGTH|LOCALE|MEDIUM|METHOD|MODIFY|NESTED|OTHERS|REJECT|SCROLL|SUPPLY|SYMBOL|ENDFOR|STRLEN|ALIGN|BEGIN|BOUND|ENDAT|ENTRY|EVENT|FINAL|FLUSH|GRANT|INNER|SHORT|USING|WRITE|AFTER|BLACK|BLOCK|CLOCK|COLOR|COUNT|DUMMY|EMPTY|ENDDO|ENDON|GREEN|INDEX|INOUT|LEAVE|LEVEL|LINES|MODIF|ORDER|OUTER|RANGE|RESET|RETRY|RIGHT|SMART|SPLIT|STYLE|TABLE|THROW|UNDER|UNTIL|UPPER|UTF-8|WHERE|ALIAS|BLANK|CLEAR|CLOSE|EXACT|FETCH|FIRST|FOUND|GROUP|LLANG|LOCAL|OTHER|REGEX|SPOOL|TITLE|TYPES|VALID|WHILE|ALPHA|BOXED|CATCH|CHAIN|CHECK|CLASS|COVER|ENDIF|EQUIV|FIELD|FLOOR|FRAME|INPUT|LOWER|MATCH|NODES|PAGES|PRINT|RAISE|ROUND|SHIFT|SPACE|SPOTS|STAMP|STATE|TASKS|TIMES|TRMAC|ULINE|UNION|VALUE|WIDTH|EQUAL|LOG10|TRUNC|BLOB|CASE|CEIL|CLOB|COND|EXIT|FILE|GAPS|HOLD|INCL|INTO|KEEP|KEYS|LAST|LINE|LONG|LPAD|MAIL|MODE|OPEN|PINK|READ|ROWS|TEST|THEN|ZERO|AREA|BACK|BADI|BYTE|CAST|EDIT|EXEC|FAIL|FIND|FKEQ|FONT|FREE|GKEQ|HIDE|INIT|ITNO|LATE|LOOP|MAIN|MARK|MOVE|NEXT|NULL|RISK|ROLE|UNIT|WAIT|ZONE|BASE|CALL|CODE|DATA|DATE|FKGE|GKGE|HIGH|KIND|LEFT|LIST|MASK|MESH|NAME|NODE|PACK|PAGE|POOL|SEND|SIGN|SIZE|SOME|STOP|TASK|TEXT|TIME|USER|VARY|WITH|WORD|BLUE|CONV|COPY|DEEP|ELSE|FORM|FROM|HINT|ICON|JOIN|LIKE|LOAD|ONLY|PART|SCAN|SKIP|SORT|TYPE|UNIX|VIEW|WHEN|WORK|ACOS|ASIN|ATAN|COSH|EACH|FRAC|LESS|RTTI|SINH|SQRT|TANH|AVG|BIT|DIV|ISO|LET|OUT|PAD|SQL|ALL|CI_|CPI|END|LOB|LPI|MAX|MIN|NEW|OLE|RUN|SET|\?TO|YES|ABS|ADD|AND|BIG|FOR|HDB|JOB|LOW|NOT|SAP|TRY|VIA|XML|ANY|GET|IDS|KEY|MOD|OFF|PUT|RAW|RED|REF|SUM|TAB|XSD|CNT|COS|EXP|LOG|SIN|TAN|XOR|AT|CO|CP|DO|GT|ID|IF|NS|OR|BT|CA|CS|GE|NA|NB|EQ|IN|LT|NE|NO|OF|ON|PF|TO|AS|BY|CN|IS|LE|NP|UP|E|I|M|O|Z|C|X)\b/i,
            lookbehind: true
        },
        /* Numbers can be only integers. Decimal or Hex appear only as strings */ number: /\b\d+\b/,
        /* Operators must always be surrounded by whitespace, they cannot be put
adjacent to operands.
*/ operator: {
            pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
            lookbehind: true
        },
        "string-operator": {
            pattern: /(\s)&&?(?=\s)/,
            lookbehind: true,
            /* The official editor highlights */ alias: "keyword"
        },
        "token-operator": [
            {
                /* Special operators used to access structure components, class methods/attributes, etc. */ pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
                lookbehind: true,
                alias: "punctuation"
            },
            {
                /* Special tokens used do delimit string templates */ pattern: /[|{}]/,
                alias: "punctuation"
            }
        ],
        punctuation: /[,.:()]/
    };
}

});

parcelRequire.register("iujtG", function(module, exports) {
"use strict";
module.exports = $d75a233cce237637$var$abnf;
$d75a233cce237637$var$abnf.displayName = "abnf";
$d75a233cce237637$var$abnf.aliases = [];
function $d75a233cce237637$var$abnf(Prism1) {
    (function(Prism) {
        var coreRules = "(?:ALPHA|BIT|CHAR|CR|CRLF|CTL|DIGIT|DQUOTE|HEXDIG|HTAB|LF|LWSP|OCTET|SP|VCHAR|WSP)";
        Prism.languages.abnf = {
            comment: /;.*/,
            string: {
                pattern: /(?:%[is])?"[^"\n\r]*"/,
                greedy: true,
                inside: {
                    punctuation: /^%[is]/
                }
            },
            range: {
                pattern: /%(?:b[01]+-[01]+|d\d+-\d+|x[A-F\d]+-[A-F\d]+)/i,
                alias: "number"
            },
            terminal: {
                pattern: /%(?:b[01]+(?:\.[01]+)*|d\d+(?:\.\d+)*|x[A-F\d]+(?:\.[A-F\d]+)*)/i,
                alias: "number"
            },
            repetition: {
                pattern: /(^|[^\w-])(?:\d*\*\d*|\d+)/,
                lookbehind: true,
                alias: "operator"
            },
            definition: {
                pattern: /(^[ \t]*)(?:[a-z][\w-]*|<[^<>\r\n]*>)(?=\s*=)/m,
                lookbehind: true,
                alias: "keyword",
                inside: {
                    punctuation: /<|>/
                }
            },
            "core-rule": {
                pattern: RegExp("(?:(^|[^<\\w-])" + coreRules + "|<" + coreRules + ">)(?![\\w-])", "i"),
                lookbehind: true,
                alias: [
                    "rule",
                    "constant"
                ],
                inside: {
                    punctuation: /<|>/
                }
            },
            rule: {
                pattern: /(^|[^<\w-])[a-z][\w-]*|<[^<>\r\n]*>/i,
                lookbehind: true,
                inside: {
                    punctuation: /<|>/
                }
            },
            operator: /=\/?|\//,
            punctuation: /[()\[\]]/
        };
    })(Prism1);
}

});

parcelRequire.register("hjZpN", function(module, exports) {
"use strict";
module.exports = $c9c3d9c47889e634$var$actionscript;
$c9c3d9c47889e634$var$actionscript.displayName = "actionscript";
$c9c3d9c47889e634$var$actionscript.aliases = [];
function $c9c3d9c47889e634$var$actionscript(Prism) {
    Prism.languages.actionscript = Prism.languages.extend("javascript", {
        keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
        operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
    });
    Prism.languages.actionscript["class-name"].alias = "function" // doesn't work with AS because AS is too complex
    ;
    delete Prism.languages.actionscript["parameter"];
    delete Prism.languages.actionscript["literal-property"];
    if (Prism.languages.markup) Prism.languages.insertBefore("actionscript", "string", {
        xml: {
            pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
            lookbehind: true,
            inside: Prism.languages.markup
        }
    });
}

});

parcelRequire.register("fgO6L", function(module, exports) {
"use strict";
module.exports = $b1df3813ad86ccbb$var$ada;
$b1df3813ad86ccbb$var$ada.displayName = "ada";
$b1df3813ad86ccbb$var$ada.aliases = [];
function $b1df3813ad86ccbb$var$ada(Prism) {
    Prism.languages.ada = {
        comment: /--.*/,
        string: /"(?:""|[^"\r\f\n])*"/,
        number: [
            {
                pattern: /\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i
            },
            {
                pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i
            }
        ],
        "attr-name": /\b'\w+/,
        keyword: /\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|new|not|null|of|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|return|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
        boolean: /\b(?:false|true)\b/i,
        operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
        punctuation: /\.\.?|[,;():]/,
        char: /'.'/,
        variable: /\b[a-z](?:\w)*\b/i
    };
}

});

parcelRequire.register("exifC", function(module, exports) {
"use strict";
module.exports = $a9524e072c3ca7ac$var$agda;
$a9524e072c3ca7ac$var$agda.displayName = "agda";
$a9524e072c3ca7ac$var$agda.aliases = [];
function $a9524e072c3ca7ac$var$agda(Prism1) {
    (function(Prism) {
        Prism.languages.agda = {
            comment: /\{-[\s\S]*?(?:-\}|$)|--.*/,
            string: {
                pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
                greedy: true
            },
            punctuation: /[(){}⦃⦄.;@]/,
            "class-name": {
                pattern: /((?:data|record) +)\S+/,
                lookbehind: true
            },
            function: {
                pattern: /(^[ \t]*)(?!\s)[^:\r\n]+(?=:)/m,
                lookbehind: true
            },
            operator: {
                pattern: /(^\s*|\s)(?:[=|:∀→λ\\?_]|->)(?=\s)/,
                lookbehind: true
            },
            keyword: /\b(?:Set|abstract|constructor|data|eta-equality|field|forall|hiding|import|in|inductive|infix|infixl|infixr|instance|let|macro|module|mutual|no-eta-equality|open|overlap|pattern|postulate|primitive|private|public|quote|quoteContext|quoteGoal|quoteTerm|record|renaming|rewrite|syntax|tactic|unquote|unquoteDecl|unquoteDef|using|variable|where|with)\b/
        };
    })(Prism1);
}

});

parcelRequire.register("ffwdt", function(module, exports) {
"use strict";
module.exports = $b1a13f354da7e368$var$al;
$b1a13f354da7e368$var$al.displayName = "al";
$b1a13f354da7e368$var$al.aliases = [];
function $b1a13f354da7e368$var$al(Prism) {
    // based on https://github.com/microsoft/AL/blob/master/grammar/alsyntax.tmlanguage
    Prism.languages.al = {
        comment: /\/\/.*|\/\*[\s\S]*?\*\//,
        string: {
            pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
            greedy: true
        },
        function: {
            pattern: /(\b(?:event|procedure|trigger)\s+|(?:^|[^.])\.\s*)[a-z_]\w*(?=\s*\()/i,
            lookbehind: true
        },
        keyword: [
            // keywords
            /\b(?:array|asserterror|begin|break|case|do|downto|else|end|event|exit|for|foreach|function|if|implements|in|indataset|interface|internal|local|of|procedure|program|protected|repeat|runonclient|securityfiltering|suppressdispose|temporary|then|to|trigger|until|var|while|with|withevents)\b/i,
            /\b(?:action|actions|addafter|addbefore|addfirst|addlast|area|assembly|chartpart|codeunit|column|controladdin|cuegroup|customizes|dataitem|dataset|dotnet|elements|enum|enumextension|extends|field|fieldattribute|fieldelement|fieldgroup|fieldgroups|fields|filter|fixed|grid|group|key|keys|label|labels|layout|modify|moveafter|movebefore|movefirst|movelast|page|pagecustomization|pageextension|part|profile|query|repeater|report|requestpage|schema|separator|systempart|table|tableelement|tableextension|textattribute|textelement|type|usercontrol|value|xmlport)\b/i
        ],
        number: /\b(?:0x[\da-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)(?:F|LL?|U(?:LL?)?)?\b/i,
        boolean: /\b(?:false|true)\b/i,
        variable: /\b(?:Curr(?:FieldNo|Page|Report)|x?Rec|RequestOptionsPage)\b/,
        "class-name": /\b(?:automation|biginteger|bigtext|blob|boolean|byte|char|clienttype|code|completiontriggererrorlevel|connectiontype|database|dataclassification|datascope|date|dateformula|datetime|decimal|defaultlayout|dialog|dictionary|dotnetassembly|dotnettypedeclaration|duration|errorinfo|errortype|executioncontext|executionmode|fieldclass|fieldref|fieldtype|file|filterpagebuilder|guid|httpclient|httpcontent|httpheaders|httprequestmessage|httpresponsemessage|instream|integer|joker|jsonarray|jsonobject|jsontoken|jsonvalue|keyref|list|moduledependencyinfo|moduleinfo|none|notification|notificationscope|objecttype|option|outstream|pageresult|record|recordid|recordref|reportformat|securityfilter|sessionsettings|tableconnectiontype|tablefilter|testaction|testfield|testfilterfield|testpage|testpermissions|testrequestpage|text|textbuilder|textconst|textencoding|time|transactionmodel|transactiontype|variant|verbosity|version|view|views|webserviceactioncontext|webserviceactionresultcode|xmlattribute|xmlattributecollection|xmlcdata|xmlcomment|xmldeclaration|xmldocument|xmldocumenttype|xmlelement|xmlnamespacemanager|xmlnametable|xmlnode|xmlnodelist|xmlprocessinginstruction|xmlreadoptions|xmltext|xmlwriteoptions)\b/i,
        operator: /\.\.|:[=:]|[-+*/]=?|<>|[<>]=?|=|\b(?:and|div|mod|not|or|xor)\b/i,
        punctuation: /[()\[\]{}:.;,]/
    };
}

});

parcelRequire.register("bI0aE", function(module, exports) {
"use strict";
module.exports = $8863efab76230dc5$var$antlr4;
$8863efab76230dc5$var$antlr4.displayName = "antlr4";
$8863efab76230dc5$var$antlr4.aliases = [
    "g4"
];
function $8863efab76230dc5$var$antlr4(Prism) {
    Prism.languages.antlr4 = {
        comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
        string: {
            pattern: /'(?:\\.|[^\\'\r\n])*'/,
            greedy: true
        },
        "character-class": {
            pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
            greedy: true,
            alias: "regex",
            inside: {
                range: {
                    pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
                    lookbehind: true,
                    alias: "punctuation"
                },
                escape: /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
                punctuation: /[\[\]]/
            }
        },
        action: {
            pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
            greedy: true,
            inside: {
                content: {
                    // this might be C, C++, Python, Java, C#, or any other language ANTLR4 compiles to
                    pattern: /(\{)[\s\S]+(?=\})/,
                    lookbehind: true
                },
                punctuation: /[{}]/
            }
        },
        command: {
            pattern: /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
            lookbehind: true,
            inside: {
                function: /\b\w+(?=\s*(?:[,(]|$))/,
                punctuation: /[,()]/
            }
        },
        annotation: {
            pattern: /@\w+(?:::\w+)*/,
            alias: "keyword"
        },
        label: {
            pattern: /#[ \t]*\w+/,
            alias: "punctuation"
        },
        keyword: /\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
        definition: [
            {
                pattern: /\b[a-z]\w*(?=\s*:)/,
                alias: [
                    "rule",
                    "class-name"
                ]
            },
            {
                pattern: /\b[A-Z]\w*(?=\s*:)/,
                alias: [
                    "token",
                    "constant"
                ]
            }
        ],
        constant: /\b[A-Z][A-Z_]*\b/,
        operator: /\.\.|->|[|~]|[*+?]\??/,
        punctuation: /[;:()=]/
    };
    Prism.languages.g4 = Prism.languages.antlr4;
}

});

parcelRequire.register("3nqcw", function(module, exports) {
"use strict";
module.exports = $2757d811a40db3ca$var$apacheconf;
$2757d811a40db3ca$var$apacheconf.displayName = "apacheconf";
$2757d811a40db3ca$var$apacheconf.aliases = [];
function $2757d811a40db3ca$var$apacheconf(Prism) {
    Prism.languages.apacheconf = {
        comment: /#.*/,
        "directive-inline": {
            pattern: /(^[\t ]*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|Type|UserFile|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|Limit(?:InternalRecursion|Request(?:Body|Fields|FieldSize|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|SRPUnknownUserSeed|SRPVerifierFile|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UserName|UseStapling|VerifyClient|VerifyDepth)|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
            lookbehind: true,
            alias: "property"
        },
        "directive-block": {
            pattern: /<\/?\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\b.*>/i,
            inside: {
                "directive-block": {
                    pattern: /^<\/?\w+/,
                    inside: {
                        punctuation: /^<\/?/
                    },
                    alias: "tag"
                },
                "directive-block-parameter": {
                    pattern: /.*[^>]/,
                    inside: {
                        punctuation: /:/,
                        string: {
                            pattern: /("|').*\1/,
                            inside: {
                                variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
                            }
                        }
                    },
                    alias: "attr-value"
                },
                punctuation: />/
            },
            alias: "tag"
        },
        "directive-flags": {
            pattern: /\[(?:[\w=],?)+\]/,
            alias: "keyword"
        },
        string: {
            pattern: /("|').*\1/,
            inside: {
                variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
            }
        },
        variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
        regex: /\^?.*\$|\^.*\$?/
    };
}

});

parcelRequire.register("iJBrn", function(module, exports) {
"use strict";

var $aeREZ = parcelRequire("aeREZ");
module.exports = $da3978e5eed57960$var$apex;
$da3978e5eed57960$var$apex.displayName = "apex";
$da3978e5eed57960$var$apex.aliases = [];
function $da3978e5eed57960$var$apex(Prism1) {
    Prism1.register($aeREZ);
    (function(Prism) {
        var keywords = /\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i;
        var className = /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(/<keyword>/g, function() {
            return keywords.source;
        });
        /** @param {string} pattern */ function insertClassName(pattern) {
            return RegExp(pattern.replace(/<CLASS-NAME>/g, function() {
                return className;
            }), "i");
        }
        var classNameInside = {
            keyword: keywords,
            punctuation: /[()\[\]{};,:.<>]/
        };
        Prism.languages.apex = {
            comment: Prism.languages.clike.comment,
            string: Prism.languages.clike.string,
            sql: {
                pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
                lookbehind: true,
                greedy: true,
                alias: "language-sql",
                inside: Prism.languages.sql
            },
            annotation: {
                pattern: /@\w+\b/,
                alias: "punctuation"
            },
            "class-name": [
                {
                    pattern: insertClassName(/(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/.source),
                    lookbehind: true,
                    inside: classNameInside
                },
                {
                    // cast
                    pattern: insertClassName(/(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source),
                    lookbehind: true,
                    inside: classNameInside
                },
                {
                    // variable/parameter declaration and return types
                    pattern: insertClassName(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source),
                    inside: classNameInside
                }
            ],
            trigger: {
                pattern: /(\btrigger\s+)\w+\b/i,
                lookbehind: true,
                alias: "class-name"
            },
            keyword: keywords,
            function: /\b[a-z_]\w*(?=\s*\()/i,
            boolean: /\b(?:false|true)\b/i,
            number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
            operator: /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
            punctuation: /[()\[\]{};,.]/
        };
    })(Prism1);
}

});
parcelRequire.register("aeREZ", function(module, exports) {
"use strict";
module.exports = $7744d5fc6a37d916$var$sql;
$7744d5fc6a37d916$var$sql.displayName = "sql";
$7744d5fc6a37d916$var$sql.aliases = [];
function $7744d5fc6a37d916$var$sql(Prism) {
    Prism.languages.sql = {
        comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
            lookbehind: true
        },
        variable: [
            {
                pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
                greedy: true
            },
            /@[\w.$]+/
        ],
        string: {
            pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
            greedy: true,
            lookbehind: true
        },
        identifier: {
            pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
            greedy: true,
            lookbehind: true,
            inside: {
                punctuation: /^`|`$/
            }
        },
        function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
        // Should we highlight user defined functions too?
        keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
        boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
        number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
        operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
        punctuation: /[;[\]()`,.]/
    };
}

});


parcelRequire.register("wyHrg", function(module, exports) {
"use strict";
module.exports = $061de7e56d0a4d6b$var$apl;
$061de7e56d0a4d6b$var$apl.displayName = "apl";
$061de7e56d0a4d6b$var$apl.aliases = [];
function $061de7e56d0a4d6b$var$apl(Prism) {
    Prism.languages.apl = {
        comment: /(?:⍝|#[! ]).*$/m,
        string: {
            pattern: /'(?:[^'\r\n]|'')*'/,
            greedy: true
        },
        number: /¯?(?:\d*\.?\b\d+(?:e[+¯]?\d+)?|¯|∞)(?:j¯?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+¯]?\d+)?|¯|∞))?/i,
        statement: /:[A-Z][a-z][A-Za-z]*\b/,
        "system-function": {
            pattern: /⎕[A-Z]+/i,
            alias: "function"
        },
        constant: /[⍬⌾#⎕⍞]/,
        function: /[-+×÷⌈⌊∣|⍳⍸?*⍟○!⌹<≤=>≥≠≡≢∊⍷∪∩~∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⊆⊇⌷⍋⍒⊤⊥⍕⍎⊣⊢⍁⍂≈⍯↗¤→]/,
        "monadic-operator": {
            pattern: /[\\\/⌿⍀¨⍨⌶&∥]/,
            alias: "operator"
        },
        "dyadic-operator": {
            pattern: /[.⍣⍠⍤∘⌸@⌺⍥]/,
            alias: "operator"
        },
        assignment: {
            pattern: /←/,
            alias: "keyword"
        },
        punctuation: /[\[;\]()◇⋄]/,
        dfn: {
            pattern: /[{}⍺⍵⍶⍹∇⍫:]/,
            alias: "builtin"
        }
    };
}

});

parcelRequire.register("3j0kU", function(module, exports) {
"use strict";
module.exports = $268368391f9b6b01$var$applescript;
$268368391f9b6b01$var$applescript.displayName = "applescript";
$268368391f9b6b01$var$applescript.aliases = [];
function $268368391f9b6b01$var$applescript(Prism) {
    Prism.languages.applescript = {
        comment: [
            // Allow one level of nesting
            /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
            /--.+/,
            /#.+/
        ],
        string: /"(?:\\.|[^"\\\r\n])*"/,
        number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?\b/i,
        operator: [
            /[&=≠≤≥*+\-\/÷^]|[<>]=?/,
            /\b(?:(?:begin|end|start)s? with|(?:contains?|(?:does not|doesn't) contain)|(?:is|isn't|is not) (?:contained by|in)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:comes|(?:does not|doesn't) come) (?:after|before)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equal to|equals|is not|isn't)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|as|div|mod|not|or))\b/
        ],
        keyword: /\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
        "class-name": /\b(?:POSIX file|RGB color|alias|application|boolean|centimeters|centimetres|class|constant|cubic centimeters|cubic centimetres|cubic feet|cubic inches|cubic meters|cubic metres|cubic yards|date|degrees Celsius|degrees Fahrenheit|degrees Kelvin|feet|file|gallons|grams|inches|integer|kilograms|kilometers|kilometres|list|liters|litres|meters|metres|miles|number|ounces|pounds|quarts|real|record|reference|script|square feet|square kilometers|square kilometres|square meters|square metres|square miles|square yards|text|yards)\b/,
        punctuation: /[{}():,¬«»《》]/
    };
}

});

parcelRequire.register("do0hG", function(module, exports) {
"use strict";
module.exports = $9bedbcb189c2177f$var$aql;
$9bedbcb189c2177f$var$aql.displayName = "aql";
$9bedbcb189c2177f$var$aql.aliases = [];
function $9bedbcb189c2177f$var$aql(Prism) {
    Prism.languages.aql = {
        comment: /\/\/.*|\/\*[\s\S]*?\*\//,
        property: {
            pattern: /([{,]\s*)(?:(?!\d)\w+|(["'´`])(?:(?!\2)[^\\\r\n]|\\.)*\2)(?=\s*:)/,
            lookbehind: true,
            greedy: true
        },
        string: {
            pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
            greedy: true
        },
        identifier: {
            pattern: /([´`])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
            greedy: true
        },
        variable: /@@?\w+/,
        keyword: [
            {
                pattern: /(\bWITH\s+)COUNT(?=\s+INTO\b)/i,
                lookbehind: true
            },
            /\b(?:AGGREGATE|ALL|AND|ANY|ASC|COLLECT|DESC|DISTINCT|FILTER|FOR|GRAPH|IN|INBOUND|INSERT|INTO|K_PATHS|K_SHORTEST_PATHS|LET|LIKE|LIMIT|NONE|NOT|NULL|OR|OUTBOUND|REMOVE|REPLACE|RETURN|SHORTEST_PATH|SORT|UPDATE|UPSERT|WINDOW|WITH)\b/i,
            {
                pattern: /(^|[^\w.[])(?:KEEP|PRUNE|SEARCH|TO)\b/i,
                lookbehind: true
            },
            {
                pattern: /(^|[^\w.[])(?:CURRENT|NEW|OLD)\b/,
                lookbehind: true
            },
            {
                pattern: /\bOPTIONS(?=\s*\{)/i
            }
        ],
        function: /\b(?!\d)\w+(?=\s*\()/,
        boolean: /\b(?:false|true)\b/i,
        range: {
            pattern: /\.\./,
            alias: "operator"
        },
        number: [
            /\b0b[01]+/i,
            /\b0x[0-9a-f]+/i,
            /(?:\B\.\d+|\b(?:0|[1-9]\d*)(?:\.\d+)?)(?:e[+-]?\d+)?/i
        ],
        operator: /\*{2,}|[=!]~|[!=<>]=?|&&|\|\||[-+*/%]/,
        punctuation: /::|[?.:,;()[\]{}]/
    };
}

});

parcelRequire.register("8DXgx", function(module, exports) {
"use strict";

var $eLG4G = parcelRequire("eLG4G");
module.exports = $64aff02a555ff45f$var$arduino;
$64aff02a555ff45f$var$arduino.displayName = "arduino";
$64aff02a555ff45f$var$arduino.aliases = [
    "ino"
];
function $64aff02a555ff45f$var$arduino(Prism) {
    Prism.register($eLG4G);
    Prism.languages.arduino = Prism.languages.extend("cpp", {
        keyword: /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
        constant: /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
        builtin: /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
    });
    Prism.languages.ino = Prism.languages.arduino;
}

});
parcelRequire.register("eLG4G", function(module, exports) {
"use strict";

var $bEqqd = parcelRequire("bEqqd");
module.exports = $ac0617948918e4b0$var$cpp;
$ac0617948918e4b0$var$cpp.displayName = "cpp";
$ac0617948918e4b0$var$cpp.aliases = [];
function $ac0617948918e4b0$var$cpp(Prism1) {
    Prism1.register($bEqqd);
    (function(Prism) {
        var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
        var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
            return keyword.source;
        });
        Prism.languages.cpp = Prism.languages.extend("c", {
            "class-name": [
                {
                    pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
                        return keyword.source;
                    })),
                    lookbehind: true
                },
                //   void foo::bar() const {}
                // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
                // it starts with an uppercase letter. This approximation should give decent results.
                /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
                //   Foo::~Foo() {}
                /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
                // parameters, so it can't be a namespace (until C++ adds generic namespaces).
                /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
            ],
            keyword: keyword,
            number: {
                pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
                greedy: true
            },
            operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
            boolean: /\b(?:false|true)\b/
        });
        Prism.languages.insertBefore("cpp", "string", {
            module: {
                // https://en.cppreference.com/w/cpp/language/modules
                pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
                    return modName;
                }) + ")"),
                lookbehind: true,
                greedy: true,
                inside: {
                    string: /^[<"][\s\S]+/,
                    operator: /:/,
                    punctuation: /\./
                }
            },
            "raw-string": {
                pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
                alias: "string",
                greedy: true
            }
        });
        Prism.languages.insertBefore("cpp", "keyword", {
            "generic-function": {
                pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
                inside: {
                    function: /^\w+/,
                    generic: {
                        pattern: /<[\s\S]+/,
                        alias: "class-name",
                        inside: Prism.languages.cpp
                    }
                }
            }
        });
        Prism.languages.insertBefore("cpp", "operator", {
            "double-colon": {
                pattern: /::/,
                alias: "punctuation"
            }
        });
        Prism.languages.insertBefore("cpp", "class-name", {
            // the base clause is an optional list of parent classes
            // https://en.cppreference.com/w/cpp/language/class
            "base-clause": {
                pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
                lookbehind: true,
                greedy: true,
                inside: Prism.languages.extend("cpp", {})
            }
        });
        Prism.languages.insertBefore("inside", "double-colon", {
            // All untokenized words that are not namespaces should be class names
            "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
        }, Prism.languages.cpp["base-clause"]);
    })(Prism1);
}

});
parcelRequire.register("bEqqd", function(module, exports) {
"use strict";
module.exports = $87b7ecf9af299eef$var$c;
$87b7ecf9af299eef$var$c.displayName = "c";
$87b7ecf9af299eef$var$c.aliases = [];
function $87b7ecf9af299eef$var$c(Prism) {
    Prism.languages.c = Prism.languages.extend("clike", {
        comment: {
            pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
            greedy: true
        },
        string: {
            // https://en.cppreference.com/w/c/language/string_literal
            pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
            greedy: true
        },
        "class-name": {
            pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
            lookbehind: true
        },
        keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
        operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
    });
    Prism.languages.insertBefore("c", "string", {
        char: {
            // https://en.cppreference.com/w/c/language/character_constant
            pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
            greedy: true
        }
    });
    Prism.languages.insertBefore("c", "string", {
        macro: {
            // allow for multiline macro definitions
            // spaces after the # character compile fine with gcc
            pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
            lookbehind: true,
            greedy: true,
            alias: "property",
            inside: {
                string: [
                    {
                        // highlight the path of the include statement as a string
                        pattern: /^(#\s*include\s*)<[^>]+>/,
                        lookbehind: true
                    },
                    Prism.languages.c["string"]
                ],
                char: Prism.languages.c["char"],
                comment: Prism.languages.c["comment"],
                "macro-name": [
                    {
                        pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
                        lookbehind: true
                    },
                    {
                        pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
                        lookbehind: true,
                        alias: "function"
                    }
                ],
                // highlight macro directives as keywords
                directive: {
                    pattern: /^(#\s*)[a-z]+/,
                    lookbehind: true,
                    alias: "keyword"
                },
                "directive-hash": /^#/,
                punctuation: /##|\\(?=[\r\n])/,
                expression: {
                    pattern: /\S[\s\S]*/,
                    inside: Prism.languages.c
                }
            }
        }
    });
    Prism.languages.insertBefore("c", "function", {
        // highlight predefined macros as constants
        constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
    });
    delete Prism.languages.c["boolean"];
}

});



parcelRequire.register("4eI86", function(module, exports) {
"use strict";
module.exports = $315ab37b428ef702$var$arff;
$315ab37b428ef702$var$arff.displayName = "arff";
$315ab37b428ef702$var$arff.aliases = [];
function $315ab37b428ef702$var$arff(Prism) {
    Prism.languages.arff = {
        comment: /%.*/,
        string: {
            pattern: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        keyword: /@(?:attribute|data|end|relation)\b/i,
        number: /\b\d+(?:\.\d+)?\b/,
        punctuation: /[{},]/
    };
}

});

parcelRequire.register("k3iwd", function(module, exports) {
"use strict";
module.exports = $e99273e08366f470$var$asciidoc;
$e99273e08366f470$var$asciidoc.displayName = "asciidoc";
$e99273e08366f470$var$asciidoc.aliases = [
    "adoc"
];
function $e99273e08366f470$var$asciidoc(Prism1) {
    (function(Prism) {
        var attributes = {
            pattern: /(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\[\]\\]|\\.)*\]|[^\[\]\\"'$`]|\\.)*\]/m,
            lookbehind: true,
            inside: {
                quoted: {
                    pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
                    inside: {
                        punctuation: /^[$`]|[$`]$/
                    }
                },
                interpreted: {
                    pattern: /'(?:[^'\\]|\\.)*'/,
                    inside: {
                        punctuation: /^'|'$/ // See rest below
                    }
                },
                string: /"(?:[^"\\]|\\.)*"/,
                variable: /\w+(?==)/,
                punctuation: /^\[|\]$|,/,
                operator: /=/,
                // The negative look-ahead prevents blank matches
                "attr-value": /(?!^\s+$).+/
            }
        };
        var asciidoc1 = Prism.languages.asciidoc = {
            "comment-block": {
                pattern: /^(\/{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1/m,
                alias: "comment"
            },
            table: {
                pattern: /^\|={3,}(?:(?:\r?\n|\r(?!\n)).*)*?(?:\r?\n|\r)\|={3,}$/m,
                inside: {
                    specifiers: {
                        pattern: /(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*](?:[<^>](?:\.[<^>])?|\.[<^>])?|[<^>](?:\.[<^>])?|\.[<^>])[a-z]*|[a-z]+)(?=\|)/,
                        alias: "attr-value"
                    },
                    punctuation: {
                        pattern: /(^|[^\\])[|!]=*/,
                        lookbehind: true
                    } // See rest below
                }
            },
            "passthrough-block": {
                pattern: /^(\+{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
                inside: {
                    punctuation: /^\++|\++$/ // See rest below
                }
            },
            // Literal blocks and listing blocks
            "literal-block": {
                pattern: /^(-{4,}|\.{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
                inside: {
                    punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/ // See rest below
                }
            },
            // Sidebar blocks, quote blocks, example blocks and open blocks
            "other-block": {
                pattern: /^(--|\*{4,}|_{4,}|={4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
                inside: {
                    punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/ // See rest below
                }
            },
            // list-punctuation and list-label must appear before indented-block
            "list-punctuation": {
                pattern: /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
                lookbehind: true,
                alias: "punctuation"
            },
            "list-label": {
                pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
                lookbehind: true,
                alias: "symbol"
            },
            "indented-block": {
                pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
                lookbehind: true
            },
            comment: /^\/\/.*/m,
            title: {
                pattern: /^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} .+|^\.(?![\s.]).*/m,
                alias: "important",
                inside: {
                    punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/ // See rest below
                }
            },
            "attribute-entry": {
                pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
                alias: "tag"
            },
            attributes: attributes,
            hr: {
                pattern: /^'{3,}$/m,
                alias: "punctuation"
            },
            "page-break": {
                pattern: /^<{3,}$/m,
                alias: "punctuation"
            },
            admonition: {
                pattern: /^(?:CAUTION|IMPORTANT|NOTE|TIP|WARNING):/m,
                alias: "keyword"
            },
            callout: [
                {
                    pattern: /(^[ \t]*)<?\d*>/m,
                    lookbehind: true,
                    alias: "symbol"
                },
                {
                    pattern: /<\d+>/,
                    alias: "symbol"
                }
            ],
            macro: {
                pattern: /\b[a-z\d][a-z\d-]*::?(?:[^\s\[\]]*\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
                inside: {
                    function: /^[a-z\d-]+(?=:)/,
                    punctuation: /^::?/,
                    attributes: {
                        pattern: /(?:\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
                        inside: attributes.inside
                    }
                }
            },
            inline: {
                /*
The initial look-behind prevents the highlighting of escaped quoted text.
Quoted text can be multi-line but cannot span an empty line.
All quoted text can have attributes before [foobar, 'foobar', baz="bar"].
First, we handle the constrained quotes.
Those must be bounded by non-word chars and cannot have spaces between the delimiter and the first char.
They are, in order: _emphasis_, ``double quotes'', `single quotes', `monospace`, 'emphasis', *strong*, +monospace+ and #unquoted#
Then we handle the unconstrained quotes.
Those do not have the restrictions of the constrained quotes.
They are, in order: __emphasis__, **strong**, ++monospace++, +++passthrough+++, ##unquoted##, $$passthrough$$, ~subscript~, ^superscript^, {attribute-reference}, [[anchor]], [[[bibliography anchor]]], <<xref>>, (((indexes))) and ((indexes))
*/ pattern: /(^|[^\\])(?:(?:\B\[(?:[^\]\\"']|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?:[^`'\s]|\s+\S)+['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"']|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
                lookbehind: true,
                inside: {
                    attributes: attributes,
                    url: {
                        pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
                        inside: {
                            punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/
                        }
                    },
                    "attribute-ref": {
                        pattern: /^\{.+\}$/,
                        inside: {
                            variable: {
                                pattern: /(^\{)[a-z\d,+_-]+/,
                                lookbehind: true
                            },
                            operator: /^[=?!#%@$]|!(?=[:}])/,
                            punctuation: /^\{|\}$|::?/
                        }
                    },
                    italic: {
                        pattern: /^(['_])[\s\S]+\1$/,
                        inside: {
                            punctuation: /^(?:''?|__?)|(?:''?|__?)$/
                        }
                    },
                    bold: {
                        pattern: /^\*[\s\S]+\*$/,
                        inside: {
                            punctuation: /^\*\*?|\*\*?$/
                        }
                    },
                    punctuation: /^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
                }
            },
            replacement: {
                pattern: /\((?:C|R|TM)\)/,
                alias: "builtin"
            },
            entity: /&#?[\da-z]{1,8};/i,
            "line-continuation": {
                pattern: /(^| )\+$/m,
                lookbehind: true,
                alias: "punctuation"
            }
        } // Allow some nesting. There is no recursion though, so cloning should not be needed.
        ;
        function copyFromAsciiDoc(keys) {
            keys = keys.split(" ");
            var o = {};
            for(var i = 0, l = keys.length; i < l; i++)o[keys[i]] = asciidoc1[keys[i]];
            return o;
        }
        attributes.inside["interpreted"].inside.rest = copyFromAsciiDoc("macro inline replacement entity");
        asciidoc1["passthrough-block"].inside.rest = copyFromAsciiDoc("macro");
        asciidoc1["literal-block"].inside.rest = copyFromAsciiDoc("callout");
        asciidoc1["table"].inside.rest = copyFromAsciiDoc("comment-block passthrough-block literal-block other-block list-punctuation indented-block comment title attribute-entry attributes hr page-break admonition list-label callout macro inline replacement entity line-continuation");
        asciidoc1["other-block"].inside.rest = copyFromAsciiDoc("table list-punctuation indented-block comment attribute-entry attributes hr page-break admonition list-label macro inline replacement entity line-continuation");
        asciidoc1["title"].inside.rest = copyFromAsciiDoc("macro inline replacement entity") // Plugin to make entity title show the real entity, idea by Roman Komarov
        ;
        Prism.hooks.add("wrap", function(env) {
            if (env.type === "entity") env.attributes["title"] = env.content.value.replace(/&amp;/, "&");
        });
        Prism.languages.adoc = Prism.languages.asciidoc;
    })(Prism1);
}

});

parcelRequire.register("dgJEm", function(module, exports) {
"use strict";
module.exports = $9a902e1dd8545038$var$asm6502;
$9a902e1dd8545038$var$asm6502.displayName = "asm6502";
$9a902e1dd8545038$var$asm6502.aliases = [];
function $9a902e1dd8545038$var$asm6502(Prism) {
    Prism.languages.asm6502 = {
        comment: /;.*/,
        directive: {
            pattern: /\.\w+(?= )/,
            alias: "property"
        },
        string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        "op-code": {
            pattern: /\b(?:ADC|AND|ASL|BCC|BCS|BEQ|BIT|BMI|BNE|BPL|BRK|BVC|BVS|CLC|CLD|CLI|CLV|CMP|CPX|CPY|DEC|DEX|DEY|EOR|INC|INX|INY|JMP|JSR|LDA|LDX|LDY|LSR|NOP|ORA|PHA|PHP|PLA|PLP|ROL|ROR|RTI|RTS|SBC|SEC|SED|SEI|STA|STX|STY|TAX|TAY|TSX|TXA|TXS|TYA|adc|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|brk|bvc|bvs|clc|cld|cli|clv|cmp|cpx|cpy|dec|dex|dey|eor|inc|inx|iny|jmp|jsr|lda|ldx|ldy|lsr|nop|ora|pha|php|pla|plp|rol|ror|rti|rts|sbc|sec|sed|sei|sta|stx|sty|tax|tay|tsx|txa|txs|tya)\b/,
            alias: "keyword"
        },
        "hex-number": {
            pattern: /#?\$[\da-f]{1,4}\b/i,
            alias: "number"
        },
        "binary-number": {
            pattern: /#?%[01]+\b/,
            alias: "number"
        },
        "decimal-number": {
            pattern: /#?\b\d+\b/,
            alias: "number"
        },
        register: {
            pattern: /\b[xya]\b/i,
            alias: "variable"
        },
        punctuation: /[(),:]/
    };
}

});

parcelRequire.register("79CB4", function(module, exports) {
"use strict";
module.exports = $5357503c3903c511$var$asmatmel;
$5357503c3903c511$var$asmatmel.displayName = "asmatmel";
$5357503c3903c511$var$asmatmel.aliases = [];
function $5357503c3903c511$var$asmatmel(Prism) {
    Prism.languages.asmatmel = {
        comment: {
            pattern: /;.*/,
            greedy: true
        },
        string: {
            pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        constant: /\b(?:PORT[A-Z]|DDR[A-Z]|(?:DD|P)[A-Z](?:\d|[0-2]\d|3[01]))\b/,
        directive: {
            pattern: /\.\w+(?= )/,
            alias: "property"
        },
        "r-register": {
            pattern: /\br(?:\d|[12]\d|3[01])\b/,
            alias: "variable"
        },
        "op-code": {
            pattern: /\b(?:ADC|ADD|ADIW|AND|ANDI|ASR|BCLR|BLD|BRBC|BRBS|BRCC|BRCS|BREAK|BREQ|BRGE|BRHC|BRHS|BRID|BRIE|BRLO|BRLT|BRMI|BRNE|BRPL|BRSH|BRTC|BRTS|BRVC|BRVS|BSET|BST|CALL|CBI|CBR|CLC|CLH|CLI|CLN|CLR|CLS|CLT|CLV|CLZ|COM|CP|CPC|CPI|CPSE|DEC|DES|EICALL|EIJMP|ELPM|EOR|FMUL|FMULS|FMULSU|ICALL|IJMP|IN|INC|JMP|LAC|LAS|LAT|LD|LD[A-Za-z0-9]|LPM|LSL|LSR|MOV|MOVW|MUL|MULS|MULSU|NEG|NOP|OR|ORI|OUT|POP|PUSH|RCALL|RET|RETI|RJMP|ROL|ROR|SBC|SBCI|SBI|SBIC|SBIS|SBIW|SBR|SBRC|SBRS|SEC|SEH|SEI|SEN|SER|SES|SET|SEV|SEZ|SLEEP|SPM|ST|ST[A-Z0-9]|SUB|SUBI|SWAP|TST|WDR|XCH|adc|add|adiw|and|andi|asr|bclr|bld|brbc|brbs|brcc|brcs|break|breq|brge|brhc|brhs|brid|brie|brlo|brlt|brmi|brne|brpl|brsh|brtc|brts|brvc|brvs|bset|bst|call|cbi|cbr|clc|clh|cli|cln|clr|cls|clt|clv|clz|com|cp|cpc|cpi|cpse|dec|des|eicall|eijmp|elpm|eor|fmul|fmuls|fmulsu|icall|ijmp|in|inc|jmp|lac|las|lat|ld|ld[a-z0-9]|lpm|lsl|lsr|mov|movw|mul|muls|mulsu|neg|nop|or|ori|out|pop|push|rcall|ret|reti|rjmp|rol|ror|sbc|sbci|sbi|sbic|sbis|sbiw|sbr|sbrc|sbrs|sec|seh|sei|sen|ser|ses|set|sev|sez|sleep|spm|st|st[a-zA-Z0-9]|sub|subi|swap|tst|wdr|xch)\b/,
            alias: "keyword"
        },
        "hex-number": {
            pattern: /#?\$[\da-f]{2,4}\b/i,
            alias: "number"
        },
        "binary-number": {
            pattern: /#?%[01]+\b/,
            alias: "number"
        },
        "decimal-number": {
            pattern: /#?\b\d+\b/,
            alias: "number"
        },
        register: {
            pattern: /\b[acznvshtixy]\b/i,
            alias: "variable"
        },
        operator: />>=?|<<=?|&&?|\|\|?|[-+*/%&|^!=<>?]=?/,
        punctuation: /[(),:]/
    };
}

});

parcelRequire.register("10dhr", function(module, exports) {
"use strict";

var $jcO3t = parcelRequire("jcO3t");
module.exports = $0bb017b6f52dacc3$var$aspnet;
$0bb017b6f52dacc3$var$aspnet.displayName = "aspnet";
$0bb017b6f52dacc3$var$aspnet.aliases = [];
function $0bb017b6f52dacc3$var$aspnet(Prism) {
    Prism.register($jcO3t);
    Prism.languages.aspnet = Prism.languages.extend("markup", {
        "page-directive": {
            pattern: /<%\s*@.*%>/,
            alias: "tag",
            inside: {
                "page-directive": {
                    pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
                    alias: "tag"
                },
                rest: Prism.languages.markup.tag.inside
            }
        },
        directive: {
            pattern: /<%.*%>/,
            alias: "tag",
            inside: {
                directive: {
                    pattern: /<%\s*?[$=%#:]{0,2}|%>/,
                    alias: "tag"
                },
                rest: Prism.languages.csharp
            }
        }
    }) // Regexp copied from prism-markup, with a negative look-ahead added
    ;
    Prism.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/ // match directives of attribute value foo="<% Bar %>"
    ;
    Prism.languages.insertBefore("inside", "punctuation", {
        directive: Prism.languages.aspnet["directive"]
    }, Prism.languages.aspnet.tag.inside["attr-value"]);
    Prism.languages.insertBefore("aspnet", "comment", {
        "asp-comment": {
            pattern: /<%--[\s\S]*?--%>/,
            alias: [
                "asp",
                "comment"
            ]
        }
    }) // script runat="server" contains csharp, not javascript
    ;
    Prism.languages.insertBefore("aspnet", Prism.languages.javascript ? "script" : "tag", {
        "asp-script": {
            pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
            lookbehind: true,
            alias: [
                "asp",
                "script"
            ],
            inside: Prism.languages.csharp || {}
        }
    });
}

});
parcelRequire.register("jcO3t", function(module, exports) {
"use strict";
module.exports = $dfb5f7377e6b71c0$var$csharp;
$dfb5f7377e6b71c0$var$csharp.displayName = "csharp";
$dfb5f7377e6b71c0$var$csharp.aliases = [
    "dotnet",
    "cs"
];
function $dfb5f7377e6b71c0$var$csharp(Prism1) {
    (function(Prism) {
        /**
     * Replaces all placeholders "<<n>>" of given pattern with the n-th replacement (zero based).
     *
     * Note: This is a simple text based replacement. Be careful when using backreferences!
     *
     * @param {string} pattern the given pattern.
     * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.
     * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.
     * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source
     */ function replace(pattern, replacements) {
            return pattern.replace(/<<(\d+)>>/g, function(m, index) {
                return "(?:" + replacements[+index] + ")";
            });
        }
        /**
     * @param {string} pattern
     * @param {string[]} replacements
     * @param {string} [flags]
     * @returns {RegExp}
     */ function re(pattern, replacements, flags) {
            return RegExp(replace(pattern, replacements), flags || "");
        }
        /**
     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.
     *
     * @param {string} pattern
     * @param {number} depthLog2
     * @returns {string}
     */ function nested(pattern, depthLog2) {
            for(var i = 0; i < depthLog2; i++)pattern = pattern.replace(/<<self>>/g, function() {
                return "(?:" + pattern + ")";
            });
            return pattern.replace(/<<self>>/g, "[^\\s\\S]");
        } // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
        var keywordKinds = {
            // keywords which represent a return or variable type
            type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
            // keywords which are used to declare a type
            typeDeclaration: "class enum interface record struct",
            // contextual keywords
            // ("var" and "dynamic" are missing because they are used like types)
            contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
            // all other keywords
            other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
        } // keywords
        ;
        function keywordsToPattern(words) {
            return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
        }
        var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
        var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
        var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
        var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other) // types
        ;
        var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2) // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.
        ;
        var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
        var name = /@?\b[A-Za-z_]\w*\b/.source;
        var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [
            name,
            generic
        ]);
        var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [
            nonTypeKeywords,
            genericName
        ]);
        var array = /\[\s*(?:,\s*)*\]/.source;
        var typeExpressionWithoutTuple = replace(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [
            identifier,
            array
        ]);
        var tupleElement = replace(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [
            generic,
            nestedRound,
            array
        ]);
        var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [
            tupleElement
        ]);
        var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [
            tuple,
            identifier,
            array
        ]);
        var typeInside = {
            keyword: keywords,
            punctuation: /[<>()?,.:[\]]/
        } // strings & characters
        ;
        // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#character-literals
        // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals
        var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source // simplified pattern
        ;
        var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
        var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
        Prism.languages.csharp = Prism.languages.extend("clike", {
            string: [
                {
                    pattern: re(/(^|[^$\\])<<0>>/.source, [
                        verbatimString
                    ]),
                    lookbehind: true,
                    greedy: true
                },
                {
                    pattern: re(/(^|[^@$\\])<<0>>/.source, [
                        regularString
                    ]),
                    lookbehind: true,
                    greedy: true
                }
            ],
            "class-name": [
                {
                    // Using static
                    // using static System.Math;
                    pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [
                        identifier
                    ]),
                    lookbehind: true,
                    inside: typeInside
                },
                {
                    // Using alias (type)
                    // using Project = PC.MyCompany.Project;
                    pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
                        name,
                        typeExpression
                    ]),
                    lookbehind: true,
                    inside: typeInside
                },
                {
                    // Using alias (alias)
                    // using Project = PC.MyCompany.Project;
                    pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [
                        name
                    ]),
                    lookbehind: true
                },
                {
                    // Type declarations
                    // class Foo<A, B>
                    // interface Foo<out A, B>
                    pattern: re(/(\b<<0>>\s+)<<1>>/.source, [
                        typeDeclarationKeywords,
                        genericName
                    ]),
                    lookbehind: true,
                    inside: typeInside
                },
                {
                    // Single catch exception declaration
                    // catch(Foo)
                    // (things like catch(Foo e) is covered by variable declaration)
                    pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [
                        identifier
                    ]),
                    lookbehind: true,
                    inside: typeInside
                },
                {
                    // Name of the type parameter of generic constraints
                    // where Foo : class
                    pattern: re(/(\bwhere\s+)<<0>>/.source, [
                        name
                    ]),
                    lookbehind: true
                },
                {
                    // Casts and checks via as and is.
                    // as Foo<A>, is Bar<B>
                    // (things like if(a is Foo b) is covered by variable declaration)
                    pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [
                        typeExpressionWithoutTuple
                    ]),
                    lookbehind: true,
                    inside: typeInside
                },
                {
                    // Variable, field and parameter declaration
                    // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
                    pattern: re(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [
                        typeExpression,
                        nonContextualKeywords,
                        name
                    ]),
                    inside: typeInside
                }
            ],
            keyword: keywords,
            // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
            number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
            operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
            punctuation: /\?\.?|::|[{}[\];(),.:]/
        });
        Prism.languages.insertBefore("csharp", "number", {
            range: {
                pattern: /\.\./,
                alias: "operator"
            }
        });
        Prism.languages.insertBefore("csharp", "punctuation", {
            "named-parameter": {
                pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [
                    name
                ]),
                lookbehind: true,
                alias: "punctuation"
            }
        });
        Prism.languages.insertBefore("csharp", "class-name", {
            namespace: {
                // namespace Foo.Bar {}
                // using Foo.Bar;
                pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [
                    name
                ]),
                lookbehind: true,
                inside: {
                    punctuation: /\./
                }
            },
            "type-expression": {
                // default(Foo), typeof(Foo<Bar>), sizeof(int)
                pattern: re(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [
                    nestedRound
                ]),
                lookbehind: true,
                alias: "class-name",
                inside: typeInside
            },
            "return-type": {
                // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
                // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
                // int Foo => 0; int Foo { get; set } = 0;
                pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [
                    typeExpression,
                    identifier
                ]),
                inside: typeInside,
                alias: "class-name"
            },
            "constructor-invocation": {
                // new List<Foo<Bar[]>> { }
                pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [
                    typeExpression
                ]),
                lookbehind: true,
                inside: typeInside,
                alias: "class-name"
            },
            /*'explicit-implementation': {
// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
inside: classNameInside,
alias: 'class-name'
},*/ "generic-method": {
                // foo<Bar>()
                pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [
                    name,
                    generic
                ]),
                inside: {
                    function: re(/^<<0>>/.source, [
                        name
                    ]),
                    generic: {
                        pattern: RegExp(generic),
                        alias: "class-name",
                        inside: typeInside
                    }
                }
            },
            "type-list": {
                // The list of types inherited or of generic constraints
                // class Foo<F> : Bar, IList<FooBar>
                // where F : Bar, IList<int>
                pattern: re(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [
                    typeDeclarationKeywords,
                    genericName,
                    name,
                    typeExpression,
                    keywords.source,
                    nestedRound,
                    /\bnew\s*\(\s*\)/.source
                ]),
                lookbehind: true,
                inside: {
                    "record-arguments": {
                        pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [
                            genericName,
                            nestedRound
                        ]),
                        lookbehind: true,
                        greedy: true,
                        inside: Prism.languages.csharp
                    },
                    keyword: keywords,
                    "class-name": {
                        pattern: RegExp(typeExpression),
                        greedy: true,
                        inside: typeInside
                    },
                    punctuation: /[,()]/
                }
            },
            preprocessor: {
                pattern: /(^[\t ]*)#.*/m,
                lookbehind: true,
                alias: "property",
                inside: {
                    // highlight preprocessor directives as keywords
                    directive: {
                        pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
                        lookbehind: true,
                        alias: "keyword"
                    }
                }
            }
        }) // attributes
        ;
        var regularStringOrCharacter = regularString + "|" + character;
        var regularStringCharacterOrComment = replace(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [
            regularStringOrCharacter
        ]);
        var roundExpression = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
            regularStringCharacterOrComment
        ]), 2) // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets
        ;
        var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
        var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [
            identifier,
            roundExpression
        ]);
        Prism.languages.insertBefore("csharp", "class-name", {
            attribute: {
                // Attributes
                // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
                pattern: re(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [
                    attrTarget,
                    attr
                ]),
                lookbehind: true,
                greedy: true,
                inside: {
                    target: {
                        pattern: re(/^<<0>>(?=\s*:)/.source, [
                            attrTarget
                        ]),
                        alias: "keyword"
                    },
                    "attribute-arguments": {
                        pattern: re(/\(<<0>>*\)/.source, [
                            roundExpression
                        ]),
                        inside: Prism.languages.csharp
                    },
                    "class-name": {
                        pattern: RegExp(identifier),
                        inside: {
                            punctuation: /\./
                        }
                    },
                    punctuation: /[:,]/
                }
            }
        }) // string interpolation
        ;
        var formatString = /:[^}\r\n]+/.source // multi line
        ;
        var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
            regularStringCharacterOrComment
        ]), 2);
        var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
            mInterpolationRound,
            formatString
        ]) // single line
        ;
        var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [
            regularStringOrCharacter
        ]), 2);
        var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
            sInterpolationRound,
            formatString
        ]);
        function createInterpolationInside(interpolation, interpolationRound) {
            return {
                interpolation: {
                    pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [
                        interpolation
                    ]),
                    lookbehind: true,
                    inside: {
                        "format-string": {
                            pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [
                                interpolationRound,
                                formatString
                            ]),
                            lookbehind: true,
                            inside: {
                                punctuation: /^:/
                            }
                        },
                        punctuation: /^\{|\}$/,
                        expression: {
                            pattern: /[\s\S]+/,
                            alias: "language-csharp",
                            inside: Prism.languages.csharp
                        }
                    }
                },
                string: /[\s\S]+/
            };
        }
        Prism.languages.insertBefore("csharp", "string", {
            "interpolation-string": [
                {
                    pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [
                        mInterpolation
                    ]),
                    lookbehind: true,
                    greedy: true,
                    inside: createInterpolationInside(mInterpolation, mInterpolationRound)
                },
                {
                    pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [
                        sInterpolation
                    ]),
                    lookbehind: true,
                    greedy: true,
                    inside: createInterpolationInside(sInterpolation, sInterpolationRound)
                }
            ],
            char: {
                pattern: RegExp(character),
                greedy: true
            }
        });
        Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;
    })(Prism1);
}

});


parcelRequire.register("3VPhx", function(module, exports) {
"use strict";
module.exports = $2dce797d99d2b753$var$autohotkey;
$2dce797d99d2b753$var$autohotkey.displayName = "autohotkey";
$2dce797d99d2b753$var$autohotkey.aliases = [];
function $2dce797d99d2b753$var$autohotkey(Prism) {
    // NOTES - follows first-first highlight method, block is locked after highlight, different from SyntaxHl
    Prism.languages.autohotkey = {
        comment: [
            {
                pattern: /(^|\s);.*/,
                lookbehind: true
            },
            {
                pattern: /(^[\t ]*)\/\*(?:[\r\n](?![ \t]*\*\/)|[^\r\n])*(?:[\r\n][ \t]*\*\/)?/m,
                lookbehind: true,
                greedy: true
            }
        ],
        tag: {
            // labels
            pattern: /^([ \t]*)[^\s,`":]+(?=:[ \t]*$)/m,
            lookbehind: true
        },
        string: /"(?:[^"\n\r]|"")*"/,
        variable: /%\w+%/,
        number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
        operator: /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
        boolean: /\b(?:false|true)\b/,
        selector: /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetRegView|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
        constant: /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_fileencoding|a_formatfloat|a_formatinteger|a_gui|a_guicontrol|a_guicontrolevent|a_guievent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_is64bitos|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|a_priorkey|a_programfiles|a_programs|a_programscommon|a_ptrsize|a_regview|a_screendpi|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scripthwnd|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel|programfiles)\b/i,
        builtin: /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|comobjactive|comobjarray|comobjconnect|comobjcreate|comobjerror|comobjflags|comobjget|comobjquery|comobjtype|comobjvalue|cos|dllcall|exp|fileexist|Fileopen|floor|format|il_add|il_create|il_destroy|instr|isfunc|islabel|IsObject|ln|log|ltrim|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|numget|numput|onmessage|regexmatch|regexreplace|registercallback|round|rtrim|sb_seticon|sb_setparts|sb_settext|sin|sqrt|strlen|strreplace|strsplit|substr|tan|tv_add|tv_delete|tv_get|tv_getchild|tv_getcount|tv_getnext|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__Call|__Get|__New|__Set)\b/i,
        symbol: /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
        important: /#\b(?:AllowSameLineComments|ClipboardTimeout|CommentFlag|DerefChar|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|If|IfTimeout|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InputLevel|InstallKeybdHook|InstallMouseHook|KeyHistory|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|MenuMaskKey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|Warn|WinActivateForce)\b/i,
        keyword: /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_exe|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Catch|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|Finally|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|Region|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Throw|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|Try|TryAgain|Type|UnCheck|underline|Unicode|Unlock|Until|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i,
        function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+(?=\()/,
        punctuation: /[{}[\]():,]/
    };
}

});

parcelRequire.register("3ETBO", function(module, exports) {
"use strict";
module.exports = $2aa03e48eec0ca7d$var$autoit;
$2aa03e48eec0ca7d$var$autoit.displayName = "autoit";
$2aa03e48eec0ca7d$var$autoit.aliases = [];
function $2aa03e48eec0ca7d$var$autoit(Prism) {
    Prism.languages.autoit = {
        comment: [
            /;.*/,
            {
                // The multi-line comments delimiters can actually be commented out with ";"
                pattern: /(^[\t ]*)#(?:comments-start|cs)[\s\S]*?^[ \t]*#(?:ce|comments-end)/m,
                lookbehind: true
            }
        ],
        url: {
            pattern: /(^[\t ]*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
            lookbehind: true
        },
        string: {
            pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
            greedy: true,
            inside: {
                variable: /([%$@])\w+\1/
            }
        },
        directive: {
            pattern: /(^[\t ]*)#[\w-]+/m,
            lookbehind: true,
            alias: "keyword"
        },
        function: /\b\w+(?=\()/,
        // Variables and macros
        variable: /[$@]\w+/,
        keyword: /\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
        number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
        boolean: /\b(?:False|True)\b/i,
        operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Not|Or)\b/i,
        punctuation: /[\[\]().,:]/
    };
}

});

parcelRequire.register("em7s9", function(module, exports) {
"use strict";
module.exports = $a738e6ccc120a74c$var$avisynth;
$a738e6ccc120a74c$var$avisynth.displayName = "avisynth";
$a738e6ccc120a74c$var$avisynth.aliases = [
    "avs"
];
function $a738e6ccc120a74c$var$avisynth(Prism1) {
    (function(Prism) {
        function replace(pattern, replacements) {
            return pattern.replace(/<<(\d+)>>/g, function(m, index) {
                return replacements[+index];
            });
        }
        function re(pattern, replacements, flags) {
            return RegExp(replace(pattern, replacements), flags || "");
        }
        var types = /bool|clip|float|int|string|val/.source;
        var internals = [
            // bools
            /is(?:bool|clip|float|int|string)|defined|(?:(?:internal)?function|var)?exists?/.source,
            /apply|assert|default|eval|import|nop|select|undefined/.source,
            /opt_(?:allowfloataudio|avipadscanlines|dwchannelmask|enable_(?:b64a|planartopackedrgb|v210|y3_10_10|y3_10_16)|usewaveextensible|vdubplanarhack)|set(?:cachemode|maxcpu|memorymax|planarlegacyalignment|workingdir)/.source,
            /hex(?:value)?|value/.source,
            /abs|ceil|continued(?:denominator|numerator)?|exp|floor|fmod|frac|log(?:10)?|max|min|muldiv|pi|pow|rand|round|sign|spline|sqrt/.source,
            /a?sinh?|a?cosh?|a?tan[2h]?/.source,
            /(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/.source,
            /average(?:[bgr]|chroma[uv]|luma)|(?:[rgb]|chroma[uv]|luma|rgb|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/.source,
            /getprocessinfo|logmsg|script(?:dir(?:utf8)?|file(?:utf8)?|name(?:utf8)?)|setlogparams/.source,
            /chr|(?:fill|find|left|mid|replace|rev|right)str|format|[lu]case|ord|str(?:cmpi?|fromutf8|len|toutf8)|time|trim(?:all|left|right)/.source,
            /isversionorgreater|version(?:number|string)/.source,
            /buildpixeltype|colorspacenametopixeltype/.source,
            /addautoloaddir|on(?:cpu|cuda)|prefetch|setfiltermtmode/.source
        ].join("|");
        var properties = [
            // content
            /has(?:audio|video)/.source,
            /height|width/.source,
            /frame(?:count|rate)|framerate(?:denominator|numerator)/.source,
            /getparity|is(?:field|frame)based/.source,
            /bitspercomponent|componentsize|hasalpha|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:va?|y2))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|numcomponents|pixeltype/.source,
            /audio(?:bits|channels|duration|length(?:[fs]|hi|lo)?|rate)|isaudio(?:float|int)/.source
        ].join("|");
        var filters = [
            // source
            /avi(?:file)?source|directshowsource|image(?:reader|source|sourceanim)|opendmlsource|segmented(?:avisource|directshowsource)|wavsource/.source,
            /coloryuv|convertbacktoyuy2|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:411|420|422|444)|YUY2)|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:chroma|luma)|rgbadjust|show(?:alpha|blue|green|red)|swapuv|tweak|[uv]toy8?|ytouv/.source,
            /(?:colorkey|reset)mask|layer|mask(?:hs)?|merge|overlay|subtract/.source,
            /addborders|(?:bicubic|bilinear|blackman|gauss|lanczos4|lanczos|point|sinc|spline(?:16|36|64))resize|crop(?:bottom)?|flip(?:horizontal|vertical)|(?:horizontal|vertical)?reduceby2|letterbox|skewrows|turn(?:180|left|right)/.source,
            /blur|fixbrokenchromaupsampling|generalconvolution|(?:spatial|temporal)soften|sharpen/.source,
            /trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|io|out)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/.source,
            /assume[bt]ff|assume(?:field|frame)based|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|fields|rows)|swapfields|weave(?:columns|rows)?/.source,
            /amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|ssrc|supereq|timestretch/.source,
            /animate|applyrange|conditional(?:filter|reader|select)|frameevaluate|scriptclip|tcp(?:server|source)|writefile(?:end|if|start)?/.source,
            /imagewriter/.source,
            /blackness|blankclip|colorbars(?:hd)?|compare|dumpfiltergraph|echo|histogram|info|messageclip|preroll|setgraphanalysis|show(?:framenumber|smpte|time)|showfiveversions|stack(?:horizontal|vertical)|subtitle|tone|version/.source
        ].join("|");
        var allinternals = [
            internals,
            properties,
            filters
        ].join("|");
        Prism.languages.avisynth = {
            comment: [
                {
                    // Matches [* *] nestable block comments, but only supports 1 level of nested comments
                    // /\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|<self>)*\*\]/
                    pattern: /(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
                    lookbehind: true,
                    greedy: true
                },
                {
                    // Matches /* */ block comments
                    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                    lookbehind: true,
                    greedy: true
                },
                {
                    // Matches # comments
                    pattern: /(^|[^\\$])#.*/,
                    lookbehind: true,
                    greedy: true
                }
            ],
            // Handle before strings because optional arguments are surrounded by double quotes
            argument: {
                pattern: re(/\b(?:<<0>>)\s+("?)\w+\1/.source, [
                    types
                ], "i"),
                inside: {
                    keyword: /^\w+/
                }
            },
            // Optional argument assignment
            "argument-label": {
                pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
                lookbehind: true,
                inside: {
                    "argument-name": {
                        pattern: /^\w+/,
                        alias: "punctuation"
                    },
                    punctuation: /=$/
                }
            },
            string: [
                {
                    // triple double-quoted
                    pattern: /"""[\s\S]*?"""/,
                    greedy: true
                },
                {
                    // single double-quoted
                    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
                    greedy: true,
                    inside: {
                        constant: {
                            // These *are* case-sensitive!
                            pattern: /\b(?:DEFAULT_MT_MODE|(?:MAINSCRIPT|PROGRAM|SCRIPT)DIR|(?:MACHINE|USER)_(?:CLASSIC|PLUS)_PLUGINS)\b/
                        }
                    }
                }
            ],
            // The special "last" variable that takes the value of the last implicitly returned clip
            variable: /\b(?:last)\b/i,
            boolean: /\b(?:false|no|true|yes)\b/i,
            keyword: /\b(?:catch|else|for|function|global|if|return|try|while|__END__)\b/i,
            constant: /\bMT_(?:MULTI_INSTANCE|NICE_FILTER|SERIALIZED|SPECIAL_MT)\b/,
            // AviSynth's internal functions, filters, and properties
            "builtin-function": {
                pattern: re(/\b(?:<<0>>)\b/.source, [
                    allinternals
                ], "i"),
                alias: "function"
            },
            "type-cast": {
                pattern: re(/\b(?:<<0>>)(?=\s*\()/.source, [
                    types
                ], "i"),
                alias: "keyword"
            },
            // External/user-defined filters
            function: {
                pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
                lookbehind: true
            },
            // Matches a \ as the first or last character on a line
            "line-continuation": {
                pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
                lookbehind: true,
                alias: "punctuation"
            },
            number: /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
            operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
            punctuation: /[{}\[\]();,.]/
        };
        Prism.languages.avs = Prism.languages.avisynth;
    })(Prism1);
}

});

parcelRequire.register("8sFpc", function(module, exports) {
"use strict";
module.exports = $62910e804a917839$var$avroIdl;
$62910e804a917839$var$avroIdl.displayName = "avroIdl";
$62910e804a917839$var$avroIdl.aliases = [];
function $62910e804a917839$var$avroIdl(Prism) {
    // GitHub: https://github.com/apache/avro
    // Docs: https://avro.apache.org/docs/current/idl.html
    Prism.languages["avro-idl"] = {
        comment: {
            pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
            greedy: true
        },
        string: {
            pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
            lookbehind: true,
            greedy: true
        },
        annotation: {
            pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
            greedy: true,
            alias: "function"
        },
        "function-identifier": {
            pattern: /`[^\r\n`]+`(?=\s*\()/,
            greedy: true,
            alias: "function"
        },
        identifier: {
            pattern: /`[^\r\n`]+`/,
            greedy: true
        },
        "class-name": {
            pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
            lookbehind: true,
            greedy: true
        },
        keyword: /\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: [
            {
                pattern: /(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
                lookbehind: true
            },
            /-?\b(?:Infinity|NaN)\b/
        ],
        operator: /=/,
        punctuation: /[()\[\]{}<>.:,;-]/
    };
    Prism.languages.avdl = Prism.languages["avro-idl"];
}

});

parcelRequire.register("adjC6", function(module, exports) {
"use strict";
module.exports = $76fa5521b8083834$var$bash;
$76fa5521b8083834$var$bash.displayName = "bash";
$76fa5521b8083834$var$bash.aliases = [
    "shell"
];
function $76fa5521b8083834$var$bash(Prism1) {
    (function(Prism) {
        // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\n' '|'
        // + LC_ALL, RANDOM, REPLY, SECONDS.
        // + make sure PS1..4 are here as they are not always set,
        // - some useless things.
        var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
        var commandAfterHeredoc = {
            pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
            lookbehind: true,
            alias: "punctuation",
            // this looks reasonably well in all themes
            inside: null // see below
        };
        var insideString = {
            bash: commandAfterHeredoc,
            environment: {
                pattern: RegExp("\\$" + envVars),
                alias: "constant"
            },
            variable: [
                // [0]: Arithmetic Environment
                {
                    pattern: /\$?\(\([\s\S]+?\)\)/,
                    greedy: true,
                    inside: {
                        // If there is a $ sign at the beginning highlight $(( and )) as variable
                        variable: [
                            {
                                pattern: /(^\$\(\([\s\S]+)\)\)/,
                                lookbehind: true
                            },
                            /^\$\(\(/
                        ],
                        number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                        // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
                        operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
                        // If there is no $ sign at the beginning highlight (( and )) as punctuation
                        punctuation: /\(\(?|\)\)?|,|;/
                    }
                },
                {
                    pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
                    greedy: true,
                    inside: {
                        variable: /^\$\(|^`|\)$|`$/
                    }
                },
                {
                    pattern: /\$\{[^}]+\}/,
                    greedy: true,
                    inside: {
                        operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                        punctuation: /[\[\]]/,
                        environment: {
                            pattern: RegExp("(\\{)" + envVars),
                            lookbehind: true,
                            alias: "constant"
                        }
                    }
                },
                /\$(?:\w+|[#?*!@$])/
            ],
            // Escape sequences from echo and printf's manuals, and escaped quotes.
            entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
        };
        Prism.languages.bash = {
            shebang: {
                pattern: /^#!\s*\/.*/,
                alias: "important"
            },
            comment: {
                pattern: /(^|[^"{\\$])#.*/,
                lookbehind: true
            },
            "function-name": [
                // a) function foo {
                // b) foo() {
                // c) function foo() {
                // but not “foo {”
                {
                    // a) and c)
                    pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
                    lookbehind: true,
                    alias: "function"
                },
                {
                    // b)
                    pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
                    alias: "function"
                }
            ],
            // Highlight variable names as variables in for and select beginnings.
            "for-or-select": {
                pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
                alias: "variable",
                lookbehind: true
            },
            // Highlight variable names as variables in the left-hand part
            // of assignments (“=” and “+=”).
            "assign-left": {
                pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
                inside: {
                    environment: {
                        pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
                        lookbehind: true,
                        alias: "constant"
                    }
                },
                alias: "variable",
                lookbehind: true
            },
            string: [
                // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
                {
                    pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
                    lookbehind: true,
                    greedy: true,
                    inside: insideString
                },
                // → No expansion (so no “inside”).
                {
                    pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
                    lookbehind: true,
                    greedy: true,
                    inside: {
                        bash: commandAfterHeredoc
                    }
                },
                {
                    // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
                    pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
                    lookbehind: true,
                    greedy: true,
                    inside: insideString
                },
                {
                    // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
                    pattern: /(^|[^$\\])'[^']*'/,
                    lookbehind: true,
                    greedy: true
                },
                {
                    // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
                    pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
                    greedy: true,
                    inside: {
                        entity: insideString.entity
                    }
                }
            ],
            environment: {
                pattern: RegExp("\\$?" + envVars),
                alias: "constant"
            },
            variable: insideString.variable,
            function: {
                pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
                lookbehind: true
            },
            keyword: {
                pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
                lookbehind: true
            },
            // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
            builtin: {
                pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
                lookbehind: true,
                // Alias added to make those easier to distinguish from strings.
                alias: "class-name"
            },
            boolean: {
                pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
                lookbehind: true
            },
            "file-descriptor": {
                pattern: /\B&\d\b/,
                alias: "important"
            },
            operator: {
                // Lots of redirections here, but not just that.
                pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
                inside: {
                    "file-descriptor": {
                        pattern: /^\d/,
                        alias: "important"
                    }
                }
            },
            punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
            number: {
                pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
                lookbehind: true
            }
        };
        commandAfterHeredoc.inside = Prism.languages.bash;
        /* Patterns in command substitution. */ var toBeCopied = [
            "comment",
            "function-name",
            "for-or-select",
            "assign-left",
            "string",
            "environment",
            "function",
            "keyword",
            "builtin",
            "boolean",
            "file-descriptor",
            "operator",
            "punctuation",
            "number"
        ];
        var inside = insideString.variable[1].inside;
        for(var i = 0; i < toBeCopied.length; i++)inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];
        Prism.languages.shell = Prism.languages.bash;
    })(Prism1);
}

});

parcelRequire.register("8M8zk", function(module, exports) {
"use strict";
module.exports = $01a61684296905d9$var$basic;
$01a61684296905d9$var$basic.displayName = "basic";
$01a61684296905d9$var$basic.aliases = [];
function $01a61684296905d9$var$basic(Prism) {
    Prism.languages.basic = {
        comment: {
            pattern: /(?:!|REM\b).+/i,
            inside: {
                keyword: /^REM/i
            }
        },
        string: {
            pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
            greedy: true
        },
        number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
        keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
        function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
        operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
        punctuation: /[,;:()]/
    };
}

});

parcelRequire.register("4RP6Z", function(module, exports) {
"use strict";
module.exports = $38b3c2637e7ac336$var$batch;
$38b3c2637e7ac336$var$batch.displayName = "batch";
$38b3c2637e7ac336$var$batch.aliases = [];
function $38b3c2637e7ac336$var$batch(Prism1) {
    (function(Prism) {
        var variable = /%%?[~:\w]+%?|!\S+!/;
        var parameter = {
            pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
            alias: "attr-name",
            inside: {
                punctuation: /:/
            }
        };
        var string = /"(?:[\\"]"|[^"])*"(?!")/;
        var number = /(?:\b|-)\d+\b/;
        Prism.languages.batch = {
            comment: [
                /^::.*/m,
                {
                    pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
                    lookbehind: true
                }
            ],
            label: {
                pattern: /^:.*/m,
                alias: "property"
            },
            command: [
                {
                    // FOR command
                    pattern: /((?:^|[&(])[ \t]*)for(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* \S+ in \([^)]+\) do/im,
                    lookbehind: true,
                    inside: {
                        keyword: /\b(?:do|in)\b|^for\b/i,
                        string: string,
                        parameter: parameter,
                        variable: variable,
                        number: number,
                        punctuation: /[()',]/
                    }
                },
                {
                    // IF command
                    pattern: /((?:^|[&(])[ \t]*)if(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|(?!")(?:(?!==)\S)+)?(?:==| (?:equ|geq|gtr|leq|lss|neq) )(?:"[^"]*"|[^\s"]\S*))/im,
                    lookbehind: true,
                    inside: {
                        keyword: /\b(?:cmdextversion|defined|errorlevel|exist|not)\b|^if\b/i,
                        string: string,
                        parameter: parameter,
                        variable: variable,
                        number: number,
                        operator: /\^|==|\b(?:equ|geq|gtr|leq|lss|neq)\b/i
                    }
                },
                {
                    // ELSE command
                    pattern: /((?:^|[&()])[ \t]*)else\b/im,
                    lookbehind: true,
                    inside: {
                        keyword: /^else\b/i
                    }
                },
                {
                    // SET command
                    pattern: /((?:^|[&(])[ \t]*)set(?: \/[a-z](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
                    lookbehind: true,
                    inside: {
                        keyword: /^set\b/i,
                        string: string,
                        parameter: parameter,
                        variable: [
                            variable,
                            /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/
                        ],
                        number: number,
                        operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
                        punctuation: /[()',]/
                    }
                },
                {
                    // Other commands
                    pattern: /((?:^|[&(])[ \t]*@?)\w+\b(?:"(?:[\\"]"|[^"])*"(?!")|[^"^&)\r\n]|\^(?:\r\n|[\s\S]))*/m,
                    lookbehind: true,
                    inside: {
                        keyword: /^\w+\b/,
                        string: string,
                        parameter: parameter,
                        label: {
                            pattern: /(^\s*):\S+/m,
                            lookbehind: true,
                            alias: "property"
                        },
                        variable: variable,
                        number: number,
                        operator: /\^/
                    }
                }
            ],
            operator: /[&@]/,
            punctuation: /[()']/
        };
    })(Prism1);
}

});

parcelRequire.register("killR", function(module, exports) {
"use strict";
module.exports = $ec660d11d4cb1620$var$bbcode;
$ec660d11d4cb1620$var$bbcode.displayName = "bbcode";
$ec660d11d4cb1620$var$bbcode.aliases = [
    "shortcode"
];
function $ec660d11d4cb1620$var$bbcode(Prism) {
    Prism.languages.bbcode = {
        tag: {
            pattern: /\[\/?[^\s=\]]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))?(?:\s+[^\s=\]]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))*\s*\]/,
            inside: {
                tag: {
                    pattern: /^\[\/?[^\s=\]]+/,
                    inside: {
                        punctuation: /^\[\/?/
                    }
                },
                "attr-value": {
                    pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+)/,
                    inside: {
                        punctuation: [
                            /^=/,
                            {
                                pattern: /^(\s*)["']|["']$/,
                                lookbehind: true
                            }
                        ]
                    }
                },
                punctuation: /\]/,
                "attr-name": /[^\s=\]]+/
            }
        }
    };
    Prism.languages.shortcode = Prism.languages.bbcode;
}

});

parcelRequire.register("1rJbI", function(module, exports) {
"use strict";
module.exports = $10db5d762ae418b6$var$bicep;
$10db5d762ae418b6$var$bicep.displayName = "bicep";
$10db5d762ae418b6$var$bicep.aliases = [];
function $10db5d762ae418b6$var$bicep(Prism) {
    // based loosely upon: https://github.com/Azure/bicep/blob/main/src/textmate/bicep.tmlanguage
    Prism.languages.bicep = {
        comment: [
            {
                // multiline comments eg /* ASDF */
                pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                lookbehind: true,
                greedy: true
            },
            {
                // singleline comments eg // ASDF
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        property: [
            {
                pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i,
                lookbehind: true
            },
            {
                pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
                lookbehind: true,
                greedy: true
            }
        ],
        string: [
            {
                pattern: /'''[^'][\s\S]*?'''/,
                greedy: true
            },
            {
                pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
                lookbehind: true,
                greedy: true
            }
        ],
        "interpolated-string": {
            pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
            lookbehind: true,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: /\$\{[^{}\r\n]*\}/,
                    inside: {
                        expression: {
                            pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                            lookbehind: true
                        },
                        punctuation: /^\$\{|\}$/
                    }
                },
                string: /[\s\S]+/
            }
        },
        datatype: {
            pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
            lookbehind: true,
            alias: "class-name"
        },
        boolean: /\b(?:false|true)\b/,
        // https://github.com/Azure/bicep/blob/114a3251b4e6e30082a58729f19a8cc4e374ffa6/src/textmate/bicep.tmlanguage#L184
        keyword: /\b(?:existing|for|if|in|module|null|output|param|resource|targetScope|var)\b/,
        decorator: /@\w+\b/,
        function: /\b[a-z_]\w*(?=[ \t]*\()/i,
        number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
        operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
        punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.bicep["interpolated-string"].inside["interpolation"].inside["expression"].inside = Prism.languages.bicep;
}

});

parcelRequire.register("58ao8", function(module, exports) {
"use strict";
module.exports = $3bc5c1ffd871fa23$var$birb;
$3bc5c1ffd871fa23$var$birb.displayName = "birb";
$3bc5c1ffd871fa23$var$birb.aliases = [];
function $3bc5c1ffd871fa23$var$birb(Prism) {
    Prism.languages.birb = Prism.languages.extend("clike", {
        string: {
            pattern: /r?("|')(?:\\.|(?!\1)[^\\])*\1/,
            greedy: true
        },
        "class-name": [
            /\b[A-Z](?:[\d_]*[a-zA-Z]\w*)?\b/,
            /\b(?:[A-Z]\w*|(?!(?:var|void)\b)[a-z]\w*)(?=\s+\w+\s*[;,=()])/
        ],
        keyword: /\b(?:assert|break|case|class|const|default|else|enum|final|follows|for|grab|if|nest|new|next|noSeeb|return|static|switch|throw|var|void|while)\b/,
        operator: /\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?|:/,
        variable: /\b[a-z_]\w*\b/
    });
    Prism.languages.insertBefore("birb", "function", {
        metadata: {
            pattern: /<\w+>/,
            greedy: true,
            alias: "symbol"
        }
    });
}

});

parcelRequire.register("2ZmdF", function(module, exports) {
"use strict";

var $bEqqd = parcelRequire("bEqqd");
module.exports = $22d28398bffb9a71$var$bison;
$22d28398bffb9a71$var$bison.displayName = "bison";
$22d28398bffb9a71$var$bison.aliases = [];
function $22d28398bffb9a71$var$bison(Prism) {
    Prism.register($bEqqd);
    Prism.languages.bison = Prism.languages.extend("c", {});
    Prism.languages.insertBefore("bison", "comment", {
        bison: {
            // This should match all the beginning of the file
            // including the prologue(s), the bison declarations and
            // the grammar rules.
            pattern: /^(?:[^%]|%(?!%))*%%[\s\S]*?%%/,
            inside: {
                c: {
                    // Allow for one level of nested braces
                    pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
                    inside: {
                        delimiter: {
                            pattern: /^%?\{|%?\}$/,
                            alias: "punctuation"
                        },
                        "bison-variable": {
                            pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
                            alias: "variable",
                            inside: {
                                punctuation: /<|>/
                            }
                        },
                        rest: Prism.languages.c
                    }
                },
                comment: Prism.languages.c.comment,
                string: Prism.languages.c.string,
                property: /\S+(?=:)/,
                keyword: /%\w+/,
                number: {
                    pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i,
                    lookbehind: true
                },
                punctuation: /%[%?]|[|:;\[\]<>]/
            }
        }
    });
}

});

parcelRequire.register("8jiFM", function(module, exports) {
"use strict";
module.exports = $60ce951bf6695c91$var$bnf;
$60ce951bf6695c91$var$bnf.displayName = "bnf";
$60ce951bf6695c91$var$bnf.aliases = [
    "rbnf"
];
function $60ce951bf6695c91$var$bnf(Prism) {
    Prism.languages.bnf = {
        string: {
            pattern: /"[^\r\n"]*"|'[^\r\n']*'/
        },
        definition: {
            pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
            alias: [
                "rule",
                "keyword"
            ],
            inside: {
                punctuation: /^<|>$/
            }
        },
        rule: {
            pattern: /<[^<>\r\n\t]+>/,
            inside: {
                punctuation: /^<|>$/
            }
        },
        operator: /::=|[|()[\]{}*+?]|\.{3}/
    };
    Prism.languages.rbnf = Prism.languages.bnf;
}

});

parcelRequire.register("4wFtN", function(module, exports) {
"use strict";
module.exports = $34ba5393d59c5529$var$brainfuck;
$34ba5393d59c5529$var$brainfuck.displayName = "brainfuck";
$34ba5393d59c5529$var$brainfuck.aliases = [];
function $34ba5393d59c5529$var$brainfuck(Prism) {
    Prism.languages.brainfuck = {
        pointer: {
            pattern: /<|>/,
            alias: "keyword"
        },
        increment: {
            pattern: /\+/,
            alias: "inserted"
        },
        decrement: {
            pattern: /-/,
            alias: "deleted"
        },
        branching: {
            pattern: /\[|\]/,
            alias: "important"
        },
        operator: /[.,]/,
        comment: /\S+/
    };
}

});

parcelRequire.register("9cYPk", function(module, exports) {
"use strict";
module.exports = $6b446b0480b57016$var$brightscript;
$6b446b0480b57016$var$brightscript.displayName = "brightscript";
$6b446b0480b57016$var$brightscript.aliases = [];
function $6b446b0480b57016$var$brightscript(Prism) {
    Prism.languages.brightscript = {
        comment: /(?:\brem|').*/i,
        "directive-statement": {
            pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
            lookbehind: true,
            alias: "property",
            inside: {
                "error-message": {
                    pattern: /(^#error).+/,
                    lookbehind: true
                },
                directive: {
                    pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
                    alias: "keyword"
                },
                expression: {
                    pattern: /[\s\S]+/,
                    inside: null // see below
                }
            }
        },
        property: {
            pattern: /([\r\n{,][\t ]*)(?:(?!\d)\w+|"(?:[^"\r\n]|"")*"(?!"))(?=[ \t]*:)/,
            lookbehind: true,
            greedy: true
        },
        string: {
            pattern: /"(?:[^"\r\n]|"")*"(?!")/,
            greedy: true
        },
        "class-name": {
            pattern: /(\bAs[\t ]+)\w+/i,
            lookbehind: true
        },
        keyword: /\b(?:As|Dim|Each|Else|Elseif|End|Exit|For|Function|Goto|If|In|Print|Return|Step|Stop|Sub|Then|To|While)\b/i,
        boolean: /\b(?:false|true)\b/i,
        function: /\b(?!\d)\w+(?=[\t ]*\()/,
        number: /(?:\b\d+(?:\.\d+)?(?:[ed][+-]\d+)?|&h[a-f\d]+)\b[%&!#]?/i,
        operator: /--|\+\+|>>=?|<<=?|<>|[-+*/\\<>]=?|[:^=?]|\b(?:and|mod|not|or)\b/i,
        punctuation: /[.,;()[\]{}]/,
        constant: /\b(?:LINE_NUM)\b/i
    };
    Prism.languages.brightscript["directive-statement"].inside.expression.inside = Prism.languages.brightscript;
}

});

parcelRequire.register("3ttFf", function(module, exports) {
"use strict";
module.exports = $287b1737d59f1eb7$var$bro;
$287b1737d59f1eb7$var$bro.displayName = "bro";
$287b1737d59f1eb7$var$bro.aliases = [];
function $287b1737d59f1eb7$var$bro(Prism) {
    Prism.languages.bro = {
        comment: {
            pattern: /(^|[^\\$])#.*/,
            lookbehind: true,
            inside: {
                italic: /\b(?:FIXME|TODO|XXX)\b/
            }
        },
        string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        boolean: /\b[TF]\b/,
        function: {
            pattern: /(\b(?:event|function|hook)[ \t]+)\w+(?:::\w+)?/,
            lookbehind: true
        },
        builtin: /(?:@(?:load(?:-(?:plugin|sigs))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:add_func|create_expire|default|delete_func|encrypt|error_handler|expire_func|group|log|mergeable|optional|persistent|priority|raw_output|read_expire|redef|rotate_interval|rotate_size|synchronized|type_column|write_expire))/,
        constant: {
            pattern: /(\bconst[ \t]+)\w+/i,
            lookbehind: true
        },
        keyword: /\b(?:add|addr|alarm|any|bool|break|const|continue|count|delete|double|else|enum|event|export|file|for|function|global|hook|if|in|int|interval|local|module|next|of|opaque|pattern|port|print|record|return|schedule|set|string|subnet|table|time|timeout|using|vector|when)\b/,
        operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
        number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        punctuation: /[{}[\];(),.:]/
    };
}

});

parcelRequire.register("4eYlO", function(module, exports) {
"use strict";
module.exports = $316748a1689acfb3$var$bsl;
$316748a1689acfb3$var$bsl.displayName = "bsl";
$316748a1689acfb3$var$bsl.aliases = [];
function $316748a1689acfb3$var$bsl(Prism) {
    /* eslint-disable no-misleading-character-class */ // 1C:Enterprise
    // https://github.com/Diversus23/
    //
    Prism.languages.bsl = {
        comment: /\/\/.*/,
        string: [
            // Строки
            // Strings
            {
                pattern: /"(?:[^"]|"")*"(?!")/,
                greedy: true
            },
            // Date & time
            {
                pattern: /'(?:[^'\r\n\\]|\\.)*'/
            }
        ],
        keyword: [
            {
                // RU
                pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:пока|для|новый|прервать|попытка|исключение|вызватьисключение|иначе|конецпопытки|неопределено|функция|перем|возврат|конецфункции|если|иначеесли|процедура|конецпроцедуры|тогда|знач|экспорт|конецесли|из|каждого|истина|ложь|по|цикл|конеццикла|выполнить)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
                lookbehind: true
            },
            {
                // EN
                pattern: /\b(?:break|do|each|else|elseif|enddo|endfunction|endif|endprocedure|endtry|except|execute|export|false|for|function|if|in|new|null|procedure|raise|return|then|to|true|try|undefined|val|var|while)\b/i
            }
        ],
        number: {
            pattern: /(^(?=\d)|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:\d+(?:\.\d*)?|\.\d+)(?:E[+-]?\d+)?/i,
            lookbehind: true
        },
        operator: [
            /[<>+\-*/]=?|[%=]/,
            {
                pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:и|или|не)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
                lookbehind: true
            },
            {
                pattern: /\b(?:and|not|or)\b/i
            }
        ],
        punctuation: /\(\.|\.\)|[()\[\]:;,.]/,
        directive: [
            // Теги препроцессора вида &Клиент, &Сервер, ...
            // Preprocessor tags of the type &Client, &Server, ...
            {
                pattern: /^([ \t]*)&.*/m,
                lookbehind: true,
                greedy: true,
                alias: "important"
            },
            // #Если Сервер Тогда
            // ...
            // #КонецЕсли
            // Preprocessor instructions of the form:
            // #If Server Then
            // ...
            // #EndIf
            {
                pattern: /^([ \t]*)#.*/gm,
                lookbehind: true,
                greedy: true,
                alias: "important"
            }
        ]
    };
    Prism.languages.oscript = Prism.languages["bsl"];
}

});

parcelRequire.register("8R9GL", function(module, exports) {
"use strict";
module.exports = $672ac9f466a62288$var$cfscript;
$672ac9f466a62288$var$cfscript.displayName = "cfscript";
$672ac9f466a62288$var$cfscript.aliases = [];
function $672ac9f466a62288$var$cfscript(Prism) {
    // https://cfdocs.org/script
    Prism.languages.cfscript = Prism.languages.extend("clike", {
        comment: [
            {
                pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                lookbehind: true,
                inside: {
                    annotation: {
                        pattern: /(?:^|[^.])@[\w\.]+/,
                        alias: "punctuation"
                    }
                }
            },
            {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        keyword: /\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
        operator: [
            /\+\+|--|&&|\|\||::|=>|[!=]==|<=?|>=?|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|[?:]/,
            /\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/
        ],
        scope: {
            pattern: /\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
            alias: "global"
        },
        type: {
            pattern: /\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
            alias: "builtin"
        }
    });
    Prism.languages.insertBefore("cfscript", "keyword", {
        // This must be declared before keyword because we use "function" inside the lookahead
        "function-variable": {
            pattern: /[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
            alias: "function"
        }
    });
    delete Prism.languages.cfscript["class-name"];
    Prism.languages.cfc = Prism.languages["cfscript"];
}

});

parcelRequire.register("53QAh", function(module, exports) {
"use strict";

var $eLG4G = parcelRequire("eLG4G");
module.exports = $3af605aeda63ad2a$var$chaiscript;
$3af605aeda63ad2a$var$chaiscript.displayName = "chaiscript";
$3af605aeda63ad2a$var$chaiscript.aliases = [];
function $3af605aeda63ad2a$var$chaiscript(Prism) {
    Prism.register($eLG4G);
    Prism.languages.chaiscript = Prism.languages.extend("clike", {
        string: {
            pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
            lookbehind: true,
            greedy: true
        },
        "class-name": [
            {
                // e.g. class Rectangle { ... }
                pattern: /(\bclass\s+)\w+/,
                lookbehind: true
            },
            {
                // e.g. attr Rectangle::height, def Rectangle::area() { ... }
                pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/,
                lookbehind: true
            }
        ],
        keyword: /\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
        number: [
            Prism.languages.cpp.number,
            /\b(?:Infinity|NaN)\b/
        ],
        operator: />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
    });
    Prism.languages.insertBefore("chaiscript", "operator", {
        "parameter-type": {
            // e.g. def foo(int x, Vector y) {...}
            pattern: /([,(]\s*)\w+(?=\s+\w)/,
            lookbehind: true,
            alias: "class-name"
        }
    });
    Prism.languages.insertBefore("chaiscript", "string", {
        "string-interpolation": {
            pattern: /(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
            lookbehind: true,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
                    lookbehind: true,
                    inside: {
                        "interpolation-expression": {
                            pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                            lookbehind: true,
                            inside: Prism.languages.chaiscript
                        },
                        "interpolation-punctuation": {
                            pattern: /^\$\{|\}$/,
                            alias: "punctuation"
                        }
                    }
                },
                string: /[\s\S]+/
            }
        }
    });
}

});

parcelRequire.register("9WThB", function(module, exports) {
"use strict";
module.exports = $73e469e4b15a5154$var$cil;
$73e469e4b15a5154$var$cil.displayName = "cil";
$73e469e4b15a5154$var$cil.aliases = [];
function $73e469e4b15a5154$var$cil(Prism) {
    Prism.languages.cil = {
        comment: /\/\/.*/,
        string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        directive: {
            pattern: /(^|\W)\.[a-z]+(?=\s)/,
            lookbehind: true,
            alias: "class-name"
        },
        // Actually an assembly reference
        variable: /\[[\w\.]+\]/,
        keyword: /\b(?:abstract|ansi|assembly|auto|autochar|beforefieldinit|bool|bstr|byvalstr|catch|char|cil|class|currency|date|decimal|default|enum|error|explicit|extends|extern|famandassem|family|famorassem|final(?:ly)?|float32|float64|hidebysig|u?int(?:8|16|32|64)?|iant|idispatch|implements|import|initonly|instance|interface|iunknown|literal|lpstr|lpstruct|lptstr|lpwstr|managed|method|native(?:Type)?|nested|newslot|object(?:ref)?|pinvokeimpl|private|privatescope|public|reqsecobj|rtspecialname|runtime|sealed|sequential|serializable|specialname|static|string|struct|syschar|tbstr|unicode|unmanagedexp|unsigned|value(?:type)?|variant|virtual|void)\b/,
        function: /\b(?:(?:constrained|no|readonly|tail|unaligned|volatile)\.)?(?:conv\.(?:[iu][1248]?|ovf\.[iu][1248]?(?:\.un)?|r\.un|r4|r8)|ldc\.(?:i4(?:\.\d+|\.[mM]1|\.s)?|i8|r4|r8)|ldelem(?:\.[iu][1248]?|\.r[48]|\.ref|a)?|ldind\.(?:[iu][1248]?|r[48]|ref)|stelem\.?(?:i[1248]?|r[48]|ref)?|stind\.(?:i[1248]?|r[48]|ref)?|end(?:fault|filter|finally)|ldarg(?:\.[0-3s]|a(?:\.s)?)?|ldloc(?:\.\d+|\.s)?|sub(?:\.ovf(?:\.un)?)?|mul(?:\.ovf(?:\.un)?)?|add(?:\.ovf(?:\.un)?)?|stloc(?:\.[0-3s])?|refany(?:type|val)|blt(?:\.un)?(?:\.s)?|ble(?:\.un)?(?:\.s)?|bgt(?:\.un)?(?:\.s)?|bge(?:\.un)?(?:\.s)?|unbox(?:\.any)?|init(?:blk|obj)|call(?:i|virt)?|brfalse(?:\.s)?|bne\.un(?:\.s)?|ldloca(?:\.s)?|brzero(?:\.s)?|brtrue(?:\.s)?|brnull(?:\.s)?|brinst(?:\.s)?|starg(?:\.s)?|leave(?:\.s)?|shr(?:\.un)?|rem(?:\.un)?|div(?:\.un)?|clt(?:\.un)?|alignment|castclass|ldvirtftn|beq(?:\.s)?|ckfinite|ldsflda|ldtoken|localloc|mkrefany|rethrow|cgt\.un|arglist|switch|stsfld|sizeof|newobj|newarr|ldsfld|ldnull|ldflda|isinst|throw|stobj|stfld|ldstr|ldobj|ldlen|ldftn|ldfld|cpobj|cpblk|break|br\.s|xor|shl|ret|pop|not|nop|neg|jmp|dup|cgt|ceq|box|and|or|br)\b/,
        boolean: /\b(?:false|true)\b/,
        number: /\b-?(?:0x[0-9a-f]+|\d+)(?:\.[0-9a-f]+)?\b/i,
        punctuation: /[{}[\];(),:=]|IL_[0-9A-Za-z]+/
    };
}

});

parcelRequire.register("eznHT", function(module, exports) {
"use strict";
module.exports = $a9b6b946e5613237$var$clojure;
$a9b6b946e5613237$var$clojure.displayName = "clojure";
$a9b6b946e5613237$var$clojure.aliases = [];
function $a9b6b946e5613237$var$clojure(Prism) {
    // Copied from https://github.com/jeluard/prism-clojure
    Prism.languages.clojure = {
        comment: {
            pattern: /;.*/,
            greedy: true
        },
        string: {
            pattern: /"(?:[^"\\]|\\.)*"/,
            greedy: true
        },
        char: /\\\w+/,
        symbol: {
            pattern: /(^|[\s()\[\]{},])::?[\w*+!?'<>=/.-]+/,
            lookbehind: true
        },
        keyword: {
            pattern: /(\()(?:-|->|->>|\.|\.\.|\*|\/|\+|<|<=|=|==|>|>=|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|cond|conj|cons|constantly|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|declare|def|def-|definline|definterface|defmacro|defmethod|defmulti|defn|defn-|defonce|defproject|defprotocol|defrecord|defstruct|deftype|deref|difference|disj|dissoc|distinct|do|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|fn|fnseq|for|frest|gensym|get|get-proxy-class|hash-map|hash-set|identical\?|identity|if|if-let|if-not|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|let|line-seq|list|list\*|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|monitor-enter|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|quote|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|recur|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|set!|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|throw|time|to-array|to-array-2d|tree-seq|true\?|try|union|up|update-proxy|val|vals|var|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[\s)]|$)/,
            lookbehind: true
        },
        boolean: /\b(?:false|nil|true)\b/,
        number: {
            pattern: /(^|[^\w$@])(?:\d+(?:[/.]\d+)?(?:e[+-]?\d+)?|0x[a-f0-9]+|[1-9]\d?r[a-z0-9]+)[lmn]?(?![\w$@])/i,
            lookbehind: true
        },
        function: {
            pattern: /((?:^|[^'])\()[\w*+!?'<>=/.-]+(?=[\s)]|$)/,
            lookbehind: true
        },
        operator: /[#@^`~]/,
        punctuation: /[{}\[\](),]/
    };
}

});

parcelRequire.register("bNqmj", function(module, exports) {
"use strict";
module.exports = $8968b7a217a2960a$var$cmake;
$8968b7a217a2960a$var$cmake.displayName = "cmake";
$8968b7a217a2960a$var$cmake.aliases = [];
function $8968b7a217a2960a$var$cmake(Prism) {
    Prism.languages.cmake = {
        comment: /#.*/,
        string: {
            pattern: /"(?:[^\\"]|\\.)*"/,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
                    inside: {
                        punctuation: /\$\{|\}/,
                        variable: /\w+/
                    }
                }
            }
        },
        variable: /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_(?:BINARY_DIR|DESCRIPTION|HOMEPAGE_URL|NAME|SOURCE_DIR|VERSION|VERSION_(?:MAJOR|MINOR|PATCH|TWEAK))|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE|XCODE_VERSION))\b/,
        property: /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|GLOBAL_KEYWORD|GLOBAL_PROJECT_TYPES|GLOBAL_ROOTNAMESPACE|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
        keyword: /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
        boolean: /\b(?:FALSE|OFF|ON|TRUE)\b/,
        namespace: /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
        operator: /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
        inserted: {
            pattern: /\b\w+::\w+\b/,
            alias: "class-name"
        },
        number: /\b\d+(?:\.\d+)*\b/,
        function: /\b[a-z_]\w*(?=\s*\()\b/i,
        punctuation: /[()>}]|\$[<{]/
    };
}

});

parcelRequire.register("ks1mO", function(module, exports) {
"use strict";
module.exports = $ee377ba12fa518c0$var$cobol;
$ee377ba12fa518c0$var$cobol.displayName = "cobol";
$ee377ba12fa518c0$var$cobol.aliases = [];
function $ee377ba12fa518c0$var$cobol(Prism) {
    Prism.languages.cobol = {
        comment: {
            pattern: /\*>.*|(^[ \t]*)\*.*/m,
            lookbehind: true,
            greedy: true
        },
        string: {
            pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
            greedy: true
        },
        level: {
            pattern: /(^[ \t]*)\d+\b/m,
            lookbehind: true,
            greedy: true,
            alias: "number"
        },
        "class-name": {
            // https://github.com/antlr/grammars-v4/blob/42edd5b687d183b5fa679e858a82297bd27141e7/cobol85/Cobol85.g4#L1015
            pattern: /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
            lookbehind: true,
            inside: {
                number: {
                    pattern: /(\()\d+/,
                    lookbehind: true
                },
                punctuation: /[()]/
            }
        },
        keyword: {
            pattern: /(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOTTOM|BOUNDS|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COL|COLLATING|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOL|EOP|EOS|ERASE|ERROR|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTION-POINTER|FUNCTIONNAME|GENERATE|GIVING|GLOBAL|GO|GOBACK|GRID|GROUP|HEADING|HIGH-VALUE|HIGH-VALUES|HIGHLIGHT|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINE-COUNTER|LINES|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOW-VALUE|LOW-VALUES|LOWER|LOWLIGHT|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|PORT|POSITION|POSITIVE|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|RD|READ|READER|REAL|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOTE|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|RESET|RETURN|RETURN-CODE|RETURNING|REVERSE-VIDEO|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TAPE|TASK|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYDDD|YYYYMMDD|ZERO-FILL|ZEROES|ZEROS)(?![\w-])/i,
            lookbehind: true
        },
        boolean: {
            pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i,
            lookbehind: true
        },
        number: {
            pattern: /(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
            lookbehind: true
        },
        operator: [
            /<>|[<>]=?|[=+*/&]/,
            {
                pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
                lookbehind: true
            }
        ],
        punctuation: /[.:,()]/
    };
}

});

parcelRequire.register("1ZTxl", function(module, exports) {
"use strict";
module.exports = $174691678b91b382$var$coffeescript;
$174691678b91b382$var$coffeescript.displayName = "coffeescript";
$174691678b91b382$var$coffeescript.aliases = [
    "coffee"
];
function $174691678b91b382$var$coffeescript(Prism1) {
    (function(Prism) {
        // Ignore comments starting with { to privilege string interpolation highlighting
        var comment = /#(?!\{).+/;
        var interpolation = {
            pattern: /#\{[^}]+\}/,
            alias: "variable"
        };
        Prism.languages.coffeescript = Prism.languages.extend("javascript", {
            comment: comment,
            string: [
                // Strings are multiline
                {
                    pattern: /'(?:\\[\s\S]|[^\\'])*'/,
                    greedy: true
                },
                {
                    // Strings are multiline
                    pattern: /"(?:\\[\s\S]|[^\\"])*"/,
                    greedy: true,
                    inside: {
                        interpolation: interpolation
                    }
                }
            ],
            keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
            "class-member": {
                pattern: /@(?!\d)\w+/,
                alias: "variable"
            }
        });
        Prism.languages.insertBefore("coffeescript", "comment", {
            "multiline-comment": {
                pattern: /###[\s\S]+?###/,
                alias: "comment"
            },
            // Block regexp can contain comments and interpolation
            "block-regex": {
                pattern: /\/{3}[\s\S]*?\/{3}/,
                alias: "regex",
                inside: {
                    comment: comment,
                    interpolation: interpolation
                }
            }
        });
        Prism.languages.insertBefore("coffeescript", "string", {
            "inline-javascript": {
                pattern: /`(?:\\[\s\S]|[^\\`])*`/,
                inside: {
                    delimiter: {
                        pattern: /^`|`$/,
                        alias: "punctuation"
                    },
                    script: {
                        pattern: /[\s\S]+/,
                        alias: "language-javascript",
                        inside: Prism.languages.javascript
                    }
                }
            },
            // Block strings
            "multiline-string": [
                {
                    pattern: /'''[\s\S]*?'''/,
                    greedy: true,
                    alias: "string"
                },
                {
                    pattern: /"""[\s\S]*?"""/,
                    greedy: true,
                    alias: "string",
                    inside: {
                        interpolation: interpolation
                    }
                }
            ]
        });
        Prism.languages.insertBefore("coffeescript", "keyword", {
            // Object property
            property: /(?!\d)\w+(?=\s*:(?!:))/
        });
        delete Prism.languages.coffeescript["template-string"];
        Prism.languages.coffee = Prism.languages.coffeescript;
    })(Prism1);
}

});

parcelRequire.register("ljEvW", function(module, exports) {
"use strict";
module.exports = $f84acc92d69b9556$var$concurnas;
$f84acc92d69b9556$var$concurnas.displayName = "concurnas";
$f84acc92d69b9556$var$concurnas.aliases = [
    "conc"
];
function $f84acc92d69b9556$var$concurnas(Prism) {
    Prism.languages.concurnas = {
        comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
            lookbehind: true,
            greedy: true
        },
        langext: {
            pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
            greedy: true,
            inside: {
                "class-name": /^\w+/,
                string: {
                    pattern: /(^\s*\|\|)[\s\S]+(?=\|\|$)/,
                    lookbehind: true
                },
                punctuation: /\|\|/
            }
        },
        function: {
            pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
            lookbehind: true
        },
        keyword: /\b(?:abstract|actor|also|annotation|assert|async|await|bool|boolean|break|byte|case|catch|changed|char|class|closed|constant|continue|def|default|del|double|elif|else|enum|every|extends|false|finally|float|for|from|global|gpudef|gpukernel|if|import|in|init|inject|int|lambda|local|long|loop|match|new|nodefault|null|of|onchange|open|out|override|package|parfor|parforsync|post|pre|private|protected|provide|provider|public|return|shared|short|single|size_t|sizeof|super|sync|this|throw|trait|trans|transient|true|try|typedef|unchecked|using|val|var|void|while|with)\b/,
        boolean: /\b(?:false|true)\b/,
        number: /\b0b[01][01_]*L?\b|\b0x(?:[\da-f_]*\.)?[\da-f_p+-]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfls]?/i,
        punctuation: /[{}[\];(),.:]/,
        operator: /<==|>==|=>|->|<-|<>|&==|&<>|\?:?|\.\?|\+\+|--|[-+*/=<>]=?|[!^~]|\b(?:and|as|band|bor|bxor|comp|is|isnot|mod|or)\b=?/,
        annotation: {
            pattern: /@(?:\w+:)?(?:\w+|\[[^\]]+\])?/,
            alias: "builtin"
        }
    };
    Prism.languages.insertBefore("concurnas", "langext", {
        "regex-literal": {
            pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                    lookbehind: true,
                    inside: Prism.languages.concurnas
                },
                regex: /[\s\S]+/
            }
        },
        "string-literal": {
            pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                    lookbehind: true,
                    inside: Prism.languages.concurnas
                },
                string: /[\s\S]+/
            }
        }
    });
    Prism.languages.conc = Prism.languages.concurnas;
}

});

parcelRequire.register("am5Uf", function(module, exports) {
"use strict";
module.exports = $78a08a4dfcbd93b8$var$coq;
$78a08a4dfcbd93b8$var$coq.displayName = "coq";
$78a08a4dfcbd93b8$var$coq.aliases = [];
function $78a08a4dfcbd93b8$var$coq(Prism1) {
    (function(Prism) {
        // https://github.com/coq/coq
        var commentSource = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source;
        for(var i = 0; i < 2; i++)commentSource = commentSource.replace(/<self>/g, function() {
            return commentSource;
        });
        commentSource = commentSource.replace(/<self>/g, "[]");
        Prism.languages.coq = {
            comment: RegExp(commentSource),
            string: {
                pattern: /"(?:[^"]|"")*"(?!")/,
                greedy: true
            },
            attribute: [
                {
                    pattern: RegExp(/#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(/<comment>/g, function() {
                        return commentSource;
                    })),
                    greedy: true,
                    alias: "attr-name",
                    inside: {
                        comment: RegExp(commentSource),
                        string: {
                            pattern: /"(?:[^"]|"")*"(?!")/,
                            greedy: true
                        },
                        operator: /=/,
                        punctuation: /^#\[|\]$|[,()]/
                    }
                },
                {
                    pattern: /\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
                    alias: "attr-name"
                }
            ],
            keyword: /\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\b/,
            number: /\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
            punct: {
                pattern: /@\{|\{\||\[=|:>/,
                alias: "punctuation"
            },
            operator: /\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
            punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
        };
    })(Prism1);
}

});

parcelRequire.register("ccC8d", function(module, exports) {
"use strict";

var $46l9U = parcelRequire("46l9U");
module.exports = $8e242f238e034cdf$var$crystal;
$8e242f238e034cdf$var$crystal.displayName = "crystal";
$8e242f238e034cdf$var$crystal.aliases = [];
function $8e242f238e034cdf$var$crystal(Prism1) {
    Prism1.register($46l9U);
    (function(Prism) {
        Prism.languages.crystal = Prism.languages.extend("ruby", {
            keyword: [
                /\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/,
                {
                    pattern: /(\.\s*)(?:is_a|responds_to)\?/,
                    lookbehind: true
                }
            ],
            number: /\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[\da-fA-F_]*[\da-fA-F]|(?:\d(?:[\d_]*\d)?)(?:\.[\d_]*\d)?(?:[eE][+-]?[\d_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/,
            operator: [
                /->/,
                Prism.languages.ruby.operator
            ],
            punctuation: /[(){}[\].,;\\]/
        });
        Prism.languages.insertBefore("crystal", "string-literal", {
            attribute: {
                pattern: /@\[.*?\]/,
                inside: {
                    delimiter: {
                        pattern: /^@\[|\]$/,
                        alias: "punctuation"
                    },
                    attribute: {
                        pattern: /^(\s*)\w+/,
                        lookbehind: true,
                        alias: "class-name"
                    },
                    args: {
                        pattern: /\S(?:[\s\S]*\S)?/,
                        inside: Prism.languages.crystal
                    }
                }
            },
            expansion: {
                pattern: /\{(?:\{.*?\}|%.*?%)\}/,
                inside: {
                    content: {
                        pattern: /^(\{.)[\s\S]+(?=.\}$)/,
                        lookbehind: true,
                        inside: Prism.languages.crystal
                    },
                    delimiter: {
                        pattern: /^\{[\{%]|[\}%]\}$/,
                        alias: "operator"
                    }
                }
            },
            char: {
                pattern: /'(?:[^\\\r\n]{1,2}|\\(?:.|u(?:[A-Fa-f0-9]{1,4}|\{[A-Fa-f0-9]{1,6}\})))'/,
                greedy: true
            }
        });
    })(Prism1);
}

});
parcelRequire.register("46l9U", function(module, exports) {
"use strict";
module.exports = $2fc822a4c882c7da$var$ruby;
$2fc822a4c882c7da$var$ruby.displayName = "ruby";
$2fc822a4c882c7da$var$ruby.aliases = [
    "rb"
];
function $2fc822a4c882c7da$var$ruby(Prism1) {
    (function(Prism) {
        Prism.languages.ruby = Prism.languages.extend("clike", {
            comment: {
                pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
                greedy: true
            },
            "class-name": {
                pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
                lookbehind: true,
                inside: {
                    punctuation: /[.\\]/
                }
            },
            keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
            operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
            punctuation: /[(){}[\].,;]/
        });
        Prism.languages.insertBefore("ruby", "operator", {
            "double-colon": {
                pattern: /::/,
                alias: "punctuation"
            }
        });
        var interpolation = {
            pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
            lookbehind: true,
            inside: {
                content: {
                    pattern: /^(#\{)[\s\S]+(?=\}$)/,
                    lookbehind: true,
                    inside: Prism.languages.ruby
                },
                delimiter: {
                    pattern: /^#\{|\}$/,
                    alias: "punctuation"
                }
            }
        };
        delete Prism.languages.ruby.function;
        var percentExpression = "(?:" + [
            /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
            /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
            /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
            /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
            /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
        ].join("|") + ")";
        var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
        Prism.languages.insertBefore("ruby", "keyword", {
            "regex-literal": [
                {
                    pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
                    greedy: true,
                    inside: {
                        interpolation: interpolation,
                        regex: /[\s\S]+/
                    }
                },
                {
                    pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
                    lookbehind: true,
                    greedy: true,
                    inside: {
                        interpolation: interpolation,
                        regex: /[\s\S]+/
                    }
                }
            ],
            variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
            symbol: [
                {
                    pattern: RegExp(/(^|[^:]):/.source + symbolName),
                    lookbehind: true,
                    greedy: true
                },
                {
                    pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
                    lookbehind: true,
                    greedy: true
                }
            ],
            "method-definition": {
                pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
                lookbehind: true,
                inside: {
                    function: /\b\w+$/,
                    keyword: /^self\b/,
                    "class-name": /^\w+/,
                    punctuation: /\./
                }
            }
        });
        Prism.languages.insertBefore("ruby", "string", {
            "string-literal": [
                {
                    pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
                    greedy: true,
                    inside: {
                        interpolation: interpolation,
                        string: /[\s\S]+/
                    }
                },
                {
                    pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
                    greedy: true,
                    inside: {
                        interpolation: interpolation,
                        string: /[\s\S]+/
                    }
                },
                {
                    pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
                    alias: "heredoc-string",
                    greedy: true,
                    inside: {
                        delimiter: {
                            pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
                            inside: {
                                symbol: /\b\w+/,
                                punctuation: /^<<[-~]?/
                            }
                        },
                        interpolation: interpolation,
                        string: /[\s\S]+/
                    }
                },
                {
                    pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
                    alias: "heredoc-string",
                    greedy: true,
                    inside: {
                        delimiter: {
                            pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
                            inside: {
                                symbol: /\b\w+/,
                                punctuation: /^<<[-~]?'|'$/
                            }
                        },
                        string: /[\s\S]+/
                    }
                }
            ],
            "command-literal": [
                {
                    pattern: RegExp(/%x/.source + percentExpression),
                    greedy: true,
                    inside: {
                        interpolation: interpolation,
                        command: {
                            pattern: /[\s\S]+/,
                            alias: "string"
                        }
                    }
                },
                {
                    pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
                    greedy: true,
                    inside: {
                        interpolation: interpolation,
                        command: {
                            pattern: /[\s\S]+/,
                            alias: "string"
                        }
                    }
                }
            ]
        });
        delete Prism.languages.ruby.string;
        Prism.languages.insertBefore("ruby", "number", {
            builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
            constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
        });
        Prism.languages.rb = Prism.languages.ruby;
    })(Prism1);
}

});


parcelRequire.register("lRSwv", function(module, exports) {
"use strict";

var $jcO3t = parcelRequire("jcO3t");
module.exports = $feb8d7669e0f911e$var$cshtml;
$feb8d7669e0f911e$var$cshtml.displayName = "cshtml";
$feb8d7669e0f911e$var$cshtml.aliases = [
    "razor"
];
function $feb8d7669e0f911e$var$cshtml(Prism1) {
    Prism1.register($jcO3t);
    (function(Prism) {
        var commentLike = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source;
        var stringLike = /@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source + "|" + /'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
        /**
     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.
     *
     * @param {string} pattern
     * @param {number} depthLog2
     * @returns {string}
     */ function nested(pattern, depthLog2) {
            for(var i = 0; i < depthLog2; i++)pattern = pattern.replace(/<self>/g, function() {
                return "(?:" + pattern + ")";
            });
            return pattern.replace(/<self>/g, "[^\\s\\S]").replace(/<str>/g, "(?:" + stringLike + ")").replace(/<comment>/g, "(?:" + commentLike + ")");
        }
        var round = nested(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2);
        var square = nested(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 2);
        var curly = nested(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2);
        var angle = nested(/<(?:[^<>'"@/]|<str>|<comment>|<self>)*>/.source, 2) // Note about the above bracket patterns:
        ;
        // They all ignore HTML expressions that might be in the C# code. This is a problem because HTML (like strings and
        // comments) is parsed differently. This is a huge problem because HTML might contain brackets and quotes which
        // messes up the bracket and string counting implemented by the above patterns.
        //
        // This problem is not fixable because 1) HTML expression are highly context sensitive and very difficult to detect
        // and 2) they require one capturing group at every nested level. See the `tagRegion` pattern to admire the
        // complexity of an HTML expression.
        //
        // To somewhat alleviate the problem a bit, the patterns for characters (e.g. 'a') is very permissive, it also
        // allows invalid characters to support HTML expressions like this: <p>That's it!</p>.
        var tagAttrs = /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?/.source;
        var tagContent = /(?!\d)[^\s>\/=$<%]+/.source + tagAttrs + /\s*\/?>/.source;
        var tagRegion = /\B@?/.source + "(?:" + /<([a-zA-Z][\w:]*)/.source + tagAttrs + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // eslint-disable-next-line regexp/strict
        /<\/?(?!\1\b)/.source + tagContent + "|" + nested(// eslint-disable-next-line regexp/strict
        /<\1/.source + tagAttrs + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // eslint-disable-next-line regexp/strict
        /<\/?(?!\1\b)/.source + tagContent + "|" + "<self>") + ")*" + /<\/\1\s*>/.source, 2)) + ")*" + /<\/\1\s*>/.source + "|" + /</.source + tagContent + ")" // Now for the actual language definition(s):
        ;
        //
        // Razor as a language has 2 parts:
        //  1) CSHTML: A markup-like language that has been extended with inline C# code expressions and blocks.
        //  2) C#+HTML: A variant of C# that can contain CSHTML tags as expressions.
        //
        // In the below code, both CSHTML and C#+HTML will be create as separate language definitions that reference each
        // other. However, only CSHTML will be exported via `Prism.languages`.
        Prism.languages.cshtml = Prism.languages.extend("markup", {});
        var csharpWithHtml = Prism.languages.insertBefore("csharp", "string", {
            html: {
                pattern: RegExp(tagRegion),
                greedy: true,
                inside: Prism.languages.cshtml
            }
        }, {
            csharp: Prism.languages.extend("csharp", {})
        });
        var cs = {
            pattern: /\S[\s\S]*/,
            alias: "language-csharp",
            inside: csharpWithHtml
        };
        Prism.languages.insertBefore("cshtml", "prolog", {
            "razor-comment": {
                pattern: /@\*[\s\S]*?\*@/,
                greedy: true,
                alias: "comment"
            },
            block: {
                pattern: RegExp(/(^|[^@])@/.source + "(?:" + [
                    // @{ ... }
                    curly,
                    /(?:code|functions)\s*/.source + curly,
                    /(?:for|foreach|lock|switch|using|while)\s*/.source + round + /\s*/.source + curly,
                    /do\s*/.source + curly + /\s*while\s*/.source + round + /(?:\s*;)?/.source,
                    /try\s*/.source + curly + /\s*catch\s*/.source + round + /\s*/.source + curly + /\s*finally\s*/.source + curly,
                    /if\s*/.source + round + /\s*/.source + curly + "(?:" + /\s*else/.source + "(?:" + /\s+if\s*/.source + round + ")?" + /\s*/.source + curly + ")*"
                ].join("|") + ")"),
                lookbehind: true,
                greedy: true,
                inside: {
                    keyword: /^@\w*/,
                    csharp: cs
                }
            },
            directive: {
                pattern: /^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
                lookbehind: true,
                greedy: true,
                inside: {
                    keyword: /^@\w+/,
                    csharp: cs
                }
            },
            value: {
                pattern: RegExp(/(^|[^@])@/.source + /(?:await\b\s*)?/.source + "(?:" + /\w+\b/.source + "|" + round + ")" + "(?:" + /[?!]?\.\w+\b/.source + "|" + round + "|" + square + "|" + angle + round + ")*"),
                lookbehind: true,
                greedy: true,
                alias: "variable",
                inside: {
                    keyword: /^@/,
                    csharp: cs
                }
            },
            "delegate-operator": {
                pattern: /(^|[^@])@(?=<)/,
                lookbehind: true,
                alias: "operator"
            }
        });
        Prism.languages.razor = Prism.languages.cshtml;
    })(Prism1);
}

});

parcelRequire.register("9fBX5", function(module, exports) {
"use strict";
module.exports = $6bc2f43ec55c1d87$var$csp;
$6bc2f43ec55c1d87$var$csp.displayName = "csp";
$6bc2f43ec55c1d87$var$csp.aliases = [];
function $6bc2f43ec55c1d87$var$csp(Prism1) {
    (function(Prism) {
        /**
     * @param {string} source
     * @returns {RegExp}
     */ function value(source) {
            return RegExp(/([ \t])/.source + "(?:" + source + ")" + /(?=[\s;]|$)/.source, "i");
        }
        Prism.languages.csp = {
            directive: {
                pattern: /(^|[\s;])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[\s;]|$)/i,
                lookbehind: true,
                alias: "property"
            },
            scheme: {
                pattern: value(/[a-z][a-z0-9.+-]*:/.source),
                lookbehind: true
            },
            none: {
                pattern: value(/'none'/.source),
                lookbehind: true,
                alias: "keyword"
            },
            nonce: {
                pattern: value(/'nonce-[-+/\w=]+'/.source),
                lookbehind: true,
                alias: "number"
            },
            hash: {
                pattern: value(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
                lookbehind: true,
                alias: "number"
            },
            host: {
                pattern: value(/[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source + "|" + /\*[^\s;,']*/.source + "|" + /[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source),
                lookbehind: true,
                alias: "url",
                inside: {
                    important: /\*/
                }
            },
            keyword: [
                {
                    pattern: value(/'unsafe-[a-z-]+'/.source),
                    lookbehind: true,
                    alias: "unsafe"
                },
                {
                    pattern: value(/'[a-z-]+'/.source),
                    lookbehind: true,
                    alias: "safe"
                }
            ],
            punctuation: /;/
        };
    })(Prism1);
}

});

parcelRequire.register("lcjlB", function(module, exports) {
"use strict";
module.exports = $f6e9b9f7e22fc61e$var$cssExtras;
$f6e9b9f7e22fc61e$var$cssExtras.displayName = "cssExtras";
$f6e9b9f7e22fc61e$var$cssExtras.aliases = [];
function $f6e9b9f7e22fc61e$var$cssExtras(Prism1) {
    (function(Prism) {
        var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
        var selectorInside;
        Prism.languages.css.selector = {
            pattern: Prism.languages.css.selector.pattern,
            lookbehind: true,
            inside: selectorInside = {
                "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
                "pseudo-class": /:[-\w]+/,
                class: /\.[-\w]+/,
                id: /#[-\w]+/,
                attribute: {
                    pattern: RegExp("\\[(?:[^[\\]\"']|" + string.source + ")*\\]"),
                    greedy: true,
                    inside: {
                        punctuation: /^\[|\]$/,
                        "case-sensitivity": {
                            pattern: /(\s)[si]$/i,
                            lookbehind: true,
                            alias: "keyword"
                        },
                        namespace: {
                            pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
                            lookbehind: true,
                            inside: {
                                punctuation: /\|$/
                            }
                        },
                        "attr-name": {
                            pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
                            lookbehind: true
                        },
                        "attr-value": [
                            string,
                            {
                                pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
                                lookbehind: true
                            }
                        ],
                        operator: /[|~*^$]?=/
                    }
                },
                "n-th": [
                    {
                        pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
                        lookbehind: true,
                        inside: {
                            number: /[\dn]+/,
                            operator: /[+-]/
                        }
                    },
                    {
                        pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
                        lookbehind: true
                    }
                ],
                combinator: />|\+|~|\|\|/,
                // the `tag` token has been existed and removed.
                // because we can't find a perfect tokenize to match it.
                // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
                punctuation: /[(),]/
            }
        };
        Prism.languages.css["atrule"].inside["selector-function-argument"].inside = selectorInside;
        Prism.languages.insertBefore("css", "property", {
            variable: {
                pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
                lookbehind: true
            }
        });
        var unit = {
            pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
            lookbehind: true
        } // 123 -123 .123 -.123 12.3 -12.3
        ;
        var number = {
            pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
            lookbehind: true
        };
        Prism.languages.insertBefore("css", "function", {
            operator: {
                pattern: /(\s)[+\-*\/](?=\s)/,
                lookbehind: true
            },
            // CAREFUL!
            // Previewers and Inline color use hexcode and color.
            hexcode: {
                pattern: /\B#[\da-f]{3,8}\b/i,
                alias: "color"
            },
            color: [
                {
                    pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
                    lookbehind: true
                },
                {
                    pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
                    inside: {
                        unit: unit,
                        number: number,
                        function: /[\w-]+(?=\()/,
                        punctuation: /[(),]/
                    }
                }
            ],
            // it's important that there is no boundary assertion after the hex digits
            entity: /\\[\da-f]{1,8}/i,
            unit: unit,
            number: number
        });
    })(Prism1);
}

});

parcelRequire.register("j3wdq", function(module, exports) {
"use strict";
module.exports = $ddf749750b6545d7$var$csv;
$ddf749750b6545d7$var$csv.displayName = "csv";
$ddf749750b6545d7$var$csv.aliases = [];
function $ddf749750b6545d7$var$csv(Prism) {
    // https://tools.ietf.org/html/rfc4180
    Prism.languages.csv = {
        value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
        punctuation: /,/
    };
}

});

parcelRequire.register("bF7f6", function(module, exports) {
"use strict";
module.exports = $87d924467aa3ccaa$var$cypher;
$87d924467aa3ccaa$var$cypher.displayName = "cypher";
$87d924467aa3ccaa$var$cypher.aliases = [];
function $87d924467aa3ccaa$var$cypher(Prism) {
    Prism.languages.cypher = {
        // https://neo4j.com/docs/cypher-manual/current/syntax/comments/
        comment: /\/\/.*/,
        string: {
            pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/,
            greedy: true
        },
        "class-name": {
            pattern: /(:\s*)(?:\w+|`(?:[^`\\\r\n])*`)(?=\s*[{):])/,
            lookbehind: true,
            greedy: true
        },
        relationship: {
            pattern: /(-\[\s*(?:\w+\s*|`(?:[^`\\\r\n])*`\s*)?:\s*|\|\s*:\s*)(?:\w+|`(?:[^`\\\r\n])*`)/,
            lookbehind: true,
            greedy: true,
            alias: "property"
        },
        identifier: {
            pattern: /`(?:[^`\\\r\n])*`/,
            greedy: true
        },
        variable: /\$\w+/,
        // https://neo4j.com/docs/cypher-manual/current/syntax/reserved/
        keyword: /\b(?:ADD|ALL|AND|AS|ASC|ASCENDING|ASSERT|BY|CALL|CASE|COMMIT|CONSTRAINT|CONTAINS|CREATE|CSV|DELETE|DESC|DESCENDING|DETACH|DISTINCT|DO|DROP|ELSE|END|ENDS|EXISTS|FOR|FOREACH|IN|INDEX|IS|JOIN|KEY|LIMIT|LOAD|MANDATORY|MATCH|MERGE|NODE|NOT|OF|ON|OPTIONAL|OR|ORDER(?=\s+BY)|PERIODIC|REMOVE|REQUIRE|RETURN|SCALAR|SCAN|SET|SKIP|START|STARTS|THEN|UNION|UNIQUE|UNWIND|USING|WHEN|WHERE|WITH|XOR|YIELD)\b/i,
        function: /\b\w+\b(?=\s*\()/,
        boolean: /\b(?:false|null|true)\b/i,
        number: /\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
        // https://neo4j.com/docs/cypher-manual/current/syntax/operators/
        operator: /:|<--?|--?>?|<>|=~?|[<>]=?|[+*/%^|]|\.\.\.?/,
        punctuation: /[()[\]{},;.]/
    };
}

});

parcelRequire.register("do4FZ", function(module, exports) {
"use strict";
module.exports = $9bf124e297d24b85$var$d;
$9bf124e297d24b85$var$d.displayName = "d";
$9bf124e297d24b85$var$d.aliases = [];
function $9bf124e297d24b85$var$d(Prism) {
    Prism.languages.d = Prism.languages.extend("clike", {
        comment: [
            {
                // Shebang
                pattern: /^\s*#!.+/,
                greedy: true
            },
            {
                pattern: RegExp(/(^|[^\\])/.source + "(?:" + [
                    // /+ comment +/
                    // Allow one level of nesting
                    /\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source,
                    /\/\/.*/.source,
                    /\/\*[\s\S]*?\*\//.source
                ].join("|") + ")"),
                lookbehind: true,
                greedy: true
            }
        ],
        string: [
            {
                pattern: RegExp([
                    // r"", x""
                    /\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source,
                    /\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source,
                    // ...
                    // IDENT"
                    /\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source,
                    // eslint-disable-next-line regexp/strict
                    /\bq"(.)[\s\S]*?\2"/.source,
                    /(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
                ].join("|"), "m"),
                greedy: true
            },
            {
                pattern: /\bq\{(?:\{[^{}]*\}|[^{}])*\}/,
                greedy: true,
                alias: "token-string"
            }
        ],
        // In order: $, keywords and special tokens, globally defined symbols
        keyword: /\$|\b(?:__(?:(?:DATE|EOF|FILE|FUNCTION|LINE|MODULE|PRETTY_FUNCTION|TIMESTAMP|TIME|VENDOR|VERSION)__|gshared|parameters|traits|vector)|abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|dstring|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|ptrdiff_t|public|pure|real|ref|return|scope|shared|short|size_t|static|string|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|wstring)\b/,
        number: [
            // The lookbehind and the negative look-ahead try to prevent bad highlighting of the .. operator
            // Hexadecimal numbers must be handled separately to avoid problems with exponent "e"
            /\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]{0,4}/i,
            {
                pattern: /((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]{0,4}/i,
                lookbehind: true
            }
        ],
        operator: /\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
    });
    Prism.languages.insertBefore("d", "string", {
        // Characters
        // 'a', '\\', '\n', '\xFF', '\377', '\uFFFF', '\U0010FFFF', '\quot'
        char: /'(?:\\(?:\W|\w+)|[^\\])'/
    });
    Prism.languages.insertBefore("d", "keyword", {
        property: /\B@\w*/
    });
    Prism.languages.insertBefore("d", "function", {
        register: {
            // Iasm registers
            pattern: /\b(?:[ABCD][LHX]|E?(?:BP|DI|SI|SP)|[BS]PL|[ECSDGF]S|CR[0234]|[DS]IL|DR[012367]|E[ABCD]X|X?MM[0-7]|R(?:1[0-5]|[89])[BWD]?|R[ABCD]X|R[BS]P|R[DS]I|TR[3-7]|XMM(?:1[0-5]|[89])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
            alias: "variable"
        }
    });
}

});

parcelRequire.register("fyYUS", function(module, exports) {
"use strict";
module.exports = $b54948bb3c4b9487$var$dart;
$b54948bb3c4b9487$var$dart.displayName = "dart";
$b54948bb3c4b9487$var$dart.aliases = [];
function $b54948bb3c4b9487$var$dart(Prism1) {
    (function(Prism) {
        var keywords = [
            /\b(?:async|sync|yield)\*/,
            /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/
        ] // Handles named imports, such as http.Client
        ;
        var packagePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source // based on the dart naming conventions
        ;
        var className = {
            pattern: RegExp(packagePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
            lookbehind: true,
            inside: {
                namespace: {
                    pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
                    inside: {
                        punctuation: /\./
                    }
                }
            }
        };
        Prism.languages.dart = Prism.languages.extend("clike", {
            "class-name": [
                className,
                {
                    // variables and parameters
                    // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
                    pattern: RegExp(packagePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),
                    lookbehind: true,
                    inside: className.inside
                }
            ],
            keyword: keywords,
            operator: /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
        });
        Prism.languages.insertBefore("dart", "string", {
            "string-literal": {
                pattern: /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
                greedy: true,
                inside: {
                    interpolation: {
                        pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
                        lookbehind: true,
                        inside: {
                            punctuation: /^\$\{?|\}$/,
                            expression: {
                                pattern: /[\s\S]+/,
                                inside: Prism.languages.dart
                            }
                        }
                    },
                    string: /[\s\S]+/
                }
            },
            string: undefined
        });
        Prism.languages.insertBefore("dart", "class-name", {
            metadata: {
                pattern: /@\w+/,
                alias: "function"
            }
        });
        Prism.languages.insertBefore("dart", "class-name", {
            generics: {
                pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
                inside: {
                    "class-name": className,
                    keyword: keywords,
                    punctuation: /[<>(),.:]/,
                    operator: /[?&|]/
                }
            }
        });
    })(Prism1);
}

});

parcelRequire.register("lLIBf", function(module, exports) {
"use strict";
module.exports = $fd909552b2beace1$var$dataweave;
$fd909552b2beace1$var$dataweave.displayName = "dataweave";
$fd909552b2beace1$var$dataweave.aliases = [];
function $fd909552b2beace1$var$dataweave(Prism1) {
    (function(Prism) {
        Prism.languages.dataweave = {
            url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
            property: {
                pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
                greedy: true
            },
            string: {
                pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
                greedy: true
            },
            "mime-type": /\b(?:application|audio|image|multipart|text|video)\/[\w+-]+/,
            date: {
                pattern: /\|[\w:+-]+\|/,
                greedy: true
            },
            comment: [
                {
                    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                    lookbehind: true,
                    greedy: true
                },
                {
                    pattern: /(^|[^\\:])\/\/.*/,
                    lookbehind: true,
                    greedy: true
                }
            ],
            regex: {
                pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//,
                greedy: true
            },
            keyword: /\b(?:and|as|at|case|do|else|fun|if|input|is|match|not|ns|null|or|output|type|unless|update|using|var)\b/,
            function: /\b[A-Z_]\w*(?=\s*\()/i,
            number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
            punctuation: /[{}[\];(),.:@]/,
            operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
            boolean: /\b(?:false|true)\b/
        };
    })(Prism1);
}

});

parcelRequire.register("5Al2z", function(module, exports) {
"use strict";
module.exports = $4110a2bb074b1456$var$dax;
$4110a2bb074b1456$var$dax.displayName = "dax";
$4110a2bb074b1456$var$dax.aliases = [];
function $4110a2bb074b1456$var$dax(Prism) {
    Prism.languages.dax = {
        comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/).*)/,
            lookbehind: true
        },
        "data-field": {
            pattern: /'(?:[^']|'')*'(?!')(?:\[[ \w\xA0-\uFFFF]+\])?|\w+\[[ \w\xA0-\uFFFF]+\]/,
            alias: "symbol"
        },
        measure: {
            pattern: /\[[ \w\xA0-\uFFFF]+\]/,
            alias: "constant"
        },
        string: {
            pattern: /"(?:[^"]|"")*"(?!")/,
            greedy: true
        },
        function: /\b(?:ABS|ACOS|ACOSH|ACOT|ACOTH|ADDCOLUMNS|ADDMISSINGITEMS|ALL|ALLCROSSFILTERED|ALLEXCEPT|ALLNOBLANKROW|ALLSELECTED|AND|APPROXIMATEDISTINCTCOUNT|ASIN|ASINH|ATAN|ATANH|AVERAGE|AVERAGEA|AVERAGEX|BETA\.DIST|BETA\.INV|BLANK|CALCULATE|CALCULATETABLE|CALENDAR|CALENDARAUTO|CEILING|CHISQ\.DIST|CHISQ\.DIST\.RT|CHISQ\.INV|CHISQ\.INV\.RT|CLOSINGBALANCEMONTH|CLOSINGBALANCEQUARTER|CLOSINGBALANCEYEAR|COALESCE|COMBIN|COMBINA|COMBINEVALUES|CONCATENATE|CONCATENATEX|CONFIDENCE\.NORM|CONFIDENCE\.T|CONTAINS|CONTAINSROW|CONTAINSSTRING|CONTAINSSTRINGEXACT|CONVERT|COS|COSH|COT|COTH|COUNT|COUNTA|COUNTAX|COUNTBLANK|COUNTROWS|COUNTX|CROSSFILTER|CROSSJOIN|CURRENCY|CURRENTGROUP|CUSTOMDATA|DATATABLE|DATE|DATEADD|DATEDIFF|DATESBETWEEN|DATESINPERIOD|DATESMTD|DATESQTD|DATESYTD|DATEVALUE|DAY|DEGREES|DETAILROWS|DISTINCT|DISTINCTCOUNT|DISTINCTCOUNTNOBLANK|DIVIDE|EARLIER|EARLIEST|EDATE|ENDOFMONTH|ENDOFQUARTER|ENDOFYEAR|EOMONTH|ERROR|EVEN|EXACT|EXCEPT|EXP|EXPON\.DIST|FACT|FALSE|FILTER|FILTERS|FIND|FIRSTDATE|FIRSTNONBLANK|FIRSTNONBLANKVALUE|FIXED|FLOOR|FORMAT|GCD|GENERATE|GENERATEALL|GENERATESERIES|GEOMEAN|GEOMEANX|GROUPBY|HASONEFILTER|HASONEVALUE|HOUR|IF|IF\.EAGER|IFERROR|IGNORE|INT|INTERSECT|ISBLANK|ISCROSSFILTERED|ISEMPTY|ISERROR|ISEVEN|ISFILTERED|ISINSCOPE|ISLOGICAL|ISNONTEXT|ISNUMBER|ISO\.CEILING|ISODD|ISONORAFTER|ISSELECTEDMEASURE|ISSUBTOTAL|ISTEXT|KEEPFILTERS|KEYWORDMATCH|LASTDATE|LASTNONBLANK|LASTNONBLANKVALUE|LCM|LEFT|LEN|LN|LOG|LOG10|LOOKUPVALUE|LOWER|MAX|MAXA|MAXX|MEDIAN|MEDIANX|MID|MIN|MINA|MINUTE|MINX|MOD|MONTH|MROUND|NATURALINNERJOIN|NATURALLEFTOUTERJOIN|NEXTDAY|NEXTMONTH|NEXTQUARTER|NEXTYEAR|NONVISUAL|NORM\.DIST|NORM\.INV|NORM\.S\.DIST|NORM\.S\.INV|NOT|NOW|ODD|OPENINGBALANCEMONTH|OPENINGBALANCEQUARTER|OPENINGBALANCEYEAR|OR|PARALLELPERIOD|PATH|PATHCONTAINS|PATHITEM|PATHITEMREVERSE|PATHLENGTH|PERCENTILE\.EXC|PERCENTILE\.INC|PERCENTILEX\.EXC|PERCENTILEX\.INC|PERMUT|PI|POISSON\.DIST|POWER|PREVIOUSDAY|PREVIOUSMONTH|PREVIOUSQUARTER|PREVIOUSYEAR|PRODUCT|PRODUCTX|QUARTER|QUOTIENT|RADIANS|RAND|RANDBETWEEN|RANK\.EQ|RANKX|RELATED|RELATEDTABLE|REMOVEFILTERS|REPLACE|REPT|RIGHT|ROLLUP|ROLLUPADDISSUBTOTAL|ROLLUPGROUP|ROLLUPISSUBTOTAL|ROUND|ROUNDDOWN|ROUNDUP|ROW|SAMEPERIODLASTYEAR|SAMPLE|SEARCH|SECOND|SELECTCOLUMNS|SELECTEDMEASURE|SELECTEDMEASUREFORMATSTRING|SELECTEDMEASURENAME|SELECTEDVALUE|SIGN|SIN|SINH|SQRT|SQRTPI|STARTOFMONTH|STARTOFQUARTER|STARTOFYEAR|STDEV\.P|STDEV\.S|STDEVX\.P|STDEVX\.S|SUBSTITUTE|SUBSTITUTEWITHINDEX|SUM|SUMMARIZE|SUMMARIZECOLUMNS|SUMX|SWITCH|T\.DIST|T\.DIST\.2T|T\.DIST\.RT|T\.INV|T\.INV\.2T|TAN|TANH|TIME|TIMEVALUE|TODAY|TOPN|TOPNPERLEVEL|TOPNSKIP|TOTALMTD|TOTALQTD|TOTALYTD|TREATAS|TRIM|TRUE|TRUNC|UNICHAR|UNICODE|UNION|UPPER|USERELATIONSHIP|USERNAME|USEROBJECTID|USERPRINCIPALNAME|UTCNOW|UTCTODAY|VALUE|VALUES|VAR\.P|VAR\.S|VARX\.P|VARX\.S|WEEKDAY|WEEKNUM|XIRR|XNPV|YEAR|YEARFRAC)(?=\s*\()/i,
        keyword: /\b(?:DEFINE|EVALUATE|MEASURE|ORDER\s+BY|RETURN|VAR|START\s+AT|ASC|DESC)\b/i,
        boolean: {
            pattern: /\b(?:FALSE|NULL|TRUE)\b/i,
            alias: "constant"
        },
        number: /\b\d+(?:\.\d*)?|\B\.\d+\b/,
        operator: /:=|[-+*\/=^]|&&?|\|\||<(?:=>?|<|>)?|>[>=]?|\b(?:IN|NOT)\b/i,
        punctuation: /[;\[\](){}`,.]/
    };
}

});

parcelRequire.register("68APj", function(module, exports) {
"use strict";
module.exports = $47800e72676978b4$var$dhall;
$47800e72676978b4$var$dhall.displayName = "dhall";
$47800e72676978b4$var$dhall.aliases = [];
function $47800e72676978b4$var$dhall(Prism) {
    // ABNF grammar:
    // https://github.com/dhall-lang/dhall-lang/blob/master/standard/dhall.abnf
    Prism.languages.dhall = {
        // Multi-line comments can be nested. E.g. {- foo {- bar -} -}
        // The multi-line pattern is essentially this:
        //   \{-(?:[^-{]|-(?!\})|\{(?!-)|<SELF>)*-\}
        comment: /--.*|\{-(?:[^-{]|-(?!\})|\{(?!-)|\{-(?:[^-{]|-(?!\})|\{(?!-))*-\})*-\}/,
        string: {
            pattern: /"(?:[^"\\]|\\.)*"|''(?:[^']|'(?!')|'''|''\$\{)*''(?!'|\$)/,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: /\$\{[^{}]*\}/,
                    inside: {
                        expression: {
                            pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                            lookbehind: true,
                            alias: "language-dhall",
                            inside: null // see blow
                        },
                        punctuation: /\$\{|\}/
                    }
                }
            }
        },
        label: {
            pattern: /`[^`]*`/,
            greedy: true
        },
        url: {
            // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L596
            pattern: /\bhttps?:\/\/[\w.:%!$&'*+;=@~-]+(?:\/[\w.:%!$&'*+;=@~-]*)*(?:\?[/?\w.:%!$&'*+;=@~-]*)?/,
            greedy: true
        },
        env: {
            // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L661
            pattern: /\benv:(?:(?!\d)\w+|"(?:[^"\\=]|\\.)*")/,
            greedy: true,
            inside: {
                function: /^env/,
                operator: /^:/,
                variable: /[\s\S]+/
            }
        },
        hash: {
            // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L725
            pattern: /\bsha256:[\da-fA-F]{64}\b/,
            inside: {
                function: /sha256/,
                operator: /:/,
                number: /[\da-fA-F]{64}/
            }
        },
        // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L359
        keyword: /\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\b|\u2200/,
        builtin: /\b(?:None|Some)\b/,
        boolean: /\b(?:False|True)\b/,
        number: /\bNaN\b|-?\bInfinity\b|[+-]?\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/,
        operator: /\/\\|\/\/\\\\|&&|\|\||===|[!=]=|\/\/|->|\+\+|::|[+*#@=:?<>|\\\u2227\u2a53\u2261\u2afd\u03bb\u2192]/,
        punctuation: /\.\.|[{}\[\](),./]/,
        // we'll just assume that every capital word left is a type name
        "class-name": /\b[A-Z]\w*\b/
    };
    Prism.languages.dhall.string.inside.interpolation.inside.expression.inside = Prism.languages.dhall;
}

});

parcelRequire.register("8TwTj", function(module, exports) {
"use strict";
module.exports = $679cf94199c4bf0d$var$diff;
$679cf94199c4bf0d$var$diff.displayName = "diff";
$679cf94199c4bf0d$var$diff.aliases = [];
function $679cf94199c4bf0d$var$diff(Prism1) {
    (function(Prism) {
        Prism.languages.diff = {
            coord: [
                // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
                /^(?:\*{3}|-{3}|\+{3}).*$/m,
                /^@@.*@@$/m,
                /^\d.*$/m
            ] // deleted, inserted, unchanged, diff
        };
        /**
     * A map from the name of a block to its line prefix.
     *
     * @type {Object<string, string>}
     */ var PREFIXES = {
            "deleted-sign": "-",
            "deleted-arrow": "<",
            "inserted-sign": "+",
            "inserted-arrow": ">",
            unchanged: " ",
            diff: "!"
        } // add a token for each prefix
        ;
        Object.keys(PREFIXES).forEach(function(name) {
            var prefix = PREFIXES[name];
            var alias = [];
            if (!/^\w+$/.test(name)) // "deleted-sign" -> "deleted"
            alias.push(/\w+/.exec(name)[0]);
            if (name === "diff") alias.push("bold");
            Prism.languages.diff[name] = {
                pattern: RegExp("^(?:[" + prefix + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
                alias: alias,
                inside: {
                    line: {
                        pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
                        lookbehind: true
                    },
                    prefix: {
                        pattern: /[\s\S]/,
                        alias: /\w+/.exec(name)[0]
                    }
                }
            };
        }) // make prefixes available to Diff plugin
        ;
        Object.defineProperty(Prism.languages.diff, "PREFIXES", {
            value: PREFIXES
        });
    })(Prism1);
}

});

parcelRequire.register("hEhTx", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");
module.exports = $cd940da68d228d13$var$django;
$cd940da68d228d13$var$django.displayName = "django";
$cd940da68d228d13$var$django.aliases = [
    "jinja2"
];
function $cd940da68d228d13$var$django(Prism1) {
    Prism1.register($cekeD);
    (function(Prism) {
        Prism.languages.django = {
            comment: /^\{#[\s\S]*?#\}$/,
            tag: {
                pattern: /(^\{%[+-]?\s*)\w+/,
                lookbehind: true,
                alias: "keyword"
            },
            delimiter: {
                pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/,
                alias: "punctuation"
            },
            string: {
                pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
                greedy: true
            },
            filter: {
                pattern: /(\|)\w+/,
                lookbehind: true,
                alias: "function"
            },
            test: {
                pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
                lookbehind: true,
                alias: "function"
            },
            function: /\b[a-z_]\w+(?=\s*\()/i,
            keyword: /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
            operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
            number: /\b\d+(?:\.\d+)?\b/,
            boolean: /[Ff]alse|[Nn]one|[Tt]rue/,
            variable: /\b\w+\b/,
            punctuation: /[{}[\](),.:;]/
        };
        var pattern = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g;
        var markupTemplating = Prism.languages["markup-templating"];
        Prism.hooks.add("before-tokenize", function(env) {
            markupTemplating.buildPlaceholders(env, "django", pattern);
        });
        Prism.hooks.add("after-tokenize", function(env) {
            markupTemplating.tokenizePlaceholders(env, "django");
        }) // Add an Jinja2 alias
        ;
        Prism.languages.jinja2 = Prism.languages.django;
        Prism.hooks.add("before-tokenize", function(env) {
            markupTemplating.buildPlaceholders(env, "jinja2", pattern);
        });
        Prism.hooks.add("after-tokenize", function(env) {
            markupTemplating.tokenizePlaceholders(env, "jinja2");
        });
    })(Prism1);
}

});
parcelRequire.register("cekeD", function(module, exports) {
"use strict";
module.exports = $8e767d1bc6bb46f5$var$markupTemplating;
$8e767d1bc6bb46f5$var$markupTemplating.displayName = "markupTemplating";
$8e767d1bc6bb46f5$var$markupTemplating.aliases = [];
function $8e767d1bc6bb46f5$var$markupTemplating(Prism1) {
    (function(Prism) {
        /**
     * Returns the placeholder for the given language id and index.
     *
     * @param {string} language
     * @param {string|number} index
     * @returns {string}
     */ function getPlaceholder(language, index) {
            return "___" + language.toUpperCase() + index + "___";
        }
        Object.defineProperties(Prism.languages["markup-templating"] = {}, {
            buildPlaceholders: {
                /**
         * Tokenize all inline templating expressions matching `placeholderPattern`.
         *
         * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
         * `true` will be replaced.
         *
         * @param {object} env The environment of the `before-tokenize` hook.
         * @param {string} language The language id.
         * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
         * @param {(match: string) => boolean} [replaceFilter]
         */ value: function(env, language, placeholderPattern, replaceFilter) {
                    if (env.language !== language) return;
                    var tokenStack = env.tokenStack = [];
                    env.code = env.code.replace(placeholderPattern, function(match) {
                        if (typeof replaceFilter === "function" && !replaceFilter(match)) return match;
                        var i = tokenStack.length;
                        var placeholder // Check for existing strings
                        ;
                        while(env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1)++i;
                         // Create a sparse array
                        tokenStack[i] = match;
                        return placeholder;
                    }) // Switch the grammar to markup
                    ;
                    env.grammar = Prism.languages.markup;
                }
            },
            tokenizePlaceholders: {
                /**
         * Replace placeholders with proper tokens after tokenizing.
         *
         * @param {object} env The environment of the `after-tokenize` hook.
         * @param {string} language The language id.
         */ value: function(env, language) {
                    if (env.language !== language || !env.tokenStack) return;
                     // Switch the grammar back
                    env.grammar = Prism.languages[language];
                    var j = 0;
                    var keys = Object.keys(env.tokenStack);
                    function walkTokens(tokens) {
                        for(var i = 0; i < tokens.length; i++){
                            // all placeholders are replaced already
                            if (j >= keys.length) break;
                            var token = tokens[i];
                            if (typeof token === "string" || token.content && typeof token.content === "string") {
                                var k = keys[j];
                                var t = env.tokenStack[k];
                                var s = typeof token === "string" ? token : token.content;
                                var placeholder = getPlaceholder(language, k);
                                var index = s.indexOf(placeholder);
                                if (index > -1) {
                                    ++j;
                                    var before = s.substring(0, index);
                                    var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), "language-" + language, t);
                                    var after = s.substring(index + placeholder.length);
                                    var replacement = [];
                                    if (before) replacement.push.apply(replacement, walkTokens([
                                        before
                                    ]));
                                    replacement.push(middle);
                                    if (after) replacement.push.apply(replacement, walkTokens([
                                        after
                                    ]));
                                    if (typeof token === "string") tokens.splice.apply(tokens, [
                                        i,
                                        1
                                    ].concat(replacement));
                                    else token.content = replacement;
                                }
                            } else if (token.content) walkTokens(token.content);
                        }
                        return tokens;
                    }
                    walkTokens(env.tokens);
                }
            }
        });
    })(Prism1);
}

});


parcelRequire.register("6XDX9", function(module, exports) {
"use strict";
module.exports = $51173e99cfe83feb$var$dnsZoneFile;
$51173e99cfe83feb$var$dnsZoneFile.displayName = "dnsZoneFile";
$51173e99cfe83feb$var$dnsZoneFile.aliases = [];
function $51173e99cfe83feb$var$dnsZoneFile(Prism) {
    Prism.languages["dns-zone-file"] = {
        comment: /;.*/,
        string: {
            pattern: /"(?:\\.|[^"\\\r\n])*"/,
            greedy: true
        },
        variable: [
            {
                pattern: /(^\$ORIGIN[ \t]+)\S+/m,
                lookbehind: true
            },
            {
                pattern: /(^|\s)@(?=\s|$)/,
                lookbehind: true
            }
        ],
        keyword: /^\$(?:INCLUDE|ORIGIN|TTL)(?=\s|$)/m,
        class: {
            // https://tools.ietf.org/html/rfc1035#page-13
            pattern: /(^|\s)(?:CH|CS|HS|IN)(?=\s|$)/,
            lookbehind: true,
            alias: "keyword"
        },
        type: {
            // https://en.wikipedia.org/wiki/List_of_DNS_record_types
            pattern: /(^|\s)(?:A|A6|AAAA|AFSDB|APL|ATMA|CAA|CDNSKEY|CDS|CERT|CNAME|DHCID|DLV|DNAME|DNSKEY|DS|EID|GID|GPOS|HINFO|HIP|IPSECKEY|ISDN|KEY|KX|LOC|MAILA|MAILB|MB|MD|MF|MG|MINFO|MR|MX|NAPTR|NB|NBSTAT|NIMLOC|NINFO|NS|NSAP|NSAP-PTR|NSEC|NSEC3|NSEC3PARAM|NULL|NXT|OPENPGPKEY|PTR|PX|RKEY|RP|RRSIG|RT|SIG|SINK|SMIMEA|SOA|SPF|SRV|SSHFP|TA|TKEY|TLSA|TSIG|TXT|UID|UINFO|UNSPEC|URI|WKS|X25)(?=\s|$)/,
            lookbehind: true,
            alias: "keyword"
        },
        punctuation: /[()]/
    };
    Prism.languages["dns-zone"] = Prism.languages["dns-zone-file"];
}

});

parcelRequire.register("9ue9I", function(module, exports) {
"use strict";
module.exports = $01c849e4e87b5d78$var$docker;
$01c849e4e87b5d78$var$docker.displayName = "docker";
$01c849e4e87b5d78$var$docker.aliases = [
    "dockerfile"
];
function $01c849e4e87b5d78$var$docker(Prism1) {
    (function(Prism) {
        // Many of the following regexes will contain negated lookaheads like `[ \t]+(?![ \t])`. This is a trick to ensure
        // that quantifiers behave *atomically*. Atomic quantifiers are necessary to prevent exponential backtracking.
        var spaceAfterBackSlash = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source // At least one space, comment, or line break
        ;
        var space = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(/<SP_BS>/g, function() {
            return spaceAfterBackSlash;
        });
        var string = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source;
        var option = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(/<STR>/g, function() {
            return string;
        });
        var stringRule = {
            pattern: RegExp(string),
            greedy: true
        };
        var commentRule = {
            pattern: /(^[ \t]*)#.*/m,
            lookbehind: true,
            greedy: true
        };
        /**
     * @param {string} source
     * @param {string} flags
     * @returns {RegExp}
     */ function re(source, flags) {
            source = source.replace(/<OPT>/g, function() {
                return option;
            }).replace(/<SP>/g, function() {
                return space;
            });
            return RegExp(source, flags);
        }
        Prism.languages.docker = {
            instruction: {
                pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
                lookbehind: true,
                greedy: true,
                inside: {
                    options: {
                        pattern: re(/(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source, "i"),
                        lookbehind: true,
                        greedy: true,
                        inside: {
                            property: {
                                pattern: /(^|\s)--[\w-]+/,
                                lookbehind: true
                            },
                            string: [
                                stringRule,
                                {
                                    pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
                                    lookbehind: true
                                }
                            ],
                            operator: /\\$/m,
                            punctuation: /=/
                        }
                    },
                    keyword: [
                        {
                            // https://docs.docker.com/engine/reference/builder/#healthcheck
                            pattern: re(/(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source, "i"),
                            lookbehind: true,
                            greedy: true
                        },
                        {
                            // https://docs.docker.com/engine/reference/builder/#from
                            pattern: re(/(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source, "i"),
                            lookbehind: true,
                            greedy: true
                        },
                        {
                            // https://docs.docker.com/engine/reference/builder/#onbuild
                            pattern: re(/(^ONBUILD<SP>)\w+/.source, "i"),
                            lookbehind: true,
                            greedy: true
                        },
                        {
                            pattern: /^\w+/,
                            greedy: true
                        }
                    ],
                    comment: commentRule,
                    string: stringRule,
                    variable: /\$(?:\w+|\{[^{}"'\\]*\})/,
                    operator: /\\$/m
                }
            },
            comment: commentRule
        };
        Prism.languages.dockerfile = Prism.languages.docker;
    })(Prism1);
}

});

parcelRequire.register("eFvuO", function(module, exports) {
"use strict";
module.exports = $aadd537b5055118a$var$dot;
$aadd537b5055118a$var$dot.displayName = "dot";
$aadd537b5055118a$var$dot.aliases = [
    "gv"
];
function $aadd537b5055118a$var$dot(Prism1) {
    (function(Prism) {
        var ID = "(?:" + [
            // an identifier
            /[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
            /-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
            /"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
            /<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
        ].join("|") + ")";
        var IDInside = {
            markup: {
                pattern: /(^<)[\s\S]+(?=>$)/,
                lookbehind: true,
                alias: [
                    "language-markup",
                    "language-html",
                    "language-xml"
                ],
                inside: Prism.languages.markup
            }
        };
        /**
     * @param {string} source
     * @param {string} flags
     * @returns {RegExp}
     */ function withID(source, flags) {
            return RegExp(source.replace(/<ID>/g, function() {
                return ID;
            }), flags);
        }
        Prism.languages.dot = {
            comment: {
                pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
                greedy: true
            },
            "graph-name": {
                pattern: withID(/(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source, "i"),
                lookbehind: true,
                greedy: true,
                alias: "class-name",
                inside: IDInside
            },
            "attr-value": {
                pattern: withID(/(=[ \t\r\n]*)<ID>/.source),
                lookbehind: true,
                greedy: true,
                inside: IDInside
            },
            "attr-name": {
                pattern: withID(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
                lookbehind: true,
                greedy: true,
                inside: IDInside
            },
            keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
            "compass-point": {
                pattern: /(:[ \t\r\n]*)(?:[ewc_]|[ns][ew]?)(?![\w\x80-\uFFFF])/,
                lookbehind: true,
                alias: "builtin"
            },
            node: {
                pattern: withID(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
                lookbehind: true,
                greedy: true,
                inside: IDInside
            },
            operator: /[=:]|-[->]/,
            punctuation: /[\[\]{};,]/
        };
        Prism.languages.gv = Prism.languages.dot;
    })(Prism1);
}

});

parcelRequire.register("lXmhB", function(module, exports) {
"use strict";
module.exports = $ffc06498e3d29ef6$var$ebnf;
$ffc06498e3d29ef6$var$ebnf.displayName = "ebnf";
$ffc06498e3d29ef6$var$ebnf.aliases = [];
function $ffc06498e3d29ef6$var$ebnf(Prism) {
    Prism.languages.ebnf = {
        comment: /\(\*[\s\S]*?\*\)/,
        string: {
            pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
            greedy: true
        },
        special: {
            pattern: /\?[^?\r\n]*\?/,
            greedy: true,
            alias: "class-name"
        },
        definition: {
            pattern: /^([\t ]*)[a-z]\w*(?:[ \t]+[a-z]\w*)*(?=\s*=)/im,
            lookbehind: true,
            alias: [
                "rule",
                "keyword"
            ]
        },
        rule: /\b[a-z]\w*(?:[ \t]+[a-z]\w*)*\b/i,
        punctuation: /\([:/]|[:/]\)|[.,;()[\]{}]/,
        operator: /[-=|*/!]/
    };
}

});

parcelRequire.register("6jL0P", function(module, exports) {
"use strict";
module.exports = $4998fc1e735443e0$var$editorconfig;
$4998fc1e735443e0$var$editorconfig.displayName = "editorconfig";
$4998fc1e735443e0$var$editorconfig.aliases = [];
function $4998fc1e735443e0$var$editorconfig(Prism) {
    Prism.languages.editorconfig = {
        // https://editorconfig-specification.readthedocs.io
        comment: /[;#].*/,
        section: {
            pattern: /(^[ \t]*)\[.+\]/m,
            lookbehind: true,
            alias: "selector",
            inside: {
                regex: /\\\\[\[\]{},!?.*]/,
                // Escape special characters with '\\'
                operator: /[!?]|\.\.|\*{1,2}/,
                punctuation: /[\[\]{},]/
            }
        },
        key: {
            pattern: /(^[ \t]*)[^\s=]+(?=[ \t]*=)/m,
            lookbehind: true,
            alias: "attr-name"
        },
        value: {
            pattern: /=.*/,
            alias: "attr-value",
            inside: {
                punctuation: /^=/
            }
        }
    };
}

});

parcelRequire.register("l43Wf", function(module, exports) {
"use strict";
module.exports = $f55d06d0c0f2f4ca$var$eiffel;
$f55d06d0c0f2f4ca$var$eiffel.displayName = "eiffel";
$f55d06d0c0f2f4ca$var$eiffel.aliases = [];
function $f55d06d0c0f2f4ca$var$eiffel(Prism) {
    Prism.languages.eiffel = {
        comment: /--.*/,
        string: [
            // Aligned-verbatim-strings
            {
                pattern: /"([^[]*)\[[\s\S]*?\]\1"/,
                greedy: true
            },
            {
                pattern: /"([^{]*)\{[\s\S]*?\}\1"/,
                greedy: true
            },
            {
                pattern: /"(?:%(?:(?!\n)\s)*\n\s*%|%\S|[^%"\r\n])*"/,
                greedy: true
            }
        ],
        // normal char | special char | char code
        char: /'(?:%.|[^%'\r\n])+'/,
        keyword: /\b(?:across|agent|alias|all|and|as|assign|attached|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
        boolean: /\b(?:False|True)\b/i,
        // Convention: class-names are always all upper-case characters
        "class-name": /\b[A-Z][\dA-Z_]*\b/,
        number: [
            // hexa | octal | bin
            /\b0[xcb][\da-f](?:_*[\da-f])*\b/i,
            /(?:\b\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?e[+-]?)?\d(?:_*\d)*\b|\b\d(?:_*\d)*\b\.?/i
        ],
        punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
        operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
    };
}

});

parcelRequire.register("5P2FD", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");
module.exports = $43d3c97826c10def$var$ejs;
$43d3c97826c10def$var$ejs.displayName = "ejs";
$43d3c97826c10def$var$ejs.aliases = [
    "eta"
];
function $43d3c97826c10def$var$ejs(Prism1) {
    Prism1.register($cekeD);
    (function(Prism) {
        Prism.languages.ejs = {
            delimiter: {
                pattern: /^<%[-_=]?|[-_]?%>$/,
                alias: "punctuation"
            },
            comment: /^#[\s\S]*/,
            "language-javascript": {
                pattern: /[\s\S]+/,
                inside: Prism.languages.javascript
            }
        };
        Prism.hooks.add("before-tokenize", function(env) {
            var ejsPattern = /<%(?!%)[\s\S]+?%>/g;
            Prism.languages["markup-templating"].buildPlaceholders(env, "ejs", ejsPattern);
        });
        Prism.hooks.add("after-tokenize", function(env) {
            Prism.languages["markup-templating"].tokenizePlaceholders(env, "ejs");
        });
        Prism.languages.eta = Prism.languages.ejs;
    })(Prism1);
}

});

parcelRequire.register("aFA8R", function(module, exports) {
"use strict";
module.exports = $7c49c4bee85a5b69$var$elixir;
$7c49c4bee85a5b69$var$elixir.displayName = "elixir";
$7c49c4bee85a5b69$var$elixir.aliases = [];
function $7c49c4bee85a5b69$var$elixir(Prism) {
    Prism.languages.elixir = {
        doc: {
            pattern: /@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
            inside: {
                attribute: /^@\w+/,
                string: /['"][\s\S]+/
            }
        },
        comment: {
            pattern: /#.*/,
            greedy: true
        },
        // ~r"""foo""" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r"foo", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>
        regex: {
            pattern: /~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
            greedy: true
        },
        string: [
            {
                // ~s"""foo""" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s"foo", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>
                pattern: /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
                greedy: true,
                inside: {
                }
            },
            {
                pattern: /("""|''')[\s\S]*?\1/,
                greedy: true,
                inside: {
                }
            },
            {
                // Multi-line strings are allowed
                pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                greedy: true,
                inside: {
                }
            }
        ],
        atom: {
            // Look-behind prevents bad highlighting of the :: operator
            pattern: /(^|[^:]):\w+/,
            lookbehind: true,
            alias: "symbol"
        },
        module: {
            pattern: /\b[A-Z]\w*\b/,
            alias: "class-name"
        },
        // Look-ahead prevents bad highlighting of the :: operator
        "attr-name": /\b\w+\??:(?!:)/,
        argument: {
            // Look-behind prevents bad highlighting of the && operator
            pattern: /(^|[^&])&\d+/,
            lookbehind: true,
            alias: "variable"
        },
        attribute: {
            pattern: /@\w+/,
            alias: "variable"
        },
        function: /\b[_a-zA-Z]\w*[?!]?(?:(?=\s*(?:\.\s*)?\()|(?=\/\d))/,
        number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
        keyword: /\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\b/,
        boolean: /\b(?:false|nil|true)\b/,
        operator: [
            /\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,
            {
                // We don't want to match <<
                pattern: /([^<])<(?!<)/,
                lookbehind: true
            },
            {
                // We don't want to match >>
                pattern: /([^>])>(?!>)/,
                lookbehind: true
            }
        ],
        punctuation: /<<|>>|[.,%\[\]{}()]/
    };
    Prism.languages.elixir.string.forEach(function(o) {
        o.inside = {
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.elixir
                }
            }
        };
    });
}

});

parcelRequire.register("2Tmt4", function(module, exports) {
"use strict";
module.exports = $21b2257f8bb99824$var$elm;
$21b2257f8bb99824$var$elm.displayName = "elm";
$21b2257f8bb99824$var$elm.aliases = [];
function $21b2257f8bb99824$var$elm(Prism) {
    Prism.languages.elm = {
        comment: /--.*|\{-[\s\S]*?-\}/,
        char: {
            pattern: /'(?:[^\\'\r\n]|\\(?:[abfnrtv\\']|\d+|x[0-9a-fA-F]+|u\{[0-9a-fA-F]+\}))'/,
            greedy: true
        },
        string: [
            {
                // Multiline strings are wrapped in triple ". Quotes may appear unescaped.
                pattern: /"""[\s\S]*?"""/,
                greedy: true
            },
            {
                pattern: /"(?:[^\\"\r\n]|\\.)*"/,
                greedy: true
            }
        ],
        "import-statement": {
            // The imported or hidden names are not included in this import
            // statement. This is because we want to highlight those exactly like
            // we do for the names in the program.
            pattern: /(^[\t ]*)import\s+[A-Z]\w*(?:\.[A-Z]\w*)*(?:\s+as\s+(?:[A-Z]\w*)(?:\.[A-Z]\w*)*)?(?:\s+exposing\s+)?/m,
            lookbehind: true,
            inside: {
                keyword: /\b(?:as|exposing|import)\b/
            }
        },
        keyword: /\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\b/,
        // These are builtin variables only. Constructors are highlighted later as a constant.
        builtin: /\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\b/,
        // decimal integers and floating point numbers | hexadecimal integers
        number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[0-9a-f]+)\b/i,
        // Most of this is needed because of the meaning of a single '.'.
        // If it stands alone freely, it is the function composition.
        // It may also be a separator between a module name and an identifier => no
        // operator. If it comes together with other special characters it is an
        // operator too.
        // Valid operator characters in 0.18: +-/*=.$<>:&|^?%#@~!
        // Ref: https://groups.google.com/forum/#!msg/elm-dev/0AHSnDdkSkQ/E0SVU70JEQAJ
        operator: /\s\.\s|[+\-/*=.$<>:&|^?%#@~!]{2,}|[+\-/*=$<>:&|^?%#@~!]/,
        // In Elm, nearly everything is a variable, do not highlight these.
        hvariable: /\b(?:[A-Z]\w*\.)*[a-z]\w*\b/,
        constant: /\b(?:[A-Z]\w*\.)*[A-Z]\w*\b/,
        punctuation: /[{}[\]|(),.:]/
    };
}

});

parcelRequire.register("4nhIU", function(module, exports) {
"use strict";

var $46l9U = parcelRequire("46l9U");

var $cekeD = parcelRequire("cekeD");
module.exports = $32f70ee397dd5800$var$erb;
$32f70ee397dd5800$var$erb.displayName = "erb";
$32f70ee397dd5800$var$erb.aliases = [];
function $32f70ee397dd5800$var$erb(Prism1) {
    Prism1.register($46l9U);
    Prism1.register($cekeD);
    (function(Prism) {
        Prism.languages.erb = {
            delimiter: {
                pattern: /^(\s*)<%=?|%>(?=\s*$)/,
                lookbehind: true,
                alias: "punctuation"
            },
            ruby: {
                pattern: /\s*\S[\s\S]*/,
                alias: "language-ruby",
                inside: Prism.languages.ruby
            }
        };
        Prism.hooks.add("before-tokenize", function(env) {
            var erbPattern = /<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g;
            Prism.languages["markup-templating"].buildPlaceholders(env, "erb", erbPattern);
        });
        Prism.hooks.add("after-tokenize", function(env) {
            Prism.languages["markup-templating"].tokenizePlaceholders(env, "erb");
        });
    })(Prism1);
}

});

parcelRequire.register("4nIBi", function(module, exports) {
"use strict";
module.exports = $330be82b76f0a8e6$var$erlang;
$330be82b76f0a8e6$var$erlang.displayName = "erlang";
$330be82b76f0a8e6$var$erlang.aliases = [];
function $330be82b76f0a8e6$var$erlang(Prism) {
    Prism.languages.erlang = {
        comment: /%.+/,
        string: {
            pattern: /"(?:\\.|[^\\"\r\n])*"/,
            greedy: true
        },
        "quoted-function": {
            pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
            alias: "function"
        },
        "quoted-atom": {
            pattern: /'(?:\\.|[^\\'\r\n])+'/,
            alias: "atom"
        },
        boolean: /\b(?:false|true)\b/,
        keyword: /\b(?:after|case|catch|end|fun|if|of|receive|try|when)\b/,
        number: [
            /\$\\?./,
            /\b\d+#[a-z0-9]+/i,
            /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i
        ],
        function: /\b[a-z][\w@]*(?=\()/,
        variable: {
            // Look-behind is used to prevent wrong highlighting of atoms containing "@"
            pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
            lookbehind: true
        },
        operator: [
            /[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/,
            {
                // We don't want to match <<
                pattern: /(^|[^<])<(?!<)/,
                lookbehind: true
            },
            {
                // We don't want to match >>
                pattern: /(^|[^>])>(?!>)/,
                lookbehind: true
            }
        ],
        atom: /\b[a-z][\w@]*/,
        punctuation: /[()[\]{}:;,.#|]|<<|>>/
    };
}

});

parcelRequire.register("eiDOE", function(module, exports) {
"use strict";

var $1rmoN = parcelRequire("1rmoN");

var $cekeD = parcelRequire("cekeD");
module.exports = $a691a1c262cade0d$var$etlua;
$a691a1c262cade0d$var$etlua.displayName = "etlua";
$a691a1c262cade0d$var$etlua.aliases = [];
function $a691a1c262cade0d$var$etlua(Prism1) {
    Prism1.register($1rmoN);
    Prism1.register($cekeD);
    (function(Prism) {
        Prism.languages.etlua = {
            delimiter: {
                pattern: /^<%[-=]?|-?%>$/,
                alias: "punctuation"
            },
            "language-lua": {
                pattern: /[\s\S]+/,
                inside: Prism.languages.lua
            }
        };
        Prism.hooks.add("before-tokenize", function(env) {
            var pattern = /<%[\s\S]+?%>/g;
            Prism.languages["markup-templating"].buildPlaceholders(env, "etlua", pattern);
        });
        Prism.hooks.add("after-tokenize", function(env) {
            Prism.languages["markup-templating"].tokenizePlaceholders(env, "etlua");
        });
    })(Prism1);
}

});
parcelRequire.register("1rmoN", function(module, exports) {
"use strict";
module.exports = $10c9afffd8b788da$var$lua;
$10c9afffd8b788da$var$lua.displayName = "lua";
$10c9afffd8b788da$var$lua.aliases = [];
function $10c9afffd8b788da$var$lua(Prism) {
    Prism.languages.lua = {
        comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
        // \z may be used to skip the following space
        string: {
            pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
            greedy: true
        },
        number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
        keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
        function: /(?!\d)\w+(?=\s*(?:[({]))/,
        operator: [
            /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
            {
                // Match ".." but don't break "..."
                pattern: /(^|[^.])\.\.(?!\.)/,
                lookbehind: true
            }
        ],
        punctuation: /[\[\](){},;]|\.+|:+/
    };
}

});


parcelRequire.register("fwAI7", function(module, exports) {
"use strict";
module.exports = $b4d6521d5c4a20e2$var$excelFormula;
$b4d6521d5c4a20e2$var$excelFormula.displayName = "excelFormula";
$b4d6521d5c4a20e2$var$excelFormula.aliases = [];
function $b4d6521d5c4a20e2$var$excelFormula(Prism) {
    Prism.languages["excel-formula"] = {
        comment: {
            pattern: /(\bN\(\s*)"(?:[^"]|"")*"(?=\s*\))/i,
            lookbehind: true,
            greedy: true
        },
        string: {
            pattern: /"(?:[^"]|"")*"(?!")/,
            greedy: true
        },
        reference: {
            // https://www.ablebits.com/office-addins-blog/2015/12/08/excel-reference-another-sheet-workbook/
            // Sales!B2
            // 'Winter sales'!B2
            // [Sales.xlsx]Jan!B2:B5
            // D:\Reports\[Sales.xlsx]Jan!B2:B5
            // '[Sales.xlsx]Jan sales'!B2:B5
            // 'D:\Reports\[Sales.xlsx]Jan sales'!B2:B5
            pattern: /(?:'[^']*'|(?:[^\s()[\]{}<>*?"';,$&]*\[[^^\s()[\]{}<>*?"']+\])?\w+)!/,
            greedy: true,
            alias: "string",
            inside: {
                operator: /!$/,
                punctuation: /'/,
                sheet: {
                    pattern: /[^[\]]+$/,
                    alias: "function"
                },
                file: {
                    pattern: /\[[^[\]]+\]$/,
                    inside: {
                        punctuation: /[[\]]/
                    }
                },
                path: /[\s\S]+/
            }
        },
        "function-name": {
            pattern: /\b[A-Z]\w*(?=\()/i,
            alias: "keyword"
        },
        range: {
            pattern: /\$?\b(?:[A-Z]+\$?\d+:\$?[A-Z]+\$?\d+|[A-Z]+:\$?[A-Z]+|\d+:\$?\d+)\b/i,
            alias: "property",
            inside: {
                operator: /:/,
                cell: /\$?[A-Z]+\$?\d+/i,
                column: /\$?[A-Z]+/i,
                row: /\$?\d+/
            }
        },
        cell: {
            // Excel is case insensitive, so the string "foo1" could be either a variable or a cell.
            // To combat this, we match cells case insensitive, if the contain at least one "$", and case sensitive otherwise.
            pattern: /\b[A-Z]+\d+\b|\$[A-Za-z]+\$?\d+\b|\b[A-Za-z]+\$\d+\b/,
            alias: "property"
        },
        number: /(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?\b/i,
        boolean: /\b(?:FALSE|TRUE)\b/i,
        operator: /[-+*/^%=&,]|<[=>]?|>=?/,
        punctuation: /[[\]();{}|]/
    };
    Prism.languages["xlsx"] = Prism.languages["xls"] = Prism.languages["excel-formula"];
}

});

parcelRequire.register("i5zwz", function(module, exports) {
"use strict";
module.exports = $d2b4400804ec0772$var$factor;
$d2b4400804ec0772$var$factor.displayName = "factor";
$d2b4400804ec0772$var$factor.aliases = [];
function $d2b4400804ec0772$var$factor(Prism1) {
    (function(Prism) {
        var comment_inside = {
            function: /\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\?{2,}|!{2,})\b/
        };
        var string_inside = {
            number: /\\[^\s']|%\w/
        };
        var factor1 = {
            comment: [
                {
                    // ! single-line exclamation point comments with whitespace after/around the !
                    pattern: /(^|\s)(?:! .*|!$)/,
                    lookbehind: true,
                    inside: comment_inside
                },
                /* from basis/multiline: */ {
                    // /* comment */, /* comment*/
                    pattern: /(^|\s)\/\*\s[\s\S]*?\*\/(?=\s|$)/,
                    lookbehind: true,
                    greedy: true,
                    inside: comment_inside
                },
                {
                    // ![[ comment ]] , ![===[ comment]===]
                    pattern: /(^|\s)!\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
                    lookbehind: true,
                    greedy: true,
                    inside: comment_inside
                }
            ],
            number: [
                {
                    // basic base 10 integers 9, -9
                    pattern: /(^|\s)[+-]?\d+(?=\s|$)/,
                    lookbehind: true
                },
                {
                    // base prefix integers 0b010 0o70 0xad 0d10 0XAD -0xa9
                    pattern: /(^|\s)[+-]?0(?:b[01]+|o[0-7]+|d\d+|x[\dA-F]+)(?=\s|$)/i,
                    lookbehind: true
                },
                {
                    // fractional ratios 1/5 -1/5 and the literal float approximations 1/5. -1/5.
                    pattern: /(^|\s)[+-]?\d+\/\d+\.?(?=\s|$)/,
                    lookbehind: true
                },
                {
                    // positive mixed numbers 23+1/5 +23+1/5
                    pattern: /(^|\s)\+?\d+\+\d+\/\d+(?=\s|$)/,
                    lookbehind: true
                },
                {
                    // negative mixed numbers -23-1/5
                    pattern: /(^|\s)-\d+-\d+\/\d+(?=\s|$)/,
                    lookbehind: true
                },
                {
                    // basic decimal floats -0.01 0. .0 .1 -.1 -1. -12.13 +12.13
                    // and scientific notation with base 10 exponents 3e4 3e-4 .3e-4
                    pattern: /(^|\s)[+-]?(?:\d*\.\d+|\d+\.\d*|\d+)(?:e[+-]?\d+)?(?=\s|$)/i,
                    lookbehind: true
                },
                {
                    // NAN literal syntax NAN: 80000deadbeef, NAN: a
                    pattern: /(^|\s)NAN:\s+[\da-fA-F]+(?=\s|$)/,
                    lookbehind: true
                },
                {
                    /*
base prefix floats 0x1.0p3 (8.0) 0b1.010p2 (5.0) 0x1.p1 0b1.11111111p11111...
"The normalized hex form ±0x1.MMMMMMMMMMMMM[pP]±EEEE allows any floating-point number to be specified precisely.
The values of MMMMMMMMMMMMM and EEEE map directly to the mantissa and exponent fields of the binary IEEE 754 representation."
<https://docs.factorcode.org/content/article-syntax-floats.html>
*/ pattern: /(^|\s)[+-]?0(?:b1\.[01]*|o1\.[0-7]*|d1\.\d*|x1\.[\dA-F]*)p\d+(?=\s|$)/i,
                    lookbehind: true
                }
            ],
            // R/ regexp?\/\\/
            regexp: {
                pattern: /(^|\s)R\/\s(?:\\\S|[^\\/])*\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\s|$)/,
                lookbehind: true,
                alias: "number",
                inside: {
                    variable: /\\\S/,
                    keyword: /[+?*\[\]^$(){}.|]/,
                    operator: {
                        pattern: /(\/)[idmsr]+(?:-[idmsr]+)?/,
                        lookbehind: true
                    }
                }
            },
            boolean: {
                pattern: /(^|\s)[tf](?=\s|$)/,
                lookbehind: true
            },
            // SBUF" asd", URL" ://...", P" /etc/"
            "custom-string": {
                pattern: /(^|\s)[A-Z0-9\-]+"\s(?:\\\S|[^"\\])*"/,
                lookbehind: true,
                greedy: true,
                alias: "string",
                inside: {
                    number: /\\\S|%\w|\//
                }
            },
            "multiline-string": [
                {
                    // STRING: name \n content \n ; -> CONSTANT: name "content" (symbol)
                    pattern: /(^|\s)STRING:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*;(?=\s|$)/,
                    lookbehind: true,
                    greedy: true,
                    alias: "string",
                    inside: {
                        number: string_inside.number,
                        // trailing semicolon on its own line
                        "semicolon-or-setlocal": {
                            pattern: /([\r\n][ \t]*);(?=\s|$)/,
                            lookbehind: true,
                            alias: "function"
                        }
                    }
                },
                {
                    // HEREDOC: marker \n content \n marker ; -> "content" (immediate)
                    pattern: /(^|\s)HEREDOC:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*\S+(?=\s|$)/,
                    lookbehind: true,
                    greedy: true,
                    alias: "string",
                    inside: string_inside
                },
                {
                    // [[ string ]], [==[ string]==]
                    pattern: /(^|\s)\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
                    lookbehind: true,
                    greedy: true,
                    alias: "string",
                    inside: string_inside
                }
            ],
            "special-using": {
                pattern: /(^|\s)USING:(?:\s\S+)*(?=\s+;(?:\s|$))/,
                lookbehind: true,
                alias: "function",
                inside: {
                    // this is essentially a regex for vocab names, which i don't want to specify
                    // but the USING: gets picked up as a vocab name
                    string: {
                        pattern: /(\s)[^:\s]+/,
                        lookbehind: true
                    }
                }
            },
            /* this description of stack effect literal syntax is not complete and not as specific as theoretically possible
trying to do better is more work and regex-computation-time than it's worth though.
- we'd like to have the "delimiter" parts of the stack effect [ (, --, and ) ] be a different (less-important or comment-like) colour to the stack effect contents
- we'd like if nested stack effects were treated as such rather than just appearing flat (with `inside`)
- we'd like if the following variable name conventions were recognised specifically:
special row variables = ..a b..
type and stack effect annotations end with a colon = ( quot: ( a: ( -- ) -- b ) -- x ), ( x: number -- )
word throws unconditional error = *
any other word-like variable name = a ? q' etc
https://docs.factorcode.org/content/article-effects.html
these are pretty complicated to highlight properly without a real parser, and therefore out of scope
the old pattern, which may be later useful, was: (^|\s)(?:call|execute|eval)?\((?:\s+[^"\r\n\t ]\S*)*?\s+--(?:\s+[^"\n\t ]\S*)*?\s+\)(?=\s|$)
*/ // current solution is not great
            "stack-effect-delimiter": [
                {
                    // opening parenthesis
                    pattern: /(^|\s)(?:call|eval|execute)?\((?=\s)/,
                    lookbehind: true,
                    alias: "operator"
                },
                {
                    // middle --
                    pattern: /(\s)--(?=\s)/,
                    lookbehind: true,
                    alias: "operator"
                },
                {
                    // closing parenthesis
                    pattern: /(\s)\)(?=\s|$)/,
                    lookbehind: true,
                    alias: "operator"
                }
            ],
            combinators: {
                pattern: null,
                lookbehind: true,
                alias: "keyword"
            },
            "kernel-builtin": {
                pattern: null,
                lookbehind: true,
                alias: "variable"
            },
            "sequences-builtin": {
                pattern: null,
                lookbehind: true,
                alias: "variable"
            },
            "math-builtin": {
                pattern: null,
                lookbehind: true,
                alias: "variable"
            },
            "constructor-word": {
                // <array> but not <=>
                pattern: /(^|\s)<(?!=+>|-+>)\S+>(?=\s|$)/,
                lookbehind: true,
                alias: "keyword"
            },
            "other-builtin-syntax": {
                pattern: null,
                lookbehind: true,
                alias: "operator"
            },
            /*
full list of supported word naming conventions: (the convention appears outside of the [brackets])
set-[x]
change-[x]
with-[x]
new-[x]
>[string]
[base]>
[string]>[number]
+[symbol]+
[boolean-word]?
?[of]
[slot-reader]>>
>>[slot-setter]
[slot-writer]<<
([implementation-detail])
[mutater]!
[variant]*
[prettyprint].
$[help-markup]
<constructors>, SYNTAX:, etc are supported by their own patterns.
`with` and `new` from `kernel` are their own builtins.
see <https://docs.factorcode.org/content/article-conventions.html>
*/ "conventionally-named-word": {
                pattern: /(^|\s)(?!")(?:(?:change|new|set|with)-\S+|\$\S+|>[^>\s]+|[^:>\s]+>|[^>\s]+>[^>\s]+|\+[^+\s]+\+|[^?\s]+\?|\?[^?\s]+|[^>\s]+>>|>>[^>\s]+|[^<\s]+<<|\([^()\s]+\)|[^!\s]+!|[^*\s]\S*\*|[^.\s]\S*\.)(?=\s|$)/,
                lookbehind: true,
                alias: "keyword"
            },
            "colon-syntax": {
                pattern: /(^|\s)(?:[A-Z0-9\-]+#?)?:{1,2}\s+(?:;\S+|(?!;)\S+)(?=\s|$)/,
                lookbehind: true,
                greedy: true,
                alias: "function"
            },
            "semicolon-or-setlocal": {
                pattern: /(\s)(?:;|:>)(?=\s|$)/,
                lookbehind: true,
                alias: "function"
            },
            // do not highlight leading } or trailing X{ at the begin/end of the file as it's invalid syntax
            "curly-brace-literal-delimiter": [
                {
                    // opening
                    pattern: /(^|\s)[a-z]*\{(?=\s)/i,
                    lookbehind: true,
                    alias: "operator"
                },
                {
                    // closing
                    pattern: /(\s)\}(?=\s|$)/,
                    lookbehind: true,
                    alias: "operator"
                }
            ],
            // do not highlight leading ] or trailing [ at the begin/end of the file as it's invalid syntax
            "quotation-delimiter": [
                {
                    // opening
                    pattern: /(^|\s)\[(?=\s)/,
                    lookbehind: true,
                    alias: "operator"
                },
                {
                    // closing
                    pattern: /(\s)\](?=\s|$)/,
                    lookbehind: true,
                    alias: "operator"
                }
            ],
            "normal-word": {
                pattern: /(^|\s)[^"\s]\S*(?=\s|$)/,
                lookbehind: true
            },
            /*
basic first-class string "a"
with escaped double-quote "a\""
escaped backslash "\\"
and general escapes since Factor has so many "\N"
syntax that works in the reference implementation that isn't fully
supported because it's an implementation detail:
"string 1""string 2" -> 2 strings (works anyway)
"string"5 -> string, 5
"string"[ ] -> string, quotation
{ "a"} -> array<string>
the rest of those examples all properly recognise the string, but not
the other object (number, quotation, etc)
this is fine for a regex-only implementation.
*/ string: {
                pattern: /"(?:\\\S|[^"\\])*"/,
                greedy: true,
                inside: string_inside
            }
        };
        var escape = function(str) {
            return (str + "").replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
        };
        var arrToWordsRegExp = function(arr) {
            return new RegExp("(^|\\s)(?:" + arr.map(escape).join("|") + ")(?=\\s|$)");
        };
        var builtins = {
            "kernel-builtin": [
                "or",
                "2nipd",
                "4drop",
                "tuck",
                "wrapper",
                "nip",
                "wrapper?",
                "callstack>array",
                "die",
                "dupd",
                "callstack",
                "callstack?",
                "3dup",
                "hashcode",
                "pick",
                "4nip",
                "build",
                ">boolean",
                "nipd",
                "clone",
                "5nip",
                "eq?",
                "?",
                "=",
                "swapd",
                "2over",
                "clear",
                "2dup",
                "get-retainstack",
                "not",
                "tuple?",
                "dup",
                "3nipd",
                "call",
                "-rotd",
                "object",
                "drop",
                "assert=",
                "assert?",
                "-rot",
                "execute",
                "boa",
                "get-callstack",
                "curried?",
                "3drop",
                "pickd",
                "overd",
                "over",
                "roll",
                "3nip",
                "swap",
                "and",
                "2nip",
                "rotd",
                "throw",
                "(clone)",
                "hashcode*",
                "spin",
                "reach",
                "4dup",
                "equal?",
                "get-datastack",
                "assert",
                "2drop",
                "<wrapper>",
                "boolean?",
                "identity-hashcode",
                "identity-tuple?",
                "null",
                "composed?",
                "new",
                "5drop",
                "rot",
                "-roll",
                "xor",
                "identity-tuple",
                "boolean"
            ],
            "other-builtin-syntax": [
                // syntax
                "=======",
                "recursive",
                "flushable",
                ">>",
                "<<<<<<",
                "M\\",
                "B",
                "PRIVATE>",
                "\\",
                "======",
                "final",
                "inline",
                "delimiter",
                "deprecated",
                "<PRIVATE",
                ">>>>>>",
                "<<<<<<<",
                "parse-complex",
                "malformed-complex",
                "read-only",
                ">>>>>>>",
                "call-next-method",
                "<<",
                "foldable",
                "$",
                "$[",
                "${"
            ],
            "sequences-builtin": [
                "member-eq?",
                "mismatch",
                "append",
                "assert-sequence=",
                "longer",
                "repetition",
                "clone-like",
                "3sequence",
                "assert-sequence?",
                "last-index-from",
                "reversed",
                "index-from",
                "cut*",
                "pad-tail",
                "join-as",
                "remove-eq!",
                "concat-as",
                "but-last",
                "snip",
                "nths",
                "nth",
                "sequence",
                "longest",
                "slice?",
                "<slice>",
                "remove-nth",
                "tail-slice",
                "empty?",
                "tail*",
                "member?",
                "virtual-sequence?",
                "set-length",
                "drop-prefix",
                "iota",
                "unclip",
                "bounds-error?",
                "unclip-last-slice",
                "non-negative-integer-expected",
                "non-negative-integer-expected?",
                "midpoint@",
                "longer?",
                "?set-nth",
                "?first",
                "rest-slice",
                "prepend-as",
                "prepend",
                "fourth",
                "sift",
                "subseq-start",
                "new-sequence",
                "?last",
                "like",
                "first4",
                "1sequence",
                "reverse",
                "slice",
                "virtual@",
                "repetition?",
                "set-last",
                "index",
                "4sequence",
                "max-length",
                "set-second",
                "immutable-sequence",
                "first2",
                "first3",
                "supremum",
                "unclip-slice",
                "suffix!",
                "insert-nth",
                "tail",
                "3append",
                "short",
                "suffix",
                "concat",
                "flip",
                "immutable?",
                "reverse!",
                "2sequence",
                "sum",
                "delete-all",
                "indices",
                "snip-slice",
                "<iota>",
                "check-slice",
                "sequence?",
                "head",
                "append-as",
                "halves",
                "sequence=",
                "collapse-slice",
                "?second",
                "slice-error?",
                "product",
                "bounds-check?",
                "bounds-check",
                "immutable",
                "virtual-exemplar",
                "harvest",
                "remove",
                "pad-head",
                "last",
                "set-fourth",
                "cartesian-product",
                "remove-eq",
                "shorten",
                "shorter",
                "reversed?",
                "shorter?",
                "shortest",
                "head-slice",
                "pop*",
                "tail-slice*",
                "but-last-slice",
                "iota?",
                "append!",
                "cut-slice",
                "new-resizable",
                "head-slice*",
                "sequence-hashcode",
                "pop",
                "set-nth",
                "?nth",
                "second",
                "join",
                "immutable-sequence?",
                "<reversed>",
                "3append-as",
                "virtual-sequence",
                "subseq?",
                "remove-nth!",
                "length",
                "last-index",
                "lengthen",
                "assert-sequence",
                "copy",
                "move",
                "third",
                "first",
                "tail?",
                "set-first",
                "prefix",
                "bounds-error",
                "<repetition>",
                "exchange",
                "surround",
                "cut",
                "min-length",
                "set-third",
                "push-all",
                "head?",
                "subseq-start-from",
                "delete-slice",
                "rest",
                "sum-lengths",
                "head*",
                "infimum",
                "remove!",
                "glue",
                "slice-error",
                "subseq",
                "push",
                "replace-slice",
                "subseq-as",
                "unclip-last"
            ],
            "math-builtin": [
                "number=",
                "next-power-of-2",
                "?1+",
                "fp-special?",
                "imaginary-part",
                "float>bits",
                "number?",
                "fp-infinity?",
                "bignum?",
                "fp-snan?",
                "denominator",
                "gcd",
                "*",
                "+",
                "fp-bitwise=",
                "-",
                "u>=",
                "/",
                ">=",
                "bitand",
                "power-of-2?",
                "log2-expects-positive",
                "neg?",
                "<",
                "log2",
                ">",
                "integer?",
                "number",
                "bits>double",
                "2/",
                "zero?",
                "bits>float",
                "float?",
                "shift",
                "ratio?",
                "rect>",
                "even?",
                "ratio",
                "fp-sign",
                "bitnot",
                ">fixnum",
                "complex?",
                "/i",
                "integer>fixnum",
                "/f",
                "sgn",
                ">bignum",
                "next-float",
                "u<",
                "u>",
                "mod",
                "recip",
                "rational",
                ">float",
                "2^",
                "integer",
                "fixnum?",
                "neg",
                "fixnum",
                "sq",
                "bignum",
                ">rect",
                "bit?",
                "fp-qnan?",
                "simple-gcd",
                "complex",
                "<fp-nan>",
                "real",
                ">fraction",
                "double>bits",
                "bitor",
                "rem",
                "fp-nan-payload",
                "real-part",
                "log2-expects-positive?",
                "prev-float",
                "align",
                "unordered?",
                "float",
                "fp-nan?",
                "abs",
                "bitxor",
                "integer>fixnum-strict",
                "u<=",
                "odd?",
                "<=",
                "/mod",
                ">integer",
                "real?",
                "rational?",
                "numerator"
            ] // that's all for now
        };
        Object.keys(builtins).forEach(function(k) {
            factor1[k].pattern = arrToWordsRegExp(builtins[k]);
        });
        var combinators = [
            // kernel
            "2bi",
            "while",
            "2tri",
            "bi*",
            "4dip",
            "both?",
            "same?",
            "tri@",
            "curry",
            "prepose",
            "3bi",
            "?if",
            "tri*",
            "2keep",
            "3keep",
            "curried",
            "2keepd",
            "when",
            "2bi*",
            "2tri*",
            "4keep",
            "bi@",
            "keepdd",
            "do",
            "unless*",
            "tri-curry",
            "if*",
            "loop",
            "bi-curry*",
            "when*",
            "2bi@",
            "2tri@",
            "with",
            "2with",
            "either?",
            "bi",
            "until",
            "3dip",
            "3curry",
            "tri-curry*",
            "tri-curry@",
            "bi-curry",
            "keepd",
            "compose",
            "2dip",
            "if",
            "3tri",
            "unless",
            "tuple",
            "keep",
            "2curry",
            "tri",
            "most",
            "while*",
            "dip",
            "composed",
            "bi-curry@",
            "find-last-from",
            "trim-head-slice",
            "map-as",
            "each-from",
            "none?",
            "trim-tail",
            "partition",
            "if-empty",
            "accumulate*",
            "reject!",
            "find-from",
            "accumulate-as",
            "collector-for-as",
            "reject",
            "map",
            "map-sum",
            "accumulate!",
            "2each-from",
            "follow",
            "supremum-by",
            "map!",
            "unless-empty",
            "collector",
            "padding",
            "reduce-index",
            "replicate-as",
            "infimum-by",
            "trim-tail-slice",
            "count",
            "find-index",
            "filter",
            "accumulate*!",
            "reject-as",
            "map-integers",
            "map-find",
            "reduce",
            "selector",
            "interleave",
            "2map",
            "filter-as",
            "binary-reduce",
            "map-index-as",
            "find",
            "produce",
            "filter!",
            "replicate",
            "cartesian-map",
            "cartesian-each",
            "find-index-from",
            "map-find-last",
            "3map-as",
            "3map",
            "find-last",
            "selector-as",
            "2map-as",
            "2map-reduce",
            "accumulate",
            "each",
            "each-index",
            "accumulate*-as",
            "when-empty",
            "all?",
            "collector-as",
            "push-either",
            "new-like",
            "collector-for",
            "2selector",
            "push-if",
            "2all?",
            "map-reduce",
            "3each",
            "any?",
            "trim-slice",
            "2reduce",
            "change-nth",
            "produce-as",
            "2each",
            "trim",
            "trim-head",
            "cartesian-find",
            "map-index",
            "if-zero",
            "each-integer",
            "unless-zero",
            "(find-integer)",
            "when-zero",
            "find-last-integer",
            "(all-integers?)",
            "times",
            "(each-integer)",
            "find-integer",
            "all-integers?",
            "unless-negative",
            "if-positive",
            "when-positive",
            "when-negative",
            "unless-positive",
            "if-negative",
            "case",
            "2cleave",
            "cond>quot",
            "case>quot",
            "3cleave",
            "wrong-values",
            "to-fixed-point",
            "alist>quot",
            "cond",
            "cleave",
            "call-effect",
            "recursive-hashcode",
            "spread",
            "deep-spread>quot",
            "2||",
            "0||",
            "n||",
            "0&&",
            "2&&",
            "3||",
            "1||",
            "1&&",
            "n&&",
            "3&&",
            "smart-unless*",
            "keep-inputs",
            "reduce-outputs",
            "smart-when*",
            "cleave>array",
            "smart-with",
            "smart-apply",
            "smart-if",
            "inputs/outputs",
            "output>sequence-n",
            "map-outputs",
            "map-reduce-outputs",
            "dropping",
            "output>array",
            "smart-map-reduce",
            "smart-2map-reduce",
            "output>array-n",
            "nullary",
            "input<sequence",
            "append-outputs",
            "drop-inputs",
            "inputs",
            "smart-2reduce",
            "drop-outputs",
            "smart-reduce",
            "preserving",
            "smart-when",
            "outputs",
            "append-outputs-as",
            "smart-unless",
            "smart-if*",
            "sum-outputs",
            "input<sequence-unsafe",
            "output>sequence" // tafn
        ];
        factor1.combinators.pattern = arrToWordsRegExp(combinators);
        Prism.languages.factor = factor1;
    })(Prism1);
}

});

parcelRequire.register("blHrv", function(module, exports) {
"use strict";
module.exports = $84335aa7e212591b$var$$false;
$84335aa7e212591b$var$$false.displayName = "$false";
$84335aa7e212591b$var$$false.aliases = [];
function $84335aa7e212591b$var$$false(Prism1) {
    (function(Prism) {
        /**
     * Based on the manual by Wouter van Oortmerssen.
     *
     * @see {@link https://github.com/PrismJS/prism/issues/2801#issue-829717504}
     */ Prism.languages["false"] = {
            comment: {
                pattern: /\{[^}]*\}/
            },
            string: {
                pattern: /"[^"]*"/,
                greedy: true
            },
            "character-code": {
                pattern: /'(?:[^\r]|\r\n?)/,
                alias: "number"
            },
            "assembler-code": {
                pattern: /\d+`/,
                alias: "important"
            },
            number: /\d+/,
            operator: /[-!#$%&'*+,./:;=>?@\\^_`|~ßø]/,
            punctuation: /\[|\]/,
            variable: /[a-z]/,
            "non-standard": {
                pattern: /[()<BDO®]/,
                alias: "bold"
            }
        };
    })(Prism1);
}

});

parcelRequire.register("kyvzx", function(module, exports) {
"use strict";
module.exports = $ef6f793a34fd0bd4$var$firestoreSecurityRules;
$ef6f793a34fd0bd4$var$firestoreSecurityRules.displayName = "firestoreSecurityRules";
$ef6f793a34fd0bd4$var$firestoreSecurityRules.aliases = [];
function $ef6f793a34fd0bd4$var$firestoreSecurityRules(Prism) {
    Prism.languages["firestore-security-rules"] = Prism.languages.extend("clike", {
        comment: /\/\/.*/,
        keyword: /\b(?:allow|function|if|match|null|return|rules_version|service)\b/,
        operator: /&&|\|\||[<>!=]=?|[-+*/%]|\b(?:in|is)\b/
    });
    delete Prism.languages["firestore-security-rules"]["class-name"];
    Prism.languages.insertBefore("firestore-security-rules", "keyword", {
        path: {
            pattern: /(^|[\s(),])(?:\/(?:[\w\xA0-\uFFFF]+|\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)))+/,
            lookbehind: true,
            greedy: true,
            inside: {
                variable: {
                    pattern: /\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)/,
                    inside: {
                        operator: /=/,
                        keyword: /\*\*/,
                        punctuation: /[.$(){}]/
                    }
                },
                punctuation: /\//
            }
        },
        method: {
            // to make the pattern shorter, the actual method names are omitted
            pattern: /(\ballow\s+)[a-z]+(?:\s*,\s*[a-z]+)*(?=\s*[:;])/,
            lookbehind: true,
            alias: "builtin",
            inside: {
                punctuation: /,/
            }
        }
    });
}

});

parcelRequire.register("aUrcT", function(module, exports) {
"use strict";
module.exports = $7f143d1958cf090a$var$flow;
$7f143d1958cf090a$var$flow.displayName = "flow";
$7f143d1958cf090a$var$flow.aliases = [];
function $7f143d1958cf090a$var$flow(Prism1) {
    (function(Prism) {
        Prism.languages.flow = Prism.languages.extend("javascript", {});
        Prism.languages.insertBefore("flow", "keyword", {
            type: [
                {
                    pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|any|mixed|null|void)\b/,
                    alias: "tag"
                }
            ]
        });
        Prism.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i;
        delete Prism.languages.flow["parameter"];
        Prism.languages.insertBefore("flow", "operator", {
            "flow-punctuation": {
                pattern: /\{\||\|\}/,
                alias: "punctuation"
            }
        });
        if (!Array.isArray(Prism.languages.flow.keyword)) Prism.languages.flow.keyword = [
            Prism.languages.flow.keyword
        ];
        Prism.languages.flow.keyword.unshift({
            pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
            lookbehind: true
        }, {
            pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,
            lookbehind: true
        });
    })(Prism1);
}

});

parcelRequire.register("iqi0o", function(module, exports) {
"use strict";
module.exports = $d6989f33aa4c6f05$var$fortran;
$d6989f33aa4c6f05$var$fortran.displayName = "fortran";
$d6989f33aa4c6f05$var$fortran.aliases = [];
function $d6989f33aa4c6f05$var$fortran(Prism) {
    Prism.languages.fortran = {
        "quoted-number": {
            pattern: /[BOZ](['"])[A-F0-9]+\1/i,
            alias: "number"
        },
        string: {
            pattern: /(?:\b\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:[ \t]*!.*(?:\r\n?|\n)|(?![ \t]*!))|(?!\1).)*(?:\1|&)/,
            inside: {
                comment: {
                    pattern: /(&(?:\r\n?|\n)\s*)!.*/,
                    lookbehind: true
                }
            }
        },
        comment: {
            pattern: /!.*/,
            greedy: true
        },
        boolean: /\.(?:FALSE|TRUE)\.(?:_\w+)?/i,
        number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
        keyword: [
            // Types
            /\b(?:CHARACTER|COMPLEX|DOUBLE ?PRECISION|INTEGER|LOGICAL|REAL)\b/i,
            /\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,
            /\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,
            /\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEIF|ELSEWHERE|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
        ],
        operator: [
            /\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.[A-Z]+\./i,
            {
                // Use lookbehind to prevent confusion with (/ /)
                pattern: /(^|(?!\().)\/(?!\))/,
                lookbehind: true
            }
        ],
        punctuation: /\(\/|\/\)|[(),;:&]/
    };
}

});

parcelRequire.register("d8oi6", function(module, exports) {
"use strict";
module.exports = $98fedd6ccf2def2f$var$fsharp;
$98fedd6ccf2def2f$var$fsharp.displayName = "fsharp";
$98fedd6ccf2def2f$var$fsharp.aliases = [];
function $98fedd6ccf2def2f$var$fsharp(Prism) {
    Prism.languages.fsharp = Prism.languages.extend("clike", {
        comment: [
            {
                pattern: /(^|[^\\])\(\*(?!\))[\s\S]*?\*\)/,
                lookbehind: true,
                greedy: true
            },
            {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        string: {
            pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|"(?:\\[\s\S]|[^\\"])*")B?/,
            greedy: true
        },
        "class-name": {
            pattern: /(\b(?:exception|inherit|interface|new|of|type)\s+|\w\s*:\s*|\s:\??>\s*)[.\w]+\b(?:\s*(?:->|\*)\s*[.\w]+\b)*(?!\s*[:.])/,
            lookbehind: true,
            inside: {
                operator: /->|\*/,
                punctuation: /\./
            }
        },
        keyword: /\b(?:let|return|use|yield)(?:!\B|\b)|\b(?:abstract|and|as|asr|assert|atomic|base|begin|break|checked|class|component|const|constraint|constructor|continue|default|delegate|do|done|downcast|downto|eager|elif|else|end|event|exception|extern|external|false|finally|fixed|for|fun|function|functor|global|if|in|include|inherit|inline|interface|internal|land|lazy|lor|lsl|lsr|lxor|match|member|method|mixin|mod|module|mutable|namespace|new|not|null|object|of|open|or|override|parallel|private|process|protected|public|pure|rec|sealed|select|sig|static|struct|tailcall|then|to|trait|true|try|type|upcast|val|virtual|void|volatile|when|while|with)\b/,
        number: [
            /\b0x[\da-fA-F]+(?:LF|lf|un)?\b/,
            /\b0b[01]+(?:uy|y)?\b/,
            /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[fm]|e[+-]?\d+)?\b/i,
            /\b\d+(?:[IlLsy]|UL|u[lsy]?)?\b/
        ],
        operator: /([<>~&^])\1\1|([*.:<>&])\2|<-|->|[!=:]=|<?\|{1,3}>?|\??(?:<=|>=|<>|[-+*/%=<>])\??|[!?^&]|~[+~-]|:>|:\?>?/
    });
    Prism.languages.insertBefore("fsharp", "keyword", {
        preprocessor: {
            pattern: /(^[\t ]*)#.*/m,
            lookbehind: true,
            alias: "property",
            inside: {
                directive: {
                    pattern: /(^#)\b(?:else|endif|if|light|line|nowarn)\b/,
                    lookbehind: true,
                    alias: "keyword"
                }
            }
        }
    });
    Prism.languages.insertBefore("fsharp", "punctuation", {
        "computation-expression": {
            pattern: /\b[_a-z]\w*(?=\s*\{)/i,
            alias: "keyword"
        }
    });
    Prism.languages.insertBefore("fsharp", "string", {
        annotation: {
            pattern: /\[<.+?>\]/,
            greedy: true,
            inside: {
                punctuation: /^\[<|>\]$/,
                "class-name": {
                    pattern: /^\w+$|(^|;\s*)[A-Z]\w*(?=\()/,
                    lookbehind: true
                },
                "annotation-content": {
                    pattern: /[\s\S]+/,
                    inside: Prism.languages.fsharp
                }
            }
        },
        char: {
            pattern: /'(?:[^\\']|\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8}))'B?/,
            greedy: true
        }
    });
}

});

parcelRequire.register("2AzYV", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");
module.exports = $1e2adac5387d219d$var$ftl;
$1e2adac5387d219d$var$ftl.displayName = "ftl";
$1e2adac5387d219d$var$ftl.aliases = [];
function $1e2adac5387d219d$var$ftl(Prism1) {
    Prism1.register($cekeD);
    (function(Prism) {
        // https://freemarker.apache.org/docs/dgui_template_exp.html
        // FTL expression with 4 levels of nesting supported
        var FTL_EXPR = /[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/.source;
        for(var i = 0; i < 2; i++)FTL_EXPR = FTL_EXPR.replace(/<expr>/g, function() {
            return FTL_EXPR;
        });
        FTL_EXPR = FTL_EXPR.replace(/<expr>/g, /[^\s\S]/.source);
        var ftl1 = {
            comment: /<#--[\s\S]*?-->/,
            string: [
                {
                    // raw string
                    pattern: /\br("|')(?:(?!\1)[^\\]|\\.)*\1/,
                    greedy: true
                },
                {
                    pattern: RegExp(/("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(/<expr>/g, function() {
                        return FTL_EXPR;
                    })),
                    greedy: true,
                    inside: {
                        interpolation: {
                            pattern: RegExp(/((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(/<expr>/g, function() {
                                return FTL_EXPR;
                            })),
                            lookbehind: true,
                            inside: {
                                "interpolation-punctuation": {
                                    pattern: /^\$\{|\}$/,
                                    alias: "punctuation"
                                },
                                rest: null
                            }
                        }
                    }
                }
            ],
            keyword: /\b(?:as)\b/,
            boolean: /\b(?:false|true)\b/,
            "builtin-function": {
                pattern: /((?:^|[^?])\?\s*)\w+/,
                lookbehind: true,
                alias: "function"
            },
            function: /\b\w+(?=\s*\()/,
            number: /\b\d+(?:\.\d+)?\b/,
            operator: /\.\.[<*!]?|->|--|\+\+|&&|\|\||\?{1,2}|[-+*/%!=<>]=?|\b(?:gt|gte|lt|lte)\b/,
            punctuation: /[,;.:()[\]{}]/
        };
        ftl1.string[1].inside.interpolation.inside.rest = ftl1;
        Prism.languages.ftl = {
            "ftl-comment": {
                // the pattern is shortened to be more efficient
                pattern: /^<#--[\s\S]*/,
                alias: "comment"
            },
            "ftl-directive": {
                pattern: /^<[\s\S]+>$/,
                inside: {
                    directive: {
                        pattern: /(^<\/?)[#@][a-z]\w*/i,
                        lookbehind: true,
                        alias: "keyword"
                    },
                    punctuation: /^<\/?|\/?>$/,
                    content: {
                        pattern: /\s*\S[\s\S]*/,
                        alias: "ftl",
                        inside: ftl1
                    }
                }
            },
            "ftl-interpolation": {
                pattern: /^\$\{[\s\S]*\}$/,
                inside: {
                    punctuation: /^\$\{|\}$/,
                    content: {
                        pattern: /\s*\S[\s\S]*/,
                        alias: "ftl",
                        inside: ftl1
                    }
                }
            }
        };
        Prism.hooks.add("before-tokenize", function(env) {
            // eslint-disable-next-line regexp/no-useless-lazy
            var pattern = RegExp(/<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(/<expr>/g, function() {
                return FTL_EXPR;
            }), "gi");
            Prism.languages["markup-templating"].buildPlaceholders(env, "ftl", pattern);
        });
        Prism.hooks.add("after-tokenize", function(env) {
            Prism.languages["markup-templating"].tokenizePlaceholders(env, "ftl");
        });
    })(Prism1);
}

});

parcelRequire.register("cak77", function(module, exports) {
"use strict";
module.exports = $8db6055f65a3aa58$var$gap;
$8db6055f65a3aa58$var$gap.displayName = "gap";
$8db6055f65a3aa58$var$gap.aliases = [];
function $8db6055f65a3aa58$var$gap(Prism) {
    // https://www.gap-system.org/Manuals/doc/ref/chap4.html
    // https://www.gap-system.org/Manuals/doc/ref/chap27.html
    Prism.languages.gap = {
        shell: {
            pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
            greedy: true,
            inside: {
                gap: {
                    pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
                    lookbehind: true,
                    inside: null // see below
                },
                punctuation: /^gap>/
            }
        },
        comment: {
            pattern: /#.*/,
            greedy: true
        },
        string: {
            pattern: /(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
            lookbehind: true,
            greedy: true,
            inside: {
                continuation: {
                    pattern: /([\r\n])>/,
                    lookbehind: true,
                    alias: "punctuation"
                }
            }
        },
        keyword: /\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
        boolean: /\b(?:false|true)\b/,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: {
            pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
            lookbehind: true
        },
        continuation: {
            pattern: /([\r\n])>/,
            lookbehind: true,
            alias: "punctuation"
        },
        operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
        punctuation: /[()[\]{},;.:]/
    };
    Prism.languages.gap.shell.inside.gap.inside = Prism.languages.gap;
}

});

parcelRequire.register("kDavc", function(module, exports) {
"use strict";
module.exports = $f04f98a9c5852ad4$var$gcode;
$f04f98a9c5852ad4$var$gcode.displayName = "gcode";
$f04f98a9c5852ad4$var$gcode.aliases = [];
function $f04f98a9c5852ad4$var$gcode(Prism) {
    Prism.languages.gcode = {
        comment: /;.*|\B\(.*?\)\B/,
        string: {
            pattern: /"(?:""|[^"])*"/,
            greedy: true
        },
        keyword: /\b[GM]\d+(?:\.\d+)?\b/,
        property: /\b[A-Z]/,
        checksum: {
            pattern: /(\*)\d+/,
            lookbehind: true,
            alias: "number"
        },
        // T0:0:0
        punctuation: /[:*]/
    };
}

});

parcelRequire.register("kZazw", function(module, exports) {
"use strict";
module.exports = $f471b48a3869262f$var$gdscript;
$f471b48a3869262f$var$gdscript.displayName = "gdscript";
$f471b48a3869262f$var$gdscript.aliases = [];
function $f471b48a3869262f$var$gdscript(Prism) {
    Prism.languages.gdscript = {
        comment: /#.*/,
        string: {
            pattern: /@?(?:("|')(?:(?!\1)[^\n\\]|\\[\s\S])*\1(?!"|')|"""(?:[^\\]|\\[\s\S])*?""")/,
            greedy: true
        },
        "class-name": {
            // class_name Foo, extends Bar, class InnerClass
            // export(int) var baz, export(int, 0) var i
            // as Node
            // const FOO: int = 9, var bar: bool = true
            // func add(reference: Item, amount: int) -> Item:
            pattern: /(^(?:class|class_name|extends)[ \t]+|^export\([ \t]*|\bas[ \t]+|(?:\b(?:const|var)[ \t]|[,(])[ \t]*\w+[ \t]*:[ \t]*|->[ \t]*)[a-zA-Z_]\w*/m,
            lookbehind: true
        },
        keyword: /\b(?:and|as|assert|break|breakpoint|class|class_name|const|continue|elif|else|enum|export|extends|for|func|if|in|is|master|mastersync|match|not|null|onready|or|pass|preload|puppet|puppetsync|remote|remotesync|return|self|setget|signal|static|tool|var|while|yield)\b/,
        function: /\b[a-z_]\w*(?=[ \t]*\()/i,
        variable: /\$\w+/,
        number: [
            /\b0b[01_]+\b|\b0x[\da-fA-F_]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.[\d_]+)(?:e[+-]?[\d_]+)?\b/,
            /\b(?:INF|NAN|PI|TAU)\b/
        ],
        constant: /\b[A-Z][A-Z_\d]*\b/,
        boolean: /\b(?:false|true)\b/,
        operator: /->|:=|&&|\|\||<<|>>|[-+*/%&|!<>=]=?|[~^]/,
        punctuation: /[.:,;()[\]{}]/
    };
}

});

parcelRequire.register("e6KPe", function(module, exports) {
"use strict";
module.exports = $a455f2c3e659204e$var$gedcom;
$a455f2c3e659204e$var$gedcom.displayName = "gedcom";
$a455f2c3e659204e$var$gedcom.aliases = [];
function $a455f2c3e659204e$var$gedcom(Prism) {
    Prism.languages.gedcom = {
        "line-value": {
            // Preceded by level, optional pointer, and tag
            pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?\w+ ).+/m,
            lookbehind: true,
            inside: {
                pointer: {
                    pattern: /^@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@$/,
                    alias: "variable"
                }
            }
        },
        tag: {
            // Preceded by level and optional pointer
            pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?)\w+/m,
            lookbehind: true,
            alias: "string"
        },
        level: {
            pattern: /(^[\t ]*)\d+/m,
            lookbehind: true,
            alias: "number"
        },
        pointer: {
            pattern: /@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@/,
            alias: "variable"
        }
    };
}

});

parcelRequire.register("juR1k", function(module, exports) {
"use strict";
module.exports = $e319f26dc4ffd569$var$gherkin;
$e319f26dc4ffd569$var$gherkin.displayName = "gherkin";
$e319f26dc4ffd569$var$gherkin.aliases = [];
function $e319f26dc4ffd569$var$gherkin(Prism1) {
    (function(Prism) {
        var tableRow = /(?:\r?\n|\r)[ \t]*\|.+\|(?:(?!\|).)*/.source;
        Prism.languages.gherkin = {
            pystring: {
                pattern: /("""|''')[\s\S]+?\1/,
                alias: "string"
            },
            comment: {
                pattern: /(^[ \t]*)#.*/m,
                lookbehind: true
            },
            tag: {
                pattern: /(^[ \t]*)@\S*/m,
                lookbehind: true
            },
            feature: {
                pattern: /((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Característica|Egenskab|Egenskap|Eiginleiki|Feature|Fīča|Fitur|Fonctionnalité|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcţionalitate|Funcționalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitāte|Funkcionalnost|Funkcja|Funksie|Funktionalität|Funktionalitéit|Funzionalità|Hwaet|Hwæt|Jellemző|Karakteristik|Lastnost|Mak|Mogucnost|laH|Mogućnost|Moznosti|Možnosti|OH HAI|Omadus|Ominaisuus|Osobina|Özellik|Potrzeba biznesowa|perbogh|poQbogh malja'|Požadavek|Požiadavka|Pretty much|Qap|Qu'meH 'ut|Savybė|Tính năng|Trajto|Vermoë|Vlastnosť|Właściwość|Značilnost|Δυνατότητα|Λειτουργία|Могућност|Мөмкинлек|Особина|Свойство|Үзенчәлеклелек|Функционал|Функционалност|Функция|Функціонал|תכונה|خاصية|خصوصیت|صلاحیت|کاروبار کی ضرورت|وِیژگی|रूप लेख|ਖਾਸੀਅਤ|ਨਕਸ਼ ਨੁਹਾਰ|ਮੁਹਾਂਦਰਾ|గుణము|ಹೆಚ್ಚಳ|ความต้องการทางธุรกิจ|ความสามารถ|โครงหลัก|기능|フィーチャ|功能|機能):(?:[^:\r\n]+(?:\r?\n|\r|$))*/,
                lookbehind: true,
                inside: {
                    important: {
                        pattern: /(:)[^\r\n]+/,
                        lookbehind: true
                    },
                    keyword: /[^:\r\n]+:/
                }
            },
            scenario: {
                pattern: /(^[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|Ær|Agtergrond|All y'all|Antecedentes|Antecedents|Atburðarás|Atburðarásir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bối cảnh|Cefndir|Cenario|Cenário|Cenario de Fundo|Cenário de Fundo|Cenarios|Cenários|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dæmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineação do Cenário|Dis is what went down|Dữ liệu|Dyagram Senaryo|Dyagram senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenário|EXAMPLZ|Examples|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatókönyv|Forgatókönyv vázlat|Fundo|Geçmiş|Grundlage|Hannergrond|ghantoH|Háttér|Heave to|Istorik|Juhtumid|Keadaan|Khung kịch bản|Khung tình huống|Kịch bản|Koncept|Konsep skenario|Kontèks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut chovnatlh|lut|lutmey|Lýsing Atburðarásar|Lýsing Dæma|MISHUN SRSLY|MISHUN|Menggariskan Senario|mo'|Náčrt Scenára|Náčrt Scénáře|Náčrt Scenáru|Oris scenarija|Örnekler|Osnova|Osnova Scenára|Osnova scénáře|Osnutek|Ozadje|Paraugs|Pavyzdžiai|Példák|Piemēri|Plan du scénario|Plan du Scénario|Plan Senaryo|Plan senaryo|Plang vum Szenario|Pozadí|Pozadie|Pozadina|Príklady|Příklady|Primer|Primeri|Primjeri|Przykłady|Raamstsenaarium|Reckon it's like|Rerefons|Scenár|Scénář|Scenarie|Scenarij|Scenarijai|Scenarijaus šablonas|Scenariji|Scenārijs|Scenārijs pēc parauga|Scenarijus|Scenario|Scénario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se ðe|Se the|Se þe|Senario|Senaryo Deskripsyon|Senaryo deskripsyon|Senaryo|Senaryo taslağı|Shiver me timbers|Situācija|Situai|Situasie Uiteensetting|Situasie|Skenario konsep|Skenario|Skica|Structura scenariu|Structură scenariu|Struktura scenarija|Stsenaarium|Swa hwaer swa|Swa|Swa hwær swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tình huống|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo-ho-ho|You'll wanna|Założenia|Παραδείγματα|Περιγραφή Σεναρίου|Σενάρια|Σενάριο|Υπόβαθρο|Кереш|Контекст|Концепт|Мисаллар|Мисоллар|Основа|Передумова|Позадина|Предистория|Предыстория|Приклади|Пример|Примери|Примеры|Рамка на сценарий|Скица|Структура сценарија|Структура сценария|Структура сценарію|Сценарий|Сценарий структураси|Сценарийның төзелеше|Сценарији|Сценарио|Сценарій|Тарих|Үрнәкләр|דוגמאות|רקע|תבנית תרחיש|תרחיש|الخلفية|الگوی سناریو|امثلة|پس منظر|زمینه|سناریو|سيناريو|سيناريو مخطط|مثالیں|منظر نامے کا خاکہ|منظرنامہ|نمونه ها|उदाहरण|परिदृश्य|परिदृश्य रूपरेखा|पृष्ठभूमि|ਉਦਾਹਰਨਾਂ|ਪਟਕਥਾ|ਪਟਕਥਾ ਢਾਂਚਾ|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਿਛੋਕੜ|ఉదాహరణలు|కథనం|నేపథ్యం|సన్నివేశం|ಉದಾಹರಣೆಗಳು|ಕಥಾಸಾರಾಂಶ|ವಿವರಣೆ|ಹಿನ್ನೆಲೆ|โครงสร้างของเหตุการณ์|ชุดของตัวอย่าง|ชุดของเหตุการณ์|แนวคิด|สรุปเหตุการณ์|เหตุการณ์|배경|시나리오|시나리오 개요|예|サンプル|シナリオ|シナリオアウトライン|シナリオテンプレ|シナリオテンプレート|テンプレ|例|例子|剧本|剧本大纲|劇本|劇本大綱|场景|场景大纲|場景|場景大綱|背景):[^:\r\n]*/m,
                lookbehind: true,
                inside: {
                    important: {
                        pattern: /(:)[^\r\n]*/,
                        lookbehind: true
                    },
                    keyword: /[^:\r\n]+:/
                }
            },
            "table-body": {
                // Look-behind is used to skip the table head, which has the same format as any table row
                pattern: RegExp("(" + tableRow + ")(?:" + tableRow + ")+"),
                lookbehind: true,
                inside: {
                    outline: {
                        pattern: /<[^>]+>/,
                        alias: "variable"
                    },
                    td: {
                        pattern: /\s*[^\s|][^|]*/,
                        alias: "string"
                    },
                    punctuation: /\|/
                }
            },
            "table-head": {
                pattern: RegExp(tableRow),
                inside: {
                    th: {
                        pattern: /\s*[^\s|][^|]*/,
                        alias: "variable"
                    },
                    punctuation: /\|/
                }
            },
            atrule: {
                pattern: /(^[ \t]+)(?:'a|'ach|'ej|7|a|A také|A taktiež|A tiež|A zároveň|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Atès|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Biết|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Când|Cand|Cando|Ce|Cuando|Če|Ða ðe|Ða|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Daţi fiind|Dați fiind|DEN|Dato|De|Den youse gotta|Dengan|Diberi|Diyelim ki|Donada|Donat|Donitaĵo|Do|Dun|Duota|Ðurh|Eeldades|Ef|Eğer ki|Entao|Então|Entón|E|En|Entonces|Epi|És|Etant donnée|Etant donné|Et|Étant données|Étant donnée|Étant donné|Etant données|Etant donnés|Étant donnés|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeśli|Jeżeli|Kad|Kada|Kadar|Kai|Kaj|Když|Keď|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|Lè sa a|Lè|Logo|Lorsqu'<|Lorsque|mä|Maar|Mais|Mając|Ma|Majd|Maka|Manawa|Mas|Men|Menawa|Mutta|Nalika|Nalikaning|Nanging|Når|När|Nato|Nhưng|Niin|Njuk|O zaman|Och|Og|Oletetaan|Ond|Onda|Oraz|Pak|Pero|Però|Podano|Pokiaľ|Pokud|Potem|Potom|Privzeto|Pryd|Quan|Quand|Quando|qaSDI'|Så|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|Şi|Și|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Thì|Thurh|Toda|Too right|Un|Und|ugeholl|Và|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za předpokladu|Zadan|Zadani|Zadano|Zadate|Zadato|Zakładając|Zaradi|Zatati|Þa þe|Þa|Þá|Þegar|Þurh|Αλλά|Δεδομένου|Και|Όταν|Τότε|А також|Агар|Але|Али|Аммо|А|Әгәр|Әйтик|Әмма|Бирок|Ва|Вә|Дадено|Дано|Допустим|Если|Задате|Задати|Задато|И|І|К тому же|Када|Кад|Когато|Когда|Коли|Ләкин|Лекин|Нәтиҗәдә|Нехай|Но|Онда|Припустимо, що|Припустимо|Пусть|Также|Та|Тогда|Тоді|То|Унда|Һәм|Якщо|אבל|אזי|אז|בהינתן|וגם|כאשר|آنگاه|اذاً|اگر|اما|اور|با فرض|بالفرض|بفرض|پھر|تب|ثم|جب|عندما|فرض کیا|لكن|لیکن|متى|هنگامی|و|अगर|और|कदा|किन्तु|चूंकि|जब|तथा|तदा|तब|परन्तु|पर|यदि|ਅਤੇ|ਜਦੋਂ|ਜਿਵੇਂ ਕਿ|ਜੇਕਰ|ਤਦ|ਪਰ|అప్పుడు|ఈ పరిస్థితిలో|కాని|చెప్పబడినది|మరియు|ಆದರೆ|ನಂತರ|ನೀಡಿದ|ಮತ್ತು|ಸ್ಥಿತಿಯನ್ನು|กำหนดให้|ดังนั้น|แต่|เมื่อ|และ|그러면<|그리고<|단<|만약<|만일<|먼저<|조건<|하지만<|かつ<|しかし<|ただし<|ならば<|もし<|並且<|但し<|但是<|假如<|假定<|假設<|假设<|前提<|同时<|同時<|并且<|当<|當<|而且<|那么<|那麼<)(?=[ \t])/m,
                lookbehind: true
            },
            string: {
                pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
                inside: {
                    outline: {
                        pattern: /<[^>]+>/,
                        alias: "variable"
                    }
                }
            },
            outline: {
                pattern: /<[^>]+>/,
                alias: "variable"
            }
        };
    })(Prism1);
}

});

parcelRequire.register("PDZAl", function(module, exports) {
"use strict";
module.exports = $09b3c92ca70dec8a$var$git;
$09b3c92ca70dec8a$var$git.displayName = "git";
$09b3c92ca70dec8a$var$git.aliases = [];
function $09b3c92ca70dec8a$var$git(Prism) {
    Prism.languages.git = {
        /*
     * A simple one line comment like in a git status command
     * For instance:
     * $ git status
     * # On branch infinite-scroll
     * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
     * # and have 1 and 2 different commits each, respectively.
     * nothing to commit (working directory clean)
     */ comment: /^#.*/m,
        /*
     * Regexp to match the changed lines in a git diff output. Check the example below.
     */ deleted: /^[-–].*/m,
        inserted: /^\+.*/m,
        /*
     * a string (double and simple quote)
     */ string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        /*
     * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
     * For instance:
     * $ git add file.txt
     */ command: {
            pattern: /^.*\$ git .*$/m,
            inside: {
                /*
         * A git command can contain a parameter starting by a single or a double dash followed by a string
         * For instance:
         * $ git diff --cached
         * $ git log -p
         */ parameter: /\s--?\w+/
            }
        },
        /*
     * Coordinates displayed in a git diff command
     * For instance:
     * $ git diff
     * diff --git file.txt file.txt
     * index 6214953..1d54a52 100644
     * --- file.txt
     * +++ file.txt
     * @@ -1 +1,2 @@
     * -Here's my tetx file
     * +Here's my text file
     * +And this is the second line
     */ coord: /^@@.*@@$/m,
        /*
     * Match a "commit [SHA1]" line in a git log output.
     * For instance:
     * $ git log
     * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
     * Author: lgiraudel
     * Date:   Mon Feb 17 11:18:34 2014 +0100
     *
     *     Add of a new line
     */ "commit-sha1": /^commit \w{40}$/m
    };
}

});

parcelRequire.register("e0r83", function(module, exports) {
"use strict";

var $bEqqd = parcelRequire("bEqqd");
module.exports = $a3261c01e3013570$var$glsl;
$a3261c01e3013570$var$glsl.displayName = "glsl";
$a3261c01e3013570$var$glsl.aliases = [];
function $a3261c01e3013570$var$glsl(Prism) {
    Prism.register($bEqqd);
    Prism.languages.glsl = Prism.languages.extend("c", {
        keyword: /\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/
    });
}

});

parcelRequire.register("97zzY", function(module, exports) {
"use strict";
module.exports = $6a405dcc6282fbdb$var$gml;
$6a405dcc6282fbdb$var$gml.displayName = "gml";
$6a405dcc6282fbdb$var$gml.aliases = [];
function $6a405dcc6282fbdb$var$gml(Prism) {
    Prism.languages.gamemakerlanguage = Prism.languages.gml = Prism.languages.extend("clike", {
        keyword: /\b(?:break|case|continue|default|do|else|enum|exit|for|globalvar|if|repeat|return|switch|until|var|while)\b/,
        number: /(?:\b0x[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ulf]{0,4}/i,
        operator: /--|\+\+|[-+%/=]=?|!=|\*\*?=?|<[<=>]?|>[=>]?|&&?|\^\^?|\|\|?|~|\b(?:and|at|not|or|with|xor)\b/,
        constant: /\b(?:GM_build_date|GM_version|action_(?:continue|restart|reverse|stop)|all|gamespeed_(?:fps|microseconds)|global|local|noone|other|pi|pointer_(?:invalid|null)|self|timezone_(?:local|utc)|undefined|ev_(?:create|destroy|step|alarm|keyboard|mouse|collision|other|draw|draw_(?:begin|end|post|pre)|keypress|keyrelease|trigger|(?:left|middle|no|right)_button|(?:left|middle|right)_press|(?:left|middle|right)_release|mouse_(?:enter|leave|wheel_down|wheel_up)|global_(?:left|middle|right)_button|global_(?:left|middle|right)_press|global_(?:left|middle|right)_release|joystick(?:1|2)_(?:button1|button2|button3|button4|button5|button6|button7|button8|down|left|right|up)|outside|boundary|game_start|game_end|room_start|room_end|no_more_lives|animation_end|end_of_path|no_more_health|user\d|gui|gui_begin|gui_end|step_(?:begin|end|normal))|vk_(?:alt|anykey|backspace|control|delete|down|end|enter|escape|home|insert|left|nokey|pagedown|pageup|pause|printscreen|return|right|shift|space|tab|up|f\d|numpad\d|add|decimal|divide|lalt|lcontrol|lshift|multiply|ralt|rcontrol|rshift|subtract)|achievement_(?:filter_(?:all_players|favorites_only|friends_only)|friends_info|info|leaderboard_info|our_info|pic_loaded|show_(?:achievement|bank|friend_picker|leaderboard|profile|purchase_prompt|ui)|type_challenge|type_score_challenge)|asset_(?:font|object|path|room|script|shader|sound|sprite|tiles|timeline|unknown)|audio_(?:3d|falloff_(?:exponent_distance|exponent_distance_clamped|inverse_distance|inverse_distance_clamped|linear_distance|linear_distance_clamped|none)|mono|new_system|old_system|stereo)|bm_(?:add|complex|dest_alpha|dest_color|dest_colour|inv_dest_alpha|inv_dest_color|inv_dest_colour|inv_src_alpha|inv_src_color|inv_src_colour|max|normal|one|src_alpha|src_alpha_sat|src_color|src_colour|subtract|zero)|browser_(?:chrome|firefox|ie|ie_mobile|not_a_browser|opera|safari|safari_mobile|tizen|unknown|windows_store)|buffer_(?:bool|f16|f32|f64|fast|fixed|generalerror|grow|invalidtype|network|outofbounds|outofspace|s16|s32|s8|seek_end|seek_relative|seek_start|string|text|u16|u32|u64|u8|vbuffer|wrap)|c_(?:aqua|black|blue|dkgray|fuchsia|gray|green|lime|ltgray|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)|cmpfunc_(?:always|equal|greater|greaterequal|less|lessequal|never|notequal)|cr_(?:appstart|arrow|beam|cross|default|drag|handpoint|hourglass|none|size_all|size_nesw|size_ns|size_nwse|size_we|uparrow)|cull_(?:clockwise|counterclockwise|noculling)|device_(?:emulator|tablet)|device_ios_(?:ipad|ipad_retina|iphone|iphone5|iphone6|iphone6plus|iphone_retina|unknown)|display_(?:landscape|landscape_flipped|portrait|portrait_flipped)|dll_(?:cdecl|cdel|stdcall)|ds_type_(?:grid|list|map|priority|queue|stack)|ef_(?:cloud|ellipse|explosion|firework|flare|rain|ring|smoke|smokeup|snow|spark|star)|fa_(?:archive|bottom|center|directory|hidden|left|middle|readonly|right|sysfile|top|volumeid)|fb_login_(?:default|fallback_to_webview|forcing_safari|forcing_webview|no_fallback_to_webview|use_system_account)|iap_(?:available|canceled|ev_consume|ev_product|ev_purchase|ev_restore|ev_storeload|failed|purchased|refunded|status_available|status_loading|status_processing|status_restoring|status_unavailable|status_uninitialised|storeload_failed|storeload_ok|unavailable)|leaderboard_type_(?:number|time_mins_secs)|lighttype_(?:dir|point)|matrix_(?:projection|view|world)|mb_(?:any|left|middle|none|right)|network_(?:config_(?:connect_timeout|disable_reliable_udp|enable_reliable_udp|use_non_blocking_socket)|socket_(?:bluetooth|tcp|udp)|type_(?:connect|data|disconnect|non_blocking_connect))|of_challenge_(?:lose|tie|win)|os_(?:android|ios|linux|macosx|ps3|ps4|psvita|unknown|uwp|win32|win8native|windows|winphone|xboxone)|phy_debug_render_(?:aabb|collision_pairs|coms|core_shapes|joints|obb|shapes)|phy_joint_(?:anchor_1_x|anchor_1_y|anchor_2_x|anchor_2_y|angle|angle_limits|damping_ratio|frequency|length_1|length_2|lower_angle_limit|max_force|max_length|max_motor_force|max_motor_torque|max_torque|motor_force|motor_speed|motor_torque|reaction_force_x|reaction_force_y|reaction_torque|speed|translation|upper_angle_limit)|phy_particle_data_flag_(?:category|color|colour|position|typeflags|velocity)|phy_particle_flag_(?:colormixing|colourmixing|elastic|powder|spring|tensile|viscous|wall|water|zombie)|phy_particle_group_flag_(?:rigid|solid)|pr_(?:linelist|linestrip|pointlist|trianglefan|trianglelist|trianglestrip)|ps_(?:distr|shape)_(?:diamond|ellipse|gaussian|invgaussian|line|linear|rectangle)|pt_shape_(?:circle|cloud|disk|explosion|flare|line|pixel|ring|smoke|snow|spark|sphere|square|star)|ty_(?:real|string)|gp_(?:face\d|axislh|axislv|axisrh|axisrv|padd|padl|padr|padu|select|shoulderl|shoulderlb|shoulderr|shoulderrb|start|stickl|stickr)|lb_disp_(?:none|numeric|time_ms|time_sec)|lb_sort_(?:ascending|descending|none)|ov_(?:achievements|community|friends|gamegroup|players|settings)|ugc_(?:filetype_(?:community|microtrans)|list_(?:Favorited|Followed|Published|Subscribed|UsedOrPlayed|VotedDown|VotedOn|VotedUp|WillVoteLater)|match_(?:AllGuides|Artwork|Collections|ControllerBindings|IntegratedGuides|Items|Items_Mtx|Items_ReadyToUse|Screenshots|UsableInGame|Videos|WebGuides)|query_(?:AcceptedForGameRankedByAcceptanceDate|CreatedByFriendsRankedByPublicationDate|FavoritedByFriendsRankedByPublicationDate|NotYetRated)|query_RankedBy(?:NumTimesReported|PublicationDate|TextSearch|TotalVotesAsc|Trend|Vote|VotesUp)|result_success|sortorder_CreationOrder(?:Asc|Desc)|sortorder_(?:ForModeration|LastUpdatedDesc|SubscriptionDateDesc|TitleAsc|VoteScoreDesc)|visibility_(?:friends_only|private|public))|vertex_usage_(?:binormal|blendindices|blendweight|color|colour|depth|fog|normal|position|psize|sample|tangent|texcoord|textcoord)|vertex_type_(?:float\d|color|colour|ubyte4)|input_type|layerelementtype_(?:background|instance|oldtilemap|particlesystem|sprite|tile|tilemap|undefined)|se_(?:chorus|compressor|echo|equalizer|flanger|gargle|none|reverb)|text_type|tile_(?:flip|index_mask|mirror|rotate)|(?:obj|rm|scr|spr)\w+)\b/,
        variable: /\b(?:alarm|application_surface|async_load|background_(?:alpha|blend|color|colour|foreground|height|hspeed|htiled|index|showcolor|showcolour|visible|vspeed|vtiled|width|x|xscale|y|yscale)|bbox_(?:bottom|left|right|top)|browser_(?:height|width)|caption_(?:health|lives|score)|current_(?:day|hour|minute|month|second|time|weekday|year)|cursor_sprite|debug_mode|delta_time|direction|display_aa|error_(?:last|occurred)|event_(?:action|number|object|type)|fps|fps_real|friction|game_(?:display|project|save)_(?:id|name)|gamemaker_(?:pro|registered|version)|gravity|gravity_direction|(?:h|v)speed|health|iap_data|id|image_(?:alpha|angle|blend|depth|index|number|speed|xscale|yscale)|instance_(?:count|id)|keyboard_(?:key|lastchar|lastkey|string)|layer|lives|mask_index|mouse_(?:button|lastbutton|x|y)|object_index|os_(?:browser|device|type|version)|path_(?:endaction|index|orientation|position|positionprevious|scale|speed)|persistent|phy_(?:rotation|(?:col_normal|collision|com|linear_velocity|position|speed)_(?:x|y)|angular_(?:damping|velocity)|position_(?:x|y)previous|speed|linear_damping|bullet|fixed_rotation|active|mass|inertia|dynamic|kinematic|sleeping|collision_points)|pointer_(?:invalid|null)|room|room_(?:caption|first|height|last|persistent|speed|width)|score|secure_mode|show_(?:health|lives|score)|solid|speed|sprite_(?:height|index|width|xoffset|yoffset)|temp_directory|timeline_(?:index|loop|position|running|speed)|transition_(?:color|kind|steps)|undefined|view_(?:angle|current|enabled|(?:h|v)(?:border|speed)|(?:h|w|x|y)port|(?:h|w|x|y)view|object|surface_id|visible)|visible|webgl_enabled|working_directory|(?:x|y)(?:previous|start)|x|y|argument(?:_relitive|_count|\d)|argument|global|local|other|self)\b/
    });
}

});

parcelRequire.register("4wGAC", function(module, exports) {
"use strict";
module.exports = $34bb300474ae958d$var$gn;
$34bb300474ae958d$var$gn.displayName = "gn";
$34bb300474ae958d$var$gn.aliases = [
    "gni"
];
function $34bb300474ae958d$var$gn(Prism) {
    // https://gn.googlesource.com/gn/+/refs/heads/main/docs/reference.md#grammar
    Prism.languages.gn = {
        comment: {
            pattern: /#.*/,
            greedy: true
        },
        "string-literal": {
            pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
            lookbehind: true,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
                    lookbehind: true,
                    inside: {
                        number: /^\$0x[\s\S]{2}$/,
                        variable: /^\$\w+$/,
                        "interpolation-punctuation": {
                            pattern: /^\$\{|\}$/,
                            alias: "punctuation"
                        },
                        expression: {
                            pattern: /[\s\S]+/,
                            inside: null // see below
                        }
                    }
                },
                string: /[\s\S]+/
            }
        },
        keyword: /\b(?:else|if)\b/,
        boolean: /\b(?:false|true)\b/,
        "builtin-function": {
            // a few functions get special highlighting to improve readability
            pattern: /\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
            alias: "keyword"
        },
        function: /\b[a-z_]\w*(?=\s*\()/i,
        constant: /\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_os|target_out_dir)\b/,
        number: /-?\b\d+\b/,
        operator: /[-+!=<>]=?|&&|\|\|/,
        punctuation: /[(){}[\],.]/
    };
    Prism.languages.gn["string-literal"].inside["interpolation"].inside["expression"].inside = Prism.languages.gn;
    Prism.languages.gni = Prism.languages.gn;
}

});

parcelRequire.register("hriul", function(module, exports) {
"use strict";
module.exports = $cb234cb211e7010d$var$goModule;
$cb234cb211e7010d$var$goModule.displayName = "goModule";
$cb234cb211e7010d$var$goModule.aliases = [];
function $cb234cb211e7010d$var$goModule(Prism) {
    // https://go.dev/ref/mod#go-mod-file-module
    Prism.languages["go-mod"] = Prism.languages["go-module"] = {
        comment: {
            pattern: /\/\/.*/,
            greedy: true
        },
        version: {
            pattern: /(^|[\s()[\],])v\d+\.\d+\.\d+(?:[+-][-+.\w]*)?(?![^\s()[\],])/,
            lookbehind: true,
            alias: "number"
        },
        "go-version": {
            pattern: /((?:^|\s)go\s+)\d+(?:\.\d+){1,2}/,
            lookbehind: true,
            alias: "number"
        },
        keyword: {
            pattern: /^([ \t]*)(?:exclude|go|module|replace|require|retract)\b/m,
            lookbehind: true
        },
        operator: /=>/,
        punctuation: /[()[\],]/
    };
}

});

parcelRequire.register("47CJF", function(module, exports) {
"use strict";
module.exports = $3005dcf751977778$var$go;
$3005dcf751977778$var$go.displayName = "go";
$3005dcf751977778$var$go.aliases = [];
function $3005dcf751977778$var$go(Prism) {
    Prism.languages.go = Prism.languages.extend("clike", {
        string: {
            pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
            lookbehind: true,
            greedy: true
        },
        keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
        boolean: /\b(?:_|false|iota|nil|true)\b/,
        number: [
            // binary and octal integers
            /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
            /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
            /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
        ],
        operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
        builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
    });
    Prism.languages.insertBefore("go", "string", {
        char: {
            pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
            greedy: true
        }
    });
    delete Prism.languages.go["class-name"];
}

});

parcelRequire.register("aIJdK", function(module, exports) {
"use strict";
module.exports = $7ce11757f6b8206f$var$graphql;
$7ce11757f6b8206f$var$graphql.displayName = "graphql";
$7ce11757f6b8206f$var$graphql.aliases = [];
function $7ce11757f6b8206f$var$graphql(Prism) {
    Prism.languages.graphql = {
        comment: /#.*/,
        description: {
            pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
            greedy: true,
            alias: "string",
            inside: {
                "language-markdown": {
                    pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
                    lookbehind: true,
                    inside: Prism.languages.markdown
                }
            }
        },
        string: {
            pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
            greedy: true
        },
        number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        boolean: /\b(?:false|true)\b/,
        variable: /\$[a-z_]\w*/i,
        directive: {
            pattern: /@[a-z_]\w*/i,
            alias: "function"
        },
        "attr-name": {
            pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
            greedy: true
        },
        "atom-input": {
            pattern: /\b[A-Z]\w*Input\b/,
            alias: "class-name"
        },
        scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
        constant: /\b[A-Z][A-Z_\d]*\b/,
        "class-name": {
            pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
            lookbehind: true
        },
        fragment: {
            pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
            lookbehind: true,
            alias: "function"
        },
        "definition-mutation": {
            pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
            lookbehind: true,
            alias: "function"
        },
        "definition-query": {
            pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
            lookbehind: true,
            alias: "function"
        },
        keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
        operator: /[!=|&]|\.{3}/,
        "property-query": /\w+(?=\s*\()/,
        object: /\w+(?=\s*\{)/,
        punctuation: /[!(){}\[\]:=,]/,
        property: /\w+/
    };
    Prism.hooks.add("after-tokenize", function afterTokenizeGraphql(env) {
        if (env.language !== "graphql") return;
        /**
     * get the graphql token stream that we want to customize
     *
     * @typedef {InstanceType<import("./prism-core")["Token"]>} Token
     * @type {Token[]}
     */ var validTokens = env.tokens.filter(function(token) {
            return typeof token !== "string" && token.type !== "comment" && token.type !== "scalar";
        });
        var currentIndex = 0;
        /**
     * Returns whether the token relative to the current index has the given type.
     *
     * @param {number} offset
     * @returns {Token | undefined}
     */ function getToken(offset) {
            return validTokens[currentIndex + offset];
        }
        /**
     * Returns whether the token relative to the current index has the given type.
     *
     * @param {readonly string[]} types
     * @param {number} [offset=0]
     * @returns {boolean}
     */ function isTokenType(types, offset) {
            offset = offset || 0;
            for(var i = 0; i < types.length; i++){
                var token = getToken(i + offset);
                if (!token || token.type !== types[i]) return false;
            }
            return true;
        }
        /**
     * Returns the index of the closing bracket to an opening bracket.
     *
     * It is assumed that `token[currentIndex - 1]` is an opening bracket.
     *
     * If no closing bracket could be found, `-1` will be returned.
     *
     * @param {RegExp} open
     * @param {RegExp} close
     * @returns {number}
     */ function findClosingBracket(open, close) {
            var stackHeight = 1;
            for(var i = currentIndex; i < validTokens.length; i++){
                var token = validTokens[i];
                var content = token.content;
                if (token.type === "punctuation" && typeof content === "string") {
                    if (open.test(content)) stackHeight++;
                    else if (close.test(content)) {
                        stackHeight--;
                        if (stackHeight === 0) return i;
                    }
                }
            }
            return -1;
        }
        /**
     * Adds an alias to the given token.
     *
     * @param {Token} token
     * @param {string} alias
     * @returns {void}
     */ function addAlias(token, alias) {
            var aliases = token.alias;
            if (!aliases) token.alias = aliases = [];
            else if (!Array.isArray(aliases)) token.alias = aliases = [
                aliases
            ];
            aliases.push(alias);
        }
        for(; currentIndex < validTokens.length;){
            var startToken = validTokens[currentIndex++] // add special aliases for mutation tokens
            ;
            if (startToken.type === "keyword" && startToken.content === "mutation") {
                // any array of the names of all input variables (if any)
                var inputVariables = [];
                if (isTokenType([
                    "definition-mutation",
                    "punctuation"
                ]) && getToken(1).content === "(") {
                    // definition
                    currentIndex += 2 // skip 'definition-mutation' and 'punctuation'
                    ;
                    var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
                    if (definitionEnd === -1) continue;
                     // find all input variables
                    for(; currentIndex < definitionEnd; currentIndex++){
                        var t = getToken(0);
                        if (t.type === "variable") {
                            addAlias(t, "variable-input");
                            inputVariables.push(t.content);
                        }
                    }
                    currentIndex = definitionEnd + 1;
                }
                if (isTokenType([
                    "punctuation",
                    "property-query"
                ]) && getToken(0).content === "{") {
                    currentIndex++ // skip opening bracket
                    ;
                    addAlias(getToken(0), "property-mutation");
                    if (inputVariables.length > 0) {
                        var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
                        if (mutationEnd === -1) continue;
                         // give references to input variables a special alias
                        for(var i1 = currentIndex; i1 < mutationEnd; i1++){
                            var varToken = validTokens[i1];
                            if (varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0) addAlias(varToken, "variable-input");
                        }
                    }
                }
            }
        }
    });
}

});

parcelRequire.register("g2hj8", function(module, exports) {
"use strict";
module.exports = $baca4227c5aaaac8$var$groovy;
$baca4227c5aaaac8$var$groovy.displayName = "groovy";
$baca4227c5aaaac8$var$groovy.aliases = [];
function $baca4227c5aaaac8$var$groovy(Prism) {
    Prism.languages.groovy = Prism.languages.extend("clike", {
        string: [
            {
                // https://groovy-lang.org/syntax.html#_dollar_slashy_string
                pattern: /("""|''')(?:[^\\]|\\[\s\S])*?\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
                greedy: true
            },
            {
                // TODO: Slash strings (e.g. /foo/) can contain line breaks but this will cause a lot of trouble with
                // simple division (see JS regex), so find a fix maybe?
                pattern: /(["'/])(?:\\.|(?!\1)[^\\\r\n])*\1/,
                greedy: true
            }
        ],
        keyword: /\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
        number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
        operator: {
            pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
            lookbehind: true
        },
        punctuation: /\.+|[{}[\];(),:$]/
    });
    Prism.languages.insertBefore("groovy", "string", {
        shebang: {
            pattern: /#!.+/,
            alias: "comment"
        }
    });
    Prism.languages.insertBefore("groovy", "punctuation", {
        "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/
    });
    Prism.languages.insertBefore("groovy", "function", {
        annotation: {
            pattern: /(^|[^.])@\w+/,
            lookbehind: true,
            alias: "punctuation"
        }
    }) // Handle string interpolation
    ;
    Prism.hooks.add("wrap", function(env) {
        if (env.language === "groovy" && env.type === "string") {
            var delimiter = env.content.value[0];
            if (delimiter != "'") {
                var pattern = /([^\\])(?:\$(?:\{.*?\}|[\w.]+))/;
                if (delimiter === "$") pattern = /([^\$])(?:\$(?:\{.*?\}|[\w.]+))/;
                 // To prevent double HTML-encoding we have to decode env.content first
                env.content.value = env.content.value.replace(/&lt;/g, "<").replace(/&amp;/g, "&");
                env.content = Prism.highlight(env.content.value, {
                    expression: {
                        pattern: pattern,
                        lookbehind: true,
                        inside: Prism.languages.groovy
                    }
                });
                env.classes.push(delimiter === "/" ? "regex" : "gstring");
            }
        }
    });
}

});

parcelRequire.register("erJ4y", function(module, exports) {
"use strict";

var $46l9U = parcelRequire("46l9U");
module.exports = $a8468cc190e5c0b0$var$haml;
$a8468cc190e5c0b0$var$haml.displayName = "haml";
$a8468cc190e5c0b0$var$haml.aliases = [];
function $a8468cc190e5c0b0$var$haml(Prism1) {
    Prism1.register($46l9U) /* TODO
Handle multiline code after tag
%foo= some |
multiline |
code |
*/ ;
    (function(Prism) {
        Prism.languages.haml = {
            // Multiline stuff should appear before the rest
            "multiline-comment": {
                pattern: /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ].+)*/,
                lookbehind: true,
                alias: "comment"
            },
            "multiline-code": [
                {
                    pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
                    lookbehind: true,
                    inside: Prism.languages.ruby
                },
                {
                    pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
                    lookbehind: true,
                    inside: Prism.languages.ruby
                }
            ],
            // See at the end of the file for known filters
            filter: {
                pattern: /((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/,
                lookbehind: true,
                inside: {
                    "filter-name": {
                        pattern: /^:[\w-]+/,
                        alias: "symbol"
                    }
                }
            },
            markup: {
                pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
                lookbehind: true,
                inside: Prism.languages.markup
            },
            doctype: {
                pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
                lookbehind: true
            },
            tag: {
                // Allows for one nested group of braces
                pattern: /((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^{}])+\}|\[[^\]]+\])*[\/<>]*/,
                lookbehind: true,
                inside: {
                    attributes: [
                        {
                            // Lookbehind tries to prevent interpolations from breaking it all
                            // Allows for one nested group of braces
                            pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
                            lookbehind: true,
                            inside: Prism.languages.ruby
                        },
                        {
                            pattern: /\([^)]+\)/,
                            inside: {
                                "attr-value": {
                                    pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
                                    lookbehind: true
                                },
                                "attr-name": /[\w:-]+(?=\s*!?=|\s*[,)])/,
                                punctuation: /[=(),]/
                            }
                        },
                        {
                            pattern: /\[[^\]]+\]/,
                            inside: Prism.languages.ruby
                        }
                    ],
                    punctuation: /[<>]/
                }
            },
            code: {
                pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
                lookbehind: true,
                inside: Prism.languages.ruby
            },
            // Interpolations in plain text
            interpolation: {
                pattern: /#\{[^}]+\}/,
                inside: {
                    delimiter: {
                        pattern: /^#\{|\}$/,
                        alias: "punctuation"
                    },
                    ruby: {
                        pattern: /[\s\S]+/,
                        inside: Prism.languages.ruby
                    }
                }
            },
            punctuation: {
                pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
                lookbehind: true
            }
        };
        var filter_pattern = "((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+" // Non exhaustive list of available filters and associated languages
        ;
        var filters = [
            "css",
            {
                filter: "coffee",
                language: "coffeescript"
            },
            "erb",
            "javascript",
            "less",
            "markdown",
            "ruby",
            "scss",
            "textile"
        ];
        var all_filters = {};
        for(var i = 0, l = filters.length; i < l; i++){
            var filter = filters[i];
            filter = typeof filter === "string" ? {
                filter: filter,
                language: filter
            } : filter;
            if (Prism.languages[filter.language]) all_filters["filter-" + filter.filter] = {
                pattern: RegExp(filter_pattern.replace("{{filter_name}}", function() {
                    return filter.filter;
                })),
                lookbehind: true,
                inside: {
                    "filter-name": {
                        pattern: /^:[\w-]+/,
                        alias: "symbol"
                    },
                    text: {
                        pattern: /[\s\S]+/,
                        alias: [
                            filter.language,
                            "language-" + filter.language
                        ],
                        inside: Prism.languages[filter.language]
                    }
                }
            };
        }
        Prism.languages.insertBefore("haml", "filter", all_filters);
    })(Prism1);
}

});

parcelRequire.register("4Xokg", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");
module.exports = $39bf8ab2c9037209$var$handlebars;
$39bf8ab2c9037209$var$handlebars.displayName = "handlebars";
$39bf8ab2c9037209$var$handlebars.aliases = [
    "hbs"
];
function $39bf8ab2c9037209$var$handlebars(Prism1) {
    Prism1.register($cekeD);
    (function(Prism) {
        Prism.languages.handlebars = {
            comment: /\{\{![\s\S]*?\}\}/,
            delimiter: {
                pattern: /^\{\{\{?|\}\}\}?$/,
                alias: "punctuation"
            },
            string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
            boolean: /\b(?:false|true)\b/,
            block: {
                pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
                lookbehind: true,
                alias: "keyword"
            },
            brackets: {
                pattern: /\[[^\]]+\]/,
                inside: {
                    punctuation: /\[|\]/,
                    variable: /[\s\S]+/
                }
            },
            punctuation: /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
            variable: /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
        };
        Prism.hooks.add("before-tokenize", function(env) {
            var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
            Prism.languages["markup-templating"].buildPlaceholders(env, "handlebars", handlebarsPattern);
        });
        Prism.hooks.add("after-tokenize", function(env) {
            Prism.languages["markup-templating"].tokenizePlaceholders(env, "handlebars");
        });
        Prism.languages.hbs = Prism.languages.handlebars;
    })(Prism1);
}

});

parcelRequire.register("2X73H", function(module, exports) {
"use strict";
module.exports = $2266912ec228ad3a$var$haskell;
$2266912ec228ad3a$var$haskell.displayName = "haskell";
$2266912ec228ad3a$var$haskell.aliases = [
    "hs"
];
function $2266912ec228ad3a$var$haskell(Prism) {
    Prism.languages.haskell = {
        comment: {
            pattern: /(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\/].*|$)|\{-[\s\S]*?-\})/m,
            lookbehind: true
        },
        char: {
            pattern: /'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|ACK|BEL|BS|CAN|CR|DC1|DC2|DC3|DC4|DEL|DLE|EM|ENQ|EOT|ESC|ETB|ETX|FF|FS|GS|HT|LF|NAK|NUL|RS|SI|SO|SOH|SP|STX|SUB|SYN|US|VT|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
            alias: "string"
        },
        string: {
            pattern: /"(?:[^\\"]|\\(?:\S|\s+\\))*"/,
            greedy: true
        },
        keyword: /\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
        "import-statement": {
            // The imported or hidden names are not included in this import
            // statement. This is because we want to highlight those exactly like
            // we do for the names in the program.
            pattern: /(^[\t ]*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
            lookbehind: true,
            inside: {
                keyword: /\b(?:as|hiding|import|qualified)\b/,
                punctuation: /\./
            }
        },
        // These are builtin variables only. Constructors are highlighted later as a constant.
        builtin: /\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
        // decimal integers and floating point numbers | octal integers | hexadecimal integers
        number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
        operator: [
            {
                // infix operator
                pattern: /`(?:[A-Z][\w']*\.)*[_a-z][\w']*`/,
                greedy: true
            },
            {
                // function composition
                pattern: /(\s)\.(?=\s)/,
                lookbehind: true
            },
            // If it stands alone freely, it is the function composition.
            // It may also be a separator between a module name and an identifier => no
            // operator. If it comes together with other special characters it is an
            // operator too.
            //
            // This regex means: /[-!#$%*+=?&@|~.:<>^\\\/]+/ without /\./.
            /[-!#$%*+=?&@|~:<>^\\\/][-!#$%*+=?&@|~.:<>^\\\/]*|\.[-!#$%*+=?&@|~.:<>^\\\/]+/
        ],
        // In Haskell, nearly everything is a variable, do not highlight these.
        hvariable: {
            pattern: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*/,
            inside: {
                punctuation: /\./
            }
        },
        constant: {
            pattern: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*/,
            inside: {
                punctuation: /\./
            }
        },
        punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.hs = Prism.languages.haskell;
}

});

parcelRequire.register("88lVj", function(module, exports) {
"use strict";
module.exports = $5ec0139aad408049$var$haxe;
$5ec0139aad408049$var$haxe.displayName = "haxe";
$5ec0139aad408049$var$haxe.aliases = [];
function $5ec0139aad408049$var$haxe(Prism) {
    Prism.languages.haxe = Prism.languages.extend("clike", {
        string: {
            // Strings can be multi-line
            pattern: /"(?:[^"\\]|\\[\s\S])*"/,
            greedy: true
        },
        "class-name": [
            {
                pattern: /(\b(?:abstract|class|enum|extends|implements|interface|new|typedef)\s+)[A-Z_]\w*/,
                lookbehind: true
            },
            /\b[A-Z]\w*/
        ],
        // The final look-ahead prevents highlighting of keywords if expressions such as "haxe.macro.Expr"
        keyword: /\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|final|for|from|function|if|implements|import|in|inline|interface|macro|new|null|operator|overload|override|package|private|public|return|static|super|switch|throw|to|try|typedef|untyped|using|var|while)(?!\.)\b/,
        function: {
            pattern: /\b[a-z_]\w*(?=\s*(?:<[^<>]*>\s*)?\()/i,
            greedy: true
        },
        operator: /\.{3}|\+\+|--|&&|\|\||->|=>|(?:<<?|>{1,3}|[-+*/%!=&|^])=?|[?:~]/
    });
    Prism.languages.insertBefore("haxe", "string", {
        "string-interpolation": {
            pattern: /'(?:[^'\\]|\\[\s\S])*'/,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: /(^|[^\\])\$(?:\w+|\{[^{}]+\})/,
                    lookbehind: true,
                    inside: {
                        "interpolation-punctuation": {
                            pattern: /^\$\{?|\}$/,
                            alias: "punctuation"
                        },
                        expression: {
                            pattern: /[\s\S]+/,
                            inside: Prism.languages.haxe
                        }
                    }
                },
                string: /[\s\S]+/
            }
        }
    });
    Prism.languages.insertBefore("haxe", "class-name", {
        regex: {
            pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[a-z]*/,
            greedy: true,
            inside: {
                "regex-flags": /\b[a-z]+$/,
                "regex-source": {
                    pattern: /^(~\/)[\s\S]+(?=\/$)/,
                    lookbehind: true,
                    alias: "language-regex",
                    inside: Prism.languages.regex
                },
                "regex-delimiter": /^~\/|\/$/
            }
        }
    });
    Prism.languages.insertBefore("haxe", "keyword", {
        preprocessor: {
            pattern: /#(?:else|elseif|end|if)\b.*/,
            alias: "property"
        },
        metadata: {
            pattern: /@:?[\w.]+/,
            alias: "symbol"
        },
        reification: {
            pattern: /\$(?:\w+|(?=\{))/,
            alias: "important"
        }
    });
}

});

parcelRequire.register("4djgk", function(module, exports) {
"use strict";
module.exports = $31175166605f3331$var$hcl;
$31175166605f3331$var$hcl.displayName = "hcl";
$31175166605f3331$var$hcl.aliases = [];
function $31175166605f3331$var$hcl(Prism) {
    Prism.languages.hcl = {
        comment: /(?:\/\/|#).*|\/\*[\s\S]*?(?:\*\/|$)/,
        heredoc: {
            pattern: /<<-?(\w+\b)[\s\S]*?^[ \t]*\1/m,
            greedy: true,
            alias: "string"
        },
        keyword: [
            {
                pattern: /(?:data|resource)\s+(?:"(?:\\[\s\S]|[^\\"])*")(?=\s+"[\w-]+"\s+\{)/i,
                inside: {
                    type: {
                        pattern: /(resource|data|\s+)(?:"(?:\\[\s\S]|[^\\"])*")/i,
                        lookbehind: true,
                        alias: "variable"
                    }
                }
            },
            {
                pattern: /(?:backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+(?=\{)/i,
                inside: {
                    type: {
                        pattern: /(backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+/i,
                        lookbehind: true,
                        alias: "variable"
                    }
                }
            },
            /[\w-]+(?=\s+\{)/
        ],
        property: [
            /[-\w\.]+(?=\s*=(?!=))/,
            /"(?:\\[\s\S]|[^\\"])+"(?=\s*[:=])/
        ],
        string: {
            pattern: /"(?:[^\\$"]|\\[\s\S]|\$(?:(?=")|\$+(?!\$)|[^"${])|\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\})*"/,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: /(^|[^$])\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\}/,
                    lookbehind: true,
                    inside: {
                        type: {
                            pattern: /(\b(?:count|data|local|module|path|self|terraform|var)\b\.)[\w\*]+/i,
                            lookbehind: true,
                            alias: "variable"
                        },
                        keyword: /\b(?:count|data|local|module|path|self|terraform|var)\b/i,
                        function: /\w+(?=\()/,
                        string: {
                            pattern: /"(?:\\[\s\S]|[^\\"])*"/,
                            greedy: true
                        },
                        number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
                        punctuation: /[!\$#%&'()*+,.\/;<=>@\[\\\]^`{|}~?:]/
                    }
                }
            }
        },
        number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
        boolean: /\b(?:false|true)\b/i,
        punctuation: /[=\[\]{}]/
    };
}

});

parcelRequire.register("crcxS", function(module, exports) {
"use strict";

var $bEqqd = parcelRequire("bEqqd");
module.exports = $90e1bce7d535605c$var$hlsl;
$90e1bce7d535605c$var$hlsl.displayName = "hlsl";
$90e1bce7d535605c$var$hlsl.aliases = [];
function $90e1bce7d535605c$var$hlsl(Prism) {
    Prism.register($bEqqd);
    Prism.languages.hlsl = Prism.languages.extend("c", {
        // Regarding keywords and class names:
        // The list of all keywords was split into 'keyword' and 'class-name' tokens based on whether they are capitalized.
        // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-keywords
        // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-reserved-words
        "class-name": [
            Prism.languages.c["class-name"],
            /\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\b/
        ],
        keyword: [
            // HLSL keyword
            /\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\b/,
            /\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\b/
        ],
        // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-grammar#floating-point-numbers
        number: /(?:(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?|\b0x[\da-fA-F]+)[fFhHlLuU]?\b/,
        boolean: /\b(?:false|true)\b/
    });
}

});

parcelRequire.register("8HAPU", function(module, exports) {
"use strict";
module.exports = $655ee9c4741a24dd$var$hoon;
$655ee9c4741a24dd$var$hoon.displayName = "hoon";
$655ee9c4741a24dd$var$hoon.aliases = [];
function $655ee9c4741a24dd$var$hoon(Prism) {
    Prism.languages.hoon = {
        comment: {
            pattern: /::.*/,
            greedy: true
        },
        string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
        },
        constant: /%(?:\.[ny]|[\w-]+)/,
        "class-name": /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
        function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
        keyword: /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
    };
}

});

parcelRequire.register("5LEXG", function(module, exports) {
"use strict";
module.exports = $43311daeae489cee$var$hpkp;
$43311daeae489cee$var$hpkp.displayName = "hpkp";
$43311daeae489cee$var$hpkp.aliases = [];
function $43311daeae489cee$var$hpkp(Prism) {
    /**
   * Original by Scott Helme.
   *
   * Reference: https://scotthelme.co.uk/hpkp-cheat-sheet/
   */ Prism.languages.hpkp = {
        directive: {
            pattern: /\b(?:includeSubDomains|max-age|pin-sha256|preload|report-to|report-uri|strict)(?=[\s;=]|$)/i,
            alias: "property"
        },
        operator: /=/,
        punctuation: /;/
    };
}

});

parcelRequire.register("eK8Jr", function(module, exports) {
"use strict";
module.exports = $abbc22867ba11a2d$var$hsts;
$abbc22867ba11a2d$var$hsts.displayName = "hsts";
$abbc22867ba11a2d$var$hsts.aliases = [];
function $abbc22867ba11a2d$var$hsts(Prism) {
    /**
   * Original by Scott Helme.
   *
   * Reference: https://scotthelme.co.uk/hsts-cheat-sheet/
   */ Prism.languages.hsts = {
        directive: {
            pattern: /\b(?:includeSubDomains|max-age|preload)(?=[\s;=]|$)/i,
            alias: "property"
        },
        operator: /=/,
        punctuation: /;/
    };
}

});

parcelRequire.register("8tt6J", function(module, exports) {
"use strict";
module.exports = $62b79c52a7caefcf$var$http;
$62b79c52a7caefcf$var$http.displayName = "http";
$62b79c52a7caefcf$var$http.aliases = [];
function $62b79c52a7caefcf$var$http(Prism1) {
    (function(Prism) {
        /**
     * @param {string} name
     * @returns {RegExp}
     */ function headerValueOf(name) {
            return RegExp("(^(?:" + name + "):[ 	]*(?![ 	]))[^]+", "i");
        }
        Prism.languages.http = {
            "request-line": {
                pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
                inside: {
                    // HTTP Method
                    method: {
                        pattern: /^[A-Z]+\b/,
                        alias: "property"
                    },
                    // Request Target e.g. http://example.com, /path/to/file
                    "request-target": {
                        pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
                        lookbehind: true,
                        alias: "url",
                        inside: Prism.languages.uri
                    },
                    // HTTP Version
                    "http-version": {
                        pattern: /^(\s)HTTP\/[\d.]+/,
                        lookbehind: true,
                        alias: "property"
                    }
                }
            },
            "response-status": {
                pattern: /^HTTP\/[\d.]+ \d+ .+/m,
                inside: {
                    // HTTP Version
                    "http-version": {
                        pattern: /^HTTP\/[\d.]+/,
                        alias: "property"
                    },
                    // Status Code
                    "status-code": {
                        pattern: /^(\s)\d+(?=\s)/,
                        lookbehind: true,
                        alias: "number"
                    },
                    // Reason Phrase
                    "reason-phrase": {
                        pattern: /^(\s).+/,
                        lookbehind: true,
                        alias: "string"
                    }
                }
            },
            header: {
                pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
                inside: {
                    "header-value": [
                        {
                            pattern: headerValueOf(/Content-Security-Policy/.source),
                            lookbehind: true,
                            alias: [
                                "csp",
                                "languages-csp"
                            ],
                            inside: Prism.languages.csp
                        },
                        {
                            pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),
                            lookbehind: true,
                            alias: [
                                "hpkp",
                                "languages-hpkp"
                            ],
                            inside: Prism.languages.hpkp
                        },
                        {
                            pattern: headerValueOf(/Strict-Transport-Security/.source),
                            lookbehind: true,
                            alias: [
                                "hsts",
                                "languages-hsts"
                            ],
                            inside: Prism.languages.hsts
                        },
                        {
                            pattern: headerValueOf(/[^:]+/.source),
                            lookbehind: true
                        }
                    ],
                    "header-name": {
                        pattern: /^[^:]+/,
                        alias: "keyword"
                    },
                    punctuation: /^:/
                }
            }
        } // Create a mapping of Content-Type headers to language definitions
        ;
        var langs = Prism.languages;
        var httpLanguages = {
            "application/javascript": langs.javascript,
            "application/json": langs.json || langs.javascript,
            "application/xml": langs.xml,
            "text/xml": langs.xml,
            "text/html": langs.html,
            "text/css": langs.css,
            "text/plain": langs.plain
        } // Declare which types can also be suffixes
        ;
        var suffixTypes = {
            "application/json": true,
            "application/xml": true
        };
        /**
     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.
     *
     * @param {string} contentType
     * @returns {string}
     */ function getSuffixPattern(contentType) {
            var suffix = contentType.replace(/^[a-z]+\//, "");
            var suffixPattern = "\\w+/(?:[\\w.-]+\\+)+" + suffix + "(?![+\\w.-])";
            return "(?:" + contentType + "|" + suffixPattern + ")";
        } // Insert each content type parser that has its associated language
        // currently loaded.
        var options;
        for(var contentType1 in httpLanguages)if (httpLanguages[contentType1]) {
            options = options || {};
            var pattern = suffixTypes[contentType1] ? getSuffixPattern(contentType1) : contentType1;
            options[contentType1.replace(/\//g, "-")] = {
                pattern: RegExp("(" + /content-type:\s*/.source + pattern + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
                // However, when writing code by hand (e.g. to display on a website) people can forget about this,
                // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
                // the body does not start with a [\w-] character (as headers do).
                /[^ \t\w-][\s\S]*/.source, "i"),
                lookbehind: true,
                inside: httpLanguages[contentType1]
            };
        }
        if (options) Prism.languages.insertBefore("http", "header", options);
    })(Prism1);
}

});

parcelRequire.register("aBVFT", function(module, exports) {
"use strict";
module.exports = $7b9a1913df7f994f$var$ichigojam;
$7b9a1913df7f994f$var$ichigojam.displayName = "ichigojam";
$7b9a1913df7f994f$var$ichigojam.aliases = [];
function $7b9a1913df7f994f$var$ichigojam(Prism) {
    // according to the offical reference (EN)
    // https://ichigojam.net/IchigoJam-en.html
    Prism.languages.ichigojam = {
        comment: /(?:\B'|REM)(?:[^\n\r]*)/i,
        string: {
            pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
            greedy: true
        },
        number: /\B#[0-9A-F]+|\B`[01]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
        keyword: /\b(?:BEEP|BPS|CASE|CLEAR|CLK|CLO|CLP|CLS|CLT|CLV|CONT|COPY|ELSE|END|FILE|FILES|FOR|GOSUB|GOTO|GSB|IF|INPUT|KBD|LED|LET|LIST|LOAD|LOCATE|LRUN|NEW|NEXT|OUT|PLAY|POKE|PRINT|PWM|REM|RENUM|RESET|RETURN|RIGHT|RTN|RUN|SAVE|SCROLL|SLEEP|SRND|STEP|STOP|SUB|TEMPO|THEN|TO|UART|VIDEO|WAIT)(?:\$|\b)/i,
        function: /\b(?:ABS|ANA|ASC|BIN|BTN|DEC|END|FREE|HELP|HEX|I2CR|I2CW|IN|INKEY|LEN|LINE|PEEK|RND|SCR|SOUND|STR|TICK|USR|VER|VPEEK|ZER)(?:\$|\b)/i,
        label: /(?:\B@\S+)/,
        operator: /<[=>]?|>=?|\|\||&&|[+\-*\/=|&^~!]|\b(?:AND|NOT|OR)\b/i,
        punctuation: /[\[,;:()\]]/
    };
}

});

parcelRequire.register("b87lY", function(module, exports) {
"use strict";
module.exports = $81a6254b22d78a98$var$icon;
$81a6254b22d78a98$var$icon.displayName = "icon";
$81a6254b22d78a98$var$icon.aliases = [];
function $81a6254b22d78a98$var$icon(Prism) {
    Prism.languages.icon = {
        comment: /#.*/,
        string: {
            pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
            greedy: true
        },
        number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
        "builtin-keyword": {
            pattern: /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
            alias: "variable"
        },
        directive: {
            pattern: /\$\w+/,
            alias: "builtin"
        },
        keyword: /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
        function: /\b(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
        operator: /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
        punctuation: /[\[\](){},;]/
    };
}

});

parcelRequire.register("fIpze", function(module, exports) {
"use strict";
module.exports = $b70ecc3595b8de05$var$icuMessageFormat;
$b70ecc3595b8de05$var$icuMessageFormat.displayName = "icuMessageFormat";
$b70ecc3595b8de05$var$icuMessageFormat.aliases = [];
function $b70ecc3595b8de05$var$icuMessageFormat(Prism1) {
    (function(Prism) {
        /**
     * @param {string} source
     * @param {number} level
     * @returns {string}
     */ function nested(source, level) {
            if (level <= 0) return /[]/.source;
            else return source.replace(/<SELF>/g, function() {
                return nested(source, level - 1);
            });
        }
        var stringPattern = /'[{}:=,](?:[^']|'')*'(?!')/;
        var escape = {
            pattern: /''/,
            greedy: true,
            alias: "operator"
        };
        var string = {
            pattern: stringPattern,
            greedy: true,
            inside: {
                escape: escape
            }
        };
        var argumentSource = nested(/\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(/<STR>/g, function() {
            return stringPattern.source;
        }), 8);
        var nestedMessage = {
            pattern: RegExp(argumentSource),
            inside: {
                message: {
                    pattern: /^(\{)[\s\S]+(?=\}$)/,
                    lookbehind: true,
                    inside: null // see below
                },
                "message-delimiter": {
                    pattern: /./,
                    alias: "punctuation"
                }
            }
        };
        Prism.languages["icu-message-format"] = {
            argument: {
                pattern: RegExp(argumentSource),
                greedy: true,
                inside: {
                    content: {
                        pattern: /^(\{)[\s\S]+(?=\}$)/,
                        lookbehind: true,
                        inside: {
                            "argument-name": {
                                pattern: /^(\s*)[^{}:=,\s]+/,
                                lookbehind: true
                            },
                            "choice-style": {
                                // https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1ChoiceFormat.html#details
                                pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
                                lookbehind: true,
                                inside: {
                                    punctuation: /\|/,
                                    range: {
                                        pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
                                        lookbehind: true,
                                        inside: {
                                            operator: /[<#\u2264]/,
                                            number: /\S+/
                                        }
                                    },
                                    rest: null // see below
                                }
                            },
                            "plural-style": {
                                // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/PluralFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                                pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
                                lookbehind: true,
                                inside: {
                                    offset: /^offset:\s*\d+/,
                                    "nested-message": nestedMessage,
                                    selector: {
                                        pattern: /=\d+|[^{}:=,\s]+/,
                                        inside: {
                                            keyword: /^(?:few|many|one|other|two|zero)$/
                                        }
                                    }
                                }
                            },
                            "select-style": {
                                // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/SelectFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                                pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
                                lookbehind: true,
                                inside: {
                                    "nested-message": nestedMessage,
                                    selector: {
                                        pattern: /[^{}:=,\s]+/,
                                        inside: {
                                            keyword: /^other$/
                                        }
                                    }
                                }
                            },
                            keyword: /\b(?:choice|plural|select|selectordinal)\b/,
                            "arg-type": {
                                pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/,
                                alias: "keyword"
                            },
                            "arg-skeleton": {
                                pattern: /(,\s*)::[^{}:=,\s]+/,
                                lookbehind: true
                            },
                            "arg-style": {
                                pattern: /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/,
                                lookbehind: true
                            },
                            "arg-style-text": {
                                pattern: RegExp(/(^\s*,\s*(?=\S))/.source + nested(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) + "$"),
                                lookbehind: true,
                                alias: "string"
                            },
                            punctuation: /,/
                        }
                    },
                    "argument-delimiter": {
                        pattern: /./,
                        alias: "operator"
                    }
                }
            },
            escape: escape,
            string: string
        };
        nestedMessage.inside.message.inside = Prism.languages["icu-message-format"];
        Prism.languages["icu-message-format"].argument.inside.content.inside["choice-style"].inside.rest = Prism.languages["icu-message-format"];
    })(Prism1);
}

});

parcelRequire.register("dhBfq", function(module, exports) {
"use strict";

var $2X73H = parcelRequire("2X73H");
module.exports = $9ab9c182bdfdaf3a$var$idris;
$9ab9c182bdfdaf3a$var$idris.displayName = "idris";
$9ab9c182bdfdaf3a$var$idris.aliases = [
    "idr"
];
function $9ab9c182bdfdaf3a$var$idris(Prism) {
    Prism.register($2X73H);
    Prism.languages.idris = Prism.languages.extend("haskell", {
        comment: {
            pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m
        },
        keyword: /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
        builtin: undefined
    });
    Prism.languages.insertBefore("idris", "keyword", {
        "import-statement": {
            pattern: /(^\s*import\s+)(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
            lookbehind: true,
            inside: {
                punctuation: /\./
            }
        }
    });
    Prism.languages.idr = Prism.languages.idris;
}

});

parcelRequire.register("ignak", function(module, exports) {
"use strict";
module.exports = $d4bbb0d238e34b67$var$iecst;
$d4bbb0d238e34b67$var$iecst.displayName = "iecst";
$d4bbb0d238e34b67$var$iecst.aliases = [];
function $d4bbb0d238e34b67$var$iecst(Prism) {
    Prism.languages.iecst = {
        comment: [
            {
                pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\(\*[\s\S]*?(?:\*\)|$)|\{[\s\S]*?(?:\}|$))/,
                lookbehind: true,
                greedy: true
            },
            {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        keyword: [
            /\b(?:END_)?(?:PROGRAM|CONFIGURATION|INTERFACE|FUNCTION_BLOCK|FUNCTION|ACTION|TRANSITION|TYPE|STRUCT|(?:INITIAL_)?STEP|NAMESPACE|LIBRARY|CHANNEL|FOLDER|RESOURCE|VAR_(?:ACCESS|CONFIG|EXTERNAL|GLOBAL|INPUT|IN_OUT|OUTPUT|TEMP)|VAR|METHOD|PROPERTY)\b/i,
            /\b(?:AT|BY|(?:END_)?(?:CASE|FOR|IF|REPEAT|WHILE)|CONSTANT|CONTINUE|DO|ELSE|ELSIF|EXIT|EXTENDS|FROM|GET|GOTO|IMPLEMENTS|JMP|NON_RETAIN|OF|PRIVATE|PROTECTED|PUBLIC|RETAIN|RETURN|SET|TASK|THEN|TO|UNTIL|USING|WITH|__CATCH|__ENDTRY|__FINALLY|__TRY)\b/
        ],
        "class-name": /\b(?:ANY|ARRAY|BOOL|BYTE|U?(?:D|L|S)?INT|(?:D|L)?WORD|DATE(?:_AND_TIME)?|DT|L?REAL|POINTER|STRING|TIME(?:_OF_DAY)?|TOD)\b/,
        address: {
            pattern: /%[IQM][XBWDL][\d.]*|%[IQ][\d.]*/,
            alias: "symbol"
        },
        number: /\b(?:16#[\da-f]+|2#[01_]+|0x[\da-f]+)\b|\b(?:D|DT|T|TOD)#[\d_shmd:]*|\b[A-Z]*#[\d.,_]*|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        boolean: /\b(?:FALSE|NULL|TRUE)\b/,
        operator: /S?R?:?=>?|&&?|\*\*?|<[=>]?|>=?|[-:^/+#]|\b(?:AND|EQ|EXPT|GE|GT|LE|LT|MOD|NE|NOT|OR|XOR)\b/,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        punctuation: /[()[\].,;]/
    };
}

});

parcelRequire.register("etUwY", function(module, exports) {
"use strict";
module.exports = $a8af9ff172ceecbd$var$ignore;
$a8af9ff172ceecbd$var$ignore.displayName = "ignore";
$a8af9ff172ceecbd$var$ignore.aliases = [
    "gitignore",
    "hgignore",
    "npmignore"
];
function $a8af9ff172ceecbd$var$ignore(Prism1) {
    (function(Prism) {
        Prism.languages.ignore = {
            // https://git-scm.com/docs/gitignore
            comment: /^#.*/m,
            entry: {
                pattern: /\S(?:.*(?:(?:\\ )|\S))?/,
                alias: "string",
                inside: {
                    operator: /^!|\*\*?|\?/,
                    regex: {
                        pattern: /(^|[^\\])\[[^\[\]]*\]/,
                        lookbehind: true
                    },
                    punctuation: /\//
                }
            }
        };
        Prism.languages.gitignore = Prism.languages.ignore;
        Prism.languages.hgignore = Prism.languages.ignore;
        Prism.languages.npmignore = Prism.languages.ignore;
    })(Prism1);
}

});

parcelRequire.register("aiic4", function(module, exports) {
"use strict";
module.exports = $77e9b2b21a251130$var$inform7;
$77e9b2b21a251130$var$inform7.displayName = "inform7";
$77e9b2b21a251130$var$inform7.aliases = [];
function $77e9b2b21a251130$var$inform7(Prism) {
    Prism.languages.inform7 = {
        string: {
            pattern: /"[^"]*"/,
            inside: {
                substitution: {
                    pattern: /\[[^\[\]]+\]/,
                    inside: {
                        delimiter: {
                            pattern: /\[|\]/,
                            alias: "punctuation"
                        } // See rest below
                    }
                }
            }
        },
        comment: {
            pattern: /\[[^\[\]]+\]/,
            greedy: true
        },
        title: {
            pattern: /^[ \t]*(?:book|chapter|part(?! of)|section|table|volume)\b.+/im,
            alias: "important"
        },
        number: {
            pattern: /(^|[^-])(?:\b\d+(?:\.\d+)?(?:\^\d+)?(?:(?!\d)\w+)?|\b(?:eight|eleven|five|four|nine|one|seven|six|ten|three|twelve|two))\b(?!-)/i,
            lookbehind: true
        },
        verb: {
            pattern: /(^|[^-])\b(?:answering|applying to|are|asking|attacking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:ing|s)?|consulting|contain(?:ing|s)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:s|ve|ving)|hold(?:ing|s)?|impl(?:ies|y)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:ing|s)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:ing|s)?|setting|showing|singing|sleeping|smelling|squeezing|support(?:ing|s)?|swearing|switching|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:ing|s)?|var(?:ies|y|ying)|waiting|waking|waving|wear(?:ing|s)?)\b(?!-)/i,
            lookbehind: true,
            alias: "operator"
        },
        keyword: {
            pattern: /(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|the story|unless)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
            lookbehind: true
        },
        property: {
            pattern: /(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: off| on)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
            lookbehind: true,
            alias: "symbol"
        },
        position: {
            pattern: /(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
            lookbehind: true,
            alias: "keyword"
        },
        type: {
            pattern: /(^|[^-])\b(?:actions?|activit(?:ies|y)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
            lookbehind: true,
            alias: "variable"
        },
        punctuation: /[.,:;(){}]/
    };
    Prism.languages.inform7["string"].inside["substitution"].inside.rest = Prism.languages.inform7 // We don't want the remaining text in the substitution to be highlighted as the string.
    ;
    Prism.languages.inform7["string"].inside["substitution"].inside.rest.text = {
        pattern: /\S(?:\s*\S)*/,
        alias: "comment"
    };
}

});

parcelRequire.register("5z5AY", function(module, exports) {
"use strict";
module.exports = $40d48fc0aff6c902$var$ini;
$40d48fc0aff6c902$var$ini.displayName = "ini";
$40d48fc0aff6c902$var$ini.aliases = [];
function $40d48fc0aff6c902$var$ini(Prism) {
    Prism.languages.ini = {
        /**
     * The component mimics the behavior of the Win32 API parser.
     *
     * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
     */ comment: {
            pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
            lookbehind: true
        },
        section: {
            pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
            lookbehind: true,
            inside: {
                "section-name": {
                    pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
                    lookbehind: true,
                    alias: "selector"
                },
                punctuation: /\[|\]/
            }
        },
        key: {
            pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
            lookbehind: true,
            alias: "attr-name"
        },
        value: {
            pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
            lookbehind: true,
            alias: "attr-value",
            inside: {
                "inner-value": {
                    pattern: /^("|').+(?=\1$)/,
                    lookbehind: true
                }
            }
        },
        punctuation: /=/
    };
}

});

parcelRequire.register("iiNcT", function(module, exports) {
"use strict";
module.exports = $d53013e3f37616bf$var$io;
$d53013e3f37616bf$var$io.displayName = "io";
$d53013e3f37616bf$var$io.aliases = [];
function $d53013e3f37616bf$var$io(Prism) {
    Prism.languages.io = {
        comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*|#.*)/,
            lookbehind: true,
            greedy: true
        },
        "triple-quoted-string": {
            pattern: /"""(?:\\[\s\S]|(?!""")[^\\])*"""/,
            greedy: true,
            alias: "string"
        },
        string: {
            pattern: /"(?:\\.|[^\\\r\n"])*"/,
            greedy: true
        },
        keyword: /\b(?:activate|activeCoroCount|asString|block|break|call|catch|clone|collectGarbage|compileString|continue|do|doFile|doMessage|doString|else|elseif|exit|for|foreach|forward|getEnvironmentVariable|getSlot|hasSlot|if|ifFalse|ifNil|ifNilEval|ifTrue|isActive|isNil|isResumable|list|message|method|parent|pass|pause|perform|performWithArgList|print|println|proto|raise|raiseResumable|removeSlot|resend|resume|schedulerSleepSeconds|self|sender|setSchedulerSleepSeconds|setSlot|shallowCopy|slotNames|super|system|then|thisBlock|thisContext|try|type|uniqueId|updateSlot|wait|while|write|yield)\b/,
        builtin: /\b(?:Array|AudioDevice|AudioMixer|BigNum|Block|Box|Buffer|CFunction|CGI|Color|Curses|DBM|DNSResolver|DOConnection|DOProxy|DOServer|Date|Directory|Duration|DynLib|Error|Exception|FFT|File|Fnmatch|Font|Future|GL|GLE|GLScissor|GLU|GLUCylinder|GLUQuadric|GLUSphere|GLUT|Host|Image|Importer|LinkList|List|Lobby|Locals|MD5|MP3Decoder|MP3Encoder|Map|Message|Movie|Notification|Number|Object|OpenGL|Point|Protos|Random|Regex|SGML|SGMLElement|SGMLParser|SQLite|Sequence|Server|ShowMessage|SleepyCat|SleepyCatCursor|Socket|SocketManager|Sound|Soup|Store|String|Tree|UDPSender|UPDReceiver|URL|User|Warning|WeakLink)\b/,
        boolean: /\b(?:false|nil|true)\b/,
        number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?/i,
        operator: /[=!*/%+\-^&|]=|>>?=?|<<?=?|:?:?=|\+\+?|--?|\*\*?|\/\/?|%|\|\|?|&&?|\b(?:and|not|or|return)\b|@@?|\?\??|\.\./,
        punctuation: /[{}[\];(),.:]/
    };
}

});

parcelRequire.register("b80S6", function(module, exports) {
"use strict";
module.exports = $81a11e212aa5315c$var$j;
$81a11e212aa5315c$var$j.displayName = "j";
$81a11e212aa5315c$var$j.aliases = [];
function $81a11e212aa5315c$var$j(Prism) {
    Prism.languages.j = {
        comment: {
            pattern: /\bNB\..*/,
            greedy: true
        },
        string: {
            pattern: /'(?:''|[^'\r\n])*'/,
            greedy: true
        },
        keyword: /\b(?:(?:CR|LF|adverb|conjunction|def|define|dyad|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
        verb: {
            // Negative look-ahead prevents bad highlighting
            // of ^: ;. =. =: !. !:
            pattern: /(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
            alias: "keyword"
        },
        number: /\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:ad|ar|[ejpx])_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_\b(?!\.))/,
        adverb: {
            pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,
            alias: "builtin"
        },
        operator: /[=a][.:]|_\./,
        conjunction: {
            pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
            alias: "variable"
        },
        punctuation: /[()]/
    };
}

});

parcelRequire.register("4co4r", function(module, exports) {
"use strict";
module.exports = $30eaf456fd6b9150$var$java;
$30eaf456fd6b9150$var$java.displayName = "java";
$30eaf456fd6b9150$var$java.aliases = [];
function $30eaf456fd6b9150$var$java(Prism1) {
    (function(Prism) {
        var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/ // full package (optional) + parent classes (optional)
        ;
        var classNamePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source // based on the java naming conventions
        ;
        var className = {
            pattern: RegExp(classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
            lookbehind: true,
            inside: {
                namespace: {
                    pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
                    inside: {
                        punctuation: /\./
                    }
                },
                punctuation: /\./
            }
        };
        Prism.languages.java = Prism.languages.extend("clike", {
            string: {
                pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
                lookbehind: true,
                greedy: true
            },
            "class-name": [
                className,
                {
                    // variables and parameters
                    // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
                    pattern: RegExp(classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),
                    lookbehind: true,
                    inside: className.inside
                }
            ],
            keyword: keywords,
            function: [
                Prism.languages.clike.function,
                {
                    pattern: /(::\s*)[a-z_]\w*/,
                    lookbehind: true
                }
            ],
            number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
            operator: {
                pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
                lookbehind: true
            }
        });
        Prism.languages.insertBefore("java", "string", {
            "triple-quoted-string": {
                // http://openjdk.java.net/jeps/355#Description
                pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
                greedy: true,
                alias: "string"
            },
            char: {
                pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
                greedy: true
            }
        });
        Prism.languages.insertBefore("java", "class-name", {
            annotation: {
                pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
                lookbehind: true,
                alias: "punctuation"
            },
            generics: {
                pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
                inside: {
                    "class-name": className,
                    keyword: keywords,
                    punctuation: /[<>(),.:]/,
                    operator: /[?&|]/
                }
            },
            namespace: {
                pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
                    return keywords.source;
                })),
                lookbehind: true,
                inside: {
                    punctuation: /\./
                }
            }
        });
    })(Prism1);
}

});

parcelRequire.register("jvX8S", function(module, exports) {
"use strict";

var $4co4r = parcelRequire("4co4r");

var $krlJ1 = parcelRequire("krlJ1");
module.exports = $03aa8fa52704ee25$var$javadoc;
$03aa8fa52704ee25$var$javadoc.displayName = "javadoc";
$03aa8fa52704ee25$var$javadoc.aliases = [];
function $03aa8fa52704ee25$var$javadoc(Prism1) {
    Prism1.register($4co4r);
    Prism1.register($krlJ1);
    (function(Prism) {
        var codeLinePattern = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m;
        var memberReference = /#\s*\w+(?:\s*\([^()]*\))?/.source;
        var reference = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(/<mem>/g, function() {
            return memberReference;
        });
        Prism.languages.javadoc = Prism.languages.extend("javadoclike", {});
        Prism.languages.insertBefore("javadoc", "keyword", {
            reference: {
                pattern: RegExp(/(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/.source + "(?:" + reference + ")"),
                lookbehind: true,
                inside: {
                    function: {
                        pattern: /(#\s*)\w+(?=\s*\()/,
                        lookbehind: true
                    },
                    field: {
                        pattern: /(#\s*)\w+/,
                        lookbehind: true
                    },
                    namespace: {
                        pattern: /\b(?:[a-z]\w*\s*\.\s*)+/,
                        inside: {
                            punctuation: /\./
                        }
                    },
                    "class-name": /\b[A-Z]\w*/,
                    keyword: Prism.languages.java.keyword,
                    punctuation: /[#()[\],.]/
                }
            },
            "class-name": {
                // @param <T> the first generic type parameter
                pattern: /(@param\s+)<[A-Z]\w*>/,
                lookbehind: true,
                inside: {
                    punctuation: /[.<>]/
                }
            },
            "code-section": [
                {
                    pattern: /(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/,
                    lookbehind: true,
                    inside: {
                        code: {
                            // there can't be any HTML inside of {@code} tags
                            pattern: codeLinePattern,
                            lookbehind: true,
                            inside: Prism.languages.java,
                            alias: "language-java"
                        }
                    }
                },
                {
                    pattern: /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/,
                    lookbehind: true,
                    inside: {
                        line: {
                            pattern: codeLinePattern,
                            lookbehind: true,
                            inside: {
                                // highlight HTML tags and entities
                                tag: Prism.languages.markup.tag,
                                entity: Prism.languages.markup.entity,
                                code: {
                                    // everything else is Java code
                                    pattern: /.+/,
                                    inside: Prism.languages.java,
                                    alias: "language-java"
                                }
                            }
                        }
                    }
                }
            ],
            tag: Prism.languages.markup.tag,
            entity: Prism.languages.markup.entity
        });
        Prism.languages.javadoclike.addSupport("java", Prism.languages.javadoc);
    })(Prism1);
}

});
parcelRequire.register("krlJ1", function(module, exports) {
"use strict";
module.exports = $ee172e6db104a9fa$var$javadoclike;
$ee172e6db104a9fa$var$javadoclike.displayName = "javadoclike";
$ee172e6db104a9fa$var$javadoclike.aliases = [];
function $ee172e6db104a9fa$var$javadoclike(Prism1) {
    (function(Prism) {
        var javaDocLike = Prism.languages.javadoclike = {
            parameter: {
                pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
                lookbehind: true
            },
            keyword: {
                // keywords are the first word in a line preceded be an `@` or surrounded by curly braces.
                // @word, {@word}
                pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
                lookbehind: true
            },
            punctuation: /[{}]/
        };
        /**
     * Adds doc comment support to the given language and calls a given callback on each doc comment pattern.
     *
     * @param {string} lang the language add doc comment support to.
     * @param {(pattern: {inside: {rest: undefined}}) => void} callback the function called with each doc comment pattern as argument.
     */ function docCommentSupport(lang, callback) {
            var tokenName = "doc-comment";
            var grammar = Prism.languages[lang];
            if (!grammar) return;
            var token = grammar[tokenName];
            if (!token) {
                // add doc comment: /** */
                var definition = {};
                definition[tokenName] = {
                    pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
                    lookbehind: true,
                    alias: "comment"
                };
                grammar = Prism.languages.insertBefore(lang, "comment", definition);
                token = grammar[tokenName];
            }
            if (token instanceof RegExp) // convert regex to object
            token = grammar[tokenName] = {
                pattern: token
            };
            if (Array.isArray(token)) for(var i = 0, l = token.length; i < l; i++){
                if (token[i] instanceof RegExp) token[i] = {
                    pattern: token[i]
                };
                callback(token[i]);
            }
            else callback(token);
        }
        /**
     * Adds doc-comment support to the given languages for the given documentation language.
     *
     * @param {string[]|string} languages
     * @param {Object} docLanguage
     */ function addSupport(languages, docLanguage) {
            if (typeof languages === "string") languages = [
                languages
            ];
            languages.forEach(function(lang) {
                docCommentSupport(lang, function(pattern) {
                    if (!pattern.inside) pattern.inside = {};
                    pattern.inside.rest = docLanguage;
                });
            });
        }
        Object.defineProperty(javaDocLike, "addSupport", {
            value: addSupport
        });
        javaDocLike.addSupport([
            "java",
            "javascript",
            "php"
        ], javaDocLike);
    })(Prism1);
}

});


parcelRequire.register("1vwxQ", function(module, exports) {
"use strict";
module.exports = $1191ee6c4c438f9c$var$javastacktrace;
$1191ee6c4c438f9c$var$javastacktrace.displayName = "javastacktrace";
$1191ee6c4c438f9c$var$javastacktrace.aliases = [];
function $1191ee6c4c438f9c$var$javastacktrace(Prism) {
    // Specification:
    // https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Throwable.html#printStackTrace()
    Prism.languages.javastacktrace = {
        // java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
        // Caused by: java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
        // Caused by: com.example.myproject.MyProjectServletException
        // Caused by: MidLevelException: LowLevelException
        // Suppressed: Resource$CloseFailException: Resource ID = 0
        summary: {
            pattern: /^([\t ]*)(?:(?:Caused by:|Suppressed:|Exception in thread "[^"]*")[\t ]+)?[\w$.]+(?::.*)?$/m,
            lookbehind: true,
            inside: {
                keyword: {
                    pattern: /^([\t ]*)(?:(?:Caused by|Suppressed)(?=:)|Exception in thread)/m,
                    lookbehind: true
                },
                // the current thread if the summary starts with 'Exception in thread'
                string: {
                    pattern: /^(\s*)"[^"]*"/,
                    lookbehind: true
                },
                exceptions: {
                    pattern: /^(:?\s*)[\w$.]+(?=:|$)/,
                    lookbehind: true,
                    inside: {
                        "class-name": /[\w$]+$/,
                        namespace: /\b[a-z]\w*\b/,
                        punctuation: /\./
                    }
                },
                message: {
                    pattern: /(:\s*)\S.*/,
                    lookbehind: true,
                    alias: "string"
                },
                punctuation: /:/
            }
        },
        // at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)
        // at org.hsqldb.jdbc.Util.throwError(Unknown Source) here could be some notes
        // at java.base/java.lang.Class.forName0(Native Method)
        // at Util.<init>(Unknown Source)
        // at com.foo.loader/foo@9.0/com.foo.Main.run(Main.java:101)
        // at com.foo.loader//com.foo.bar.App.run(App.java:12)
        // at acme@2.1/org.acme.Lib.test(Lib.java:80)
        // at MyClass.mash(MyClass.java:9)
        //
        // More information:
        // https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/StackTraceElement.html#toString()
        //
        // A valid Java module name is defined as:
        //   "A module name consists of one or more Java identifiers (§3.8) separated by "." tokens."
        // https://docs.oracle.com/javase/specs/jls/se9/html/jls-6.html#jls-ModuleName
        //
        // A Java module version is defined by this class:
        // https://docs.oracle.com/javase/9/docs/api/java/lang/module/ModuleDescriptor.Version.html
        // This is the implementation of the `parse` method in JDK13:
        // https://github.com/matcdac/jdk/blob/2305df71d1b7710266ae0956d73927a225132c0f/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java#L1108
        // However, to keep this simple, a version will be matched by the pattern /@[\w$.+-]*/.
        "stack-frame": {
            pattern: /^([\t ]*)at (?:[\w$./]|@[\w$.+-]*\/)+(?:<init>)?\([^()]*\)/m,
            lookbehind: true,
            inside: {
                keyword: {
                    pattern: /^(\s*)at(?= )/,
                    lookbehind: true
                },
                source: [
                    // (Main.java:15)
                    // (Main.scala:15)
                    {
                        pattern: /(\()\w+\.\w+:\d+(?=\))/,
                        lookbehind: true,
                        inside: {
                            file: /^\w+\.\w+/,
                            punctuation: /:/,
                            "line-number": {
                                pattern: /\b\d+\b/,
                                alias: "number"
                            }
                        }
                    },
                    // (Native Method)
                    // (...something...)
                    {
                        pattern: /(\()[^()]*(?=\))/,
                        lookbehind: true,
                        inside: {
                            keyword: /^(?:Native Method|Unknown Source)$/
                        }
                    }
                ],
                "class-name": /[\w$]+(?=\.(?:<init>|[\w$]+)\()/,
                function: /(?:<init>|[\w$]+)(?=\()/,
                "class-loader": {
                    pattern: /(\s)[a-z]\w*(?:\.[a-z]\w*)*(?=\/[\w@$.]*\/)/,
                    lookbehind: true,
                    alias: "namespace",
                    inside: {
                        punctuation: /\./
                    }
                },
                module: {
                    pattern: /([\s/])[a-z]\w*(?:\.[a-z]\w*)*(?:@[\w$.+-]*)?(?=\/)/,
                    lookbehind: true,
                    inside: {
                        version: {
                            pattern: /(@)[\s\S]+/,
                            lookbehind: true,
                            alias: "number"
                        },
                        punctuation: /[@.]/
                    }
                },
                namespace: {
                    pattern: /(?:\b[a-z]\w*\.)+/,
                    inside: {
                        punctuation: /\./
                    }
                },
                punctuation: /[()/.]/
            }
        },
        // ... 32 more
        // ... 32 common frames omitted
        more: {
            pattern: /^([\t ]*)\.{3} \d+ [a-z]+(?: [a-z]+)*/m,
            lookbehind: true,
            inside: {
                punctuation: /\.{3}/,
                number: /\d+/,
                keyword: /\b[a-z]+(?: [a-z]+)*\b/
            }
        }
    };
}

});

parcelRequire.register("i2ayO", function(module, exports) {
"use strict";
module.exports = $d2109afc64cbb364$var$jexl;
$d2109afc64cbb364$var$jexl.displayName = "jexl";
$d2109afc64cbb364$var$jexl.aliases = [];
function $d2109afc64cbb364$var$jexl(Prism) {
    Prism.languages.jexl = {
        string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
        transform: {
            pattern: /(\|\s*)[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
            alias: "function",
            lookbehind: true
        },
        function: /[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
        number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
        operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
        boolean: /\b(?:false|true)\b/,
        keyword: /\bin\b/,
        punctuation: /[{}[\](),.]/
    };
}

});

parcelRequire.register("ewimh", function(module, exports) {
"use strict";
module.exports = $a9224b702e2289a3$var$jolie;
$a9224b702e2289a3$var$jolie.displayName = "jolie";
$a9224b702e2289a3$var$jolie.aliases = [];
function $a9224b702e2289a3$var$jolie(Prism) {
    Prism.languages.jolie = Prism.languages.extend("clike", {
        string: {
            pattern: /(^|[^\\])"(?:\\[\s\S]|[^"\\])*"/,
            lookbehind: true,
            greedy: true
        },
        "class-name": {
            pattern: /((?:\b(?:as|courier|embed|in|inputPort|outputPort|service)\b|@)[ \t]*)\w+/,
            lookbehind: true
        },
        keyword: /\b(?:as|cH|comp|concurrent|constants|courier|cset|csets|default|define|else|embed|embedded|execution|exit|extender|for|foreach|forward|from|global|if|import|in|include|init|inputPort|install|instanceof|interface|is_defined|linkIn|linkOut|main|new|nullProcess|outputPort|over|private|provide|public|scope|sequential|service|single|spawn|synchronized|this|throw|throws|type|undef|until|while|with)\b/,
        function: /\b[a-z_]\w*(?=[ \t]*[@(])/i,
        number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?l?/i,
        operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[?\/%^@|]/,
        punctuation: /[()[\]{},;.:]/,
        builtin: /\b(?:Byte|any|bool|char|double|enum|float|int|length|long|ranges|regex|string|undefined|void)\b/
    });
    Prism.languages.insertBefore("jolie", "keyword", {
        aggregates: {
            pattern: /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
            lookbehind: true,
            inside: {
                keyword: /\bwith\b/,
                "class-name": /\w+/,
                punctuation: /,/
            }
        },
        redirects: {
            pattern: /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
            lookbehind: true,
            inside: {
                punctuation: /,/,
                "class-name": /\w+/,
                operator: /=>/
            }
        },
        property: {
            pattern: /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
        }
    });
}

});

parcelRequire.register("awkUj", function(module, exports) {
"use strict";
module.exports = $7a8d1c4f40b5b1b3$var$jq;
$7a8d1c4f40b5b1b3$var$jq.displayName = "jq";
$7a8d1c4f40b5b1b3$var$jq.aliases = [];
function $7a8d1c4f40b5b1b3$var$jq(Prism1) {
    (function(Prism) {
        var interpolation = /\\\((?:[^()]|\([^()]*\))*\)/.source;
        var string = RegExp(/(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(/__/g, function() {
            return interpolation;
        }));
        var stringInterpolation = {
            interpolation: {
                pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + interpolation),
                lookbehind: true,
                inside: {
                    content: {
                        pattern: /^(\\\()[\s\S]+(?=\)$)/,
                        lookbehind: true,
                        inside: null // see below
                    },
                    punctuation: /^\\\(|\)$/
                }
            }
        };
        var jq1 = Prism.languages.jq = {
            comment: /#.*/,
            property: {
                pattern: RegExp(string.source + /(?=\s*:(?!:))/.source),
                lookbehind: true,
                greedy: true,
                inside: stringInterpolation
            },
            string: {
                pattern: string,
                lookbehind: true,
                greedy: true,
                inside: stringInterpolation
            },
            function: {
                pattern: /(\bdef\s+)[a-z_]\w+/i,
                lookbehind: true
            },
            variable: /\B\$\w+/,
            "property-literal": {
                pattern: /\b[a-z_]\w*(?=\s*:(?!:))/i,
                alias: "property"
            },
            keyword: /\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/,
            boolean: /\b(?:false|true)\b/,
            number: /(?:\b\d+\.|\B\.)?\b\d+(?:[eE][+-]?\d+)?\b/,
            operator: [
                {
                    pattern: /\|=?/,
                    alias: "pipe"
                },
                /\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|not|or)\b/
            ],
            "c-style-function": {
                pattern: /\b[a-z_]\w*(?=\s*\()/i,
                alias: "function"
            },
            punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/,
            dot: {
                pattern: /\./,
                alias: "important"
            }
        };
        stringInterpolation.interpolation.inside.content.inside = jq1;
    })(Prism1);
}

});

parcelRequire.register("5PXvh", function(module, exports) {
"use strict";
module.exports = $43ffdf5462a81b23$var$jsExtras;
$43ffdf5462a81b23$var$jsExtras.displayName = "jsExtras";
$43ffdf5462a81b23$var$jsExtras.aliases = [];
function $43ffdf5462a81b23$var$jsExtras(Prism1) {
    (function(Prism) {
        Prism.languages.insertBefore("javascript", "function-variable", {
            "method-variable": {
                pattern: RegExp("(\\.\\s*)" + Prism.languages.javascript["function-variable"].pattern.source),
                lookbehind: true,
                alias: [
                    "function-variable",
                    "method",
                    "function",
                    "property-access"
                ]
            }
        });
        Prism.languages.insertBefore("javascript", "function", {
            method: {
                pattern: RegExp("(\\.\\s*)" + Prism.languages.javascript["function"].source),
                lookbehind: true,
                alias: [
                    "function",
                    "property-access"
                ]
            }
        });
        Prism.languages.insertBefore("javascript", "constant", {
            "known-class-name": [
                {
                    // standard built-ins
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
                    pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
                    alias: "class-name"
                },
                {
                    // errors
                    pattern: /\b(?:[A-Z]\w*)Error\b/,
                    alias: "class-name"
                }
            ]
        });
        /**
     * Replaces the `<ID>` placeholder in the given pattern with a pattern for general JS identifiers.
     *
     * @param {string} source
     * @param {string} [flags]
     * @returns {RegExp}
     */ function withId(source, flags) {
            return RegExp(source.replace(/<ID>/g, function() {
                return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
            }), flags);
        }
        Prism.languages.insertBefore("javascript", "keyword", {
            imports: {
                // https://tc39.es/ecma262/#sec-imports
                pattern: withId(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source),
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            exports: {
                // https://tc39.es/ecma262/#sec-exports
                pattern: withId(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source),
                lookbehind: true,
                inside: Prism.languages.javascript
            }
        });
        Prism.languages.javascript["keyword"].unshift({
            pattern: /\b(?:as|default|export|from|import)\b/,
            alias: "module"
        }, {
            pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
            alias: "control-flow"
        }, {
            pattern: /\bnull\b/,
            alias: [
                "null",
                "nil"
            ]
        }, {
            pattern: /\bundefined\b/,
            alias: "nil"
        });
        Prism.languages.insertBefore("javascript", "operator", {
            spread: {
                pattern: /\.{3}/,
                alias: "operator"
            },
            arrow: {
                pattern: /=>/,
                alias: "operator"
            }
        });
        Prism.languages.insertBefore("javascript", "punctuation", {
            "property-access": {
                pattern: withId(/(\.\s*)#?<ID>/.source),
                lookbehind: true
            },
            "maybe-class-name": {
                pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
                lookbehind: true
            },
            dom: {
                // this contains only a few commonly used DOM variables
                pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
                alias: "variable"
            },
            console: {
                pattern: /\bconsole(?=\s*\.)/,
                alias: "class-name"
            }
        }) // add 'maybe-class-name' to tokens which might be a class name
        ;
        var maybeClassNameTokens = [
            "function",
            "function-variable",
            "method",
            "method-variable",
            "property-access"
        ];
        for(var i = 0; i < maybeClassNameTokens.length; i++){
            var token = maybeClassNameTokens[i];
            var value = Prism.languages.javascript[token] // convert regex to object
            ;
            if (Prism.util.type(value) === "RegExp") value = Prism.languages.javascript[token] = {
                pattern: value
            };
             // keep in mind that we don't support arrays
            var inside = value.inside || {};
            value.inside = inside;
            inside["maybe-class-name"] = /^[A-Z][\s\S]*/;
        }
    })(Prism1);
}

});

parcelRequire.register("2l5ju", function(module, exports) {
"use strict";
module.exports = $1b41aa0e3844a072$var$jsTemplates;
$1b41aa0e3844a072$var$jsTemplates.displayName = "jsTemplates";
$1b41aa0e3844a072$var$jsTemplates.aliases = [];
function $1b41aa0e3844a072$var$jsTemplates(Prism1) {
    (function(Prism) {
        var templateString = Prism.languages.javascript["template-string"] // see the pattern in prism-javascript.js
        ;
        var templateLiteralPattern = templateString.pattern.source;
        var interpolationObject = templateString.inside["interpolation"];
        var interpolationPunctuationObject = interpolationObject.inside["interpolation-punctuation"];
        var interpolationPattern = interpolationObject.pattern.source;
        /**
     * Creates a new pattern to match a template string with a special tag.
     *
     * This will return `undefined` if there is no grammar with the given language id.
     *
     * @param {string} language The language id of the embedded language. E.g. `markdown`.
     * @param {string} tag The regex pattern to match the tag.
     * @returns {object | undefined}
     * @example
     * createTemplate('css', /\bcss/.source);
     */ function createTemplate(language, tag) {
            if (!Prism.languages[language]) return undefined;
            return {
                pattern: RegExp("((?:" + tag + ")\\s*)" + templateLiteralPattern),
                lookbehind: true,
                greedy: true,
                inside: {
                    "template-punctuation": {
                        pattern: /^`|`$/,
                        alias: "string"
                    },
                    "embedded-code": {
                        pattern: /[\s\S]+/,
                        alias: language
                    }
                }
            };
        }
        Prism.languages.javascript["template-string"] = [
            // styled-jsx:
            //   css`a { color: #25F; }`
            // styled-components:
            //   styled.h1`color: red;`
            createTemplate("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),
            // div.innerHTML = `<p></p>`
            createTemplate("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
            createTemplate("svg", /\bsvg/.source),
            createTemplate("markdown", /\b(?:markdown|md)/.source),
            createTemplate("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),
            createTemplate("sql", /\bsql/.source),
            templateString
        ].filter(Boolean);
        /**
     * Returns a specific placeholder literal for the given language.
     *
     * @param {number} counter
     * @param {string} language
     * @returns {string}
     */ function getPlaceholder(counter, language) {
            return "___" + language.toUpperCase() + "_" + counter + "___";
        }
        /**
     * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.
     *
     * @param {string} code
     * @param {any} grammar
     * @param {string} language
     * @returns {(string|Token)[]}
     */ function tokenizeWithHooks(code, grammar, language) {
            var env = {
                code: code,
                grammar: grammar,
                language: language
            };
            Prism.hooks.run("before-tokenize", env);
            env.tokens = Prism.tokenize(env.code, env.grammar);
            Prism.hooks.run("after-tokenize", env);
            return env.tokens;
        }
        /**
     * Returns the token of the given JavaScript interpolation expression.
     *
     * @param {string} expression The code of the expression. E.g. `"${42}"`
     * @returns {Token}
     */ function tokenizeInterpolationExpression(expression) {
            var tempGrammar = {};
            tempGrammar["interpolation-punctuation"] = interpolationPunctuationObject;
            /** @type {Array} */ var tokens = Prism.tokenize(expression, tempGrammar);
            if (tokens.length === 3) {
                /**
         * The token array will look like this
         * [
         *     ["interpolation-punctuation", "${"]
         *     "..." // JavaScript expression of the interpolation
         *     ["interpolation-punctuation", "}"]
         * ]
         */ var args = [
                    1,
                    1
                ];
                args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, "javascript"));
                tokens.splice.apply(tokens, args);
            }
            return new Prism.Token("interpolation", tokens, interpolationObject.alias, expression);
        }
        /**
     * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.
     *
     * This function has 3 phases:
     *
     * 1. Replace all JavaScript interpolation expression with a placeholder.
     *    The placeholder will have the syntax of a identify of the target language.
     * 2. Tokenize the code with placeholders.
     * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.
     *    The insertion only works if a placeholder hasn't been "ripped apart" meaning that the placeholder has been
     *    tokenized as two tokens by the grammar of the embedded language.
     *
     * @param {string} code
     * @param {object} grammar
     * @param {string} language
     * @returns {Token}
     */ function tokenizeEmbedded(code, grammar, language) {
            // 1. First filter out all interpolations
            // because they might be escaped, we need a lookbehind, so we use Prism
            /** @type {(Token|string)[]} */ var _tokens = Prism.tokenize(code, {
                interpolation: {
                    pattern: RegExp(interpolationPattern),
                    lookbehind: true
                }
            }) // replace all interpolations with a placeholder which is not in the code already
            ;
            var placeholderCounter = 0;
            /** @type {Object<string, string>} */ var placeholderMap = {};
            var embeddedCode = _tokens.map(function(token) {
                if (typeof token === "string") return token;
                else {
                    var interpolationExpression = token.content;
                    var placeholder;
                    while(code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1);
                    placeholderMap[placeholder] = interpolationExpression;
                    return placeholder;
                }
            }).join("") // 2. Tokenize the embedded code
            ;
            var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language) // 3. Re-insert the interpolation
            ;
            var placeholders = Object.keys(placeholderMap);
            placeholderCounter = 0;
            /**
       *
       * @param {(Token|string)[]} tokens
       * @returns {void}
       */ function walkTokens(tokens) {
                for(var i = 0; i < tokens.length; i++){
                    if (placeholderCounter >= placeholders.length) return;
                    var token = tokens[i];
                    if (typeof token === "string" || typeof token.content === "string") {
                        var placeholder = placeholders[placeholderCounter];
                        var s = typeof token === "string" ? token : /** @type {string} */ token.content;
                        var index = s.indexOf(placeholder);
                        if (index !== -1) {
                            ++placeholderCounter;
                            var before = s.substring(0, index);
                            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);
                            var after = s.substring(index + placeholder.length);
                            var replacement = [];
                            if (before) replacement.push(before);
                            replacement.push(middle);
                            if (after) {
                                var afterTokens = [
                                    after
                                ];
                                walkTokens(afterTokens);
                                replacement.push.apply(replacement, afterTokens);
                            }
                            if (typeof token === "string") {
                                tokens.splice.apply(tokens, [
                                    i,
                                    1
                                ].concat(replacement));
                                i += replacement.length - 1;
                            } else token.content = replacement;
                        }
                    } else {
                        var content = token.content;
                        if (Array.isArray(content)) walkTokens(content);
                        else walkTokens([
                            content
                        ]);
                    }
                }
            }
            walkTokens(embeddedTokens);
            return new Prism.Token(language, embeddedTokens, "language-" + language, code);
        }
        /**
     * The languages for which JS templating will handle tagged template literals.
     *
     * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.
     */ var supportedLanguages = {
            javascript: true,
            js: true,
            typescript: true,
            ts: true,
            jsx: true,
            tsx: true
        };
        Prism.hooks.add("after-tokenize", function(env) {
            if (!(env.language in supportedLanguages)) return;
            /**
       * Finds and tokenizes all template strings with an embedded languages.
       *
       * @param {(Token | string)[]} tokens
       * @returns {void}
       */ function findTemplateStrings(tokens) {
                for(var i = 0, l = tokens.length; i < l; i++){
                    var token = tokens[i];
                    if (typeof token === "string") continue;
                    var content = token.content;
                    if (!Array.isArray(content)) {
                        if (typeof content !== "string") findTemplateStrings([
                            content
                        ]);
                        continue;
                    }
                    if (token.type === "template-string") {
                        /**
             * A JavaScript template-string token will look like this:
             *
             * ["template-string", [
             *     ["template-punctuation", "`"],
             *     (
             *         An array of "string" and "interpolation" tokens. This is the simple string case.
             *         or
             *         ["embedded-code", "..."] This is the token containing the embedded code.
             *                                  It also has an alias which is the language of the embedded code.
             *     ),
             *     ["template-punctuation", "`"]
             * ]]
             */ var embedded = content[1];
                        if (content.length === 3 && typeof embedded !== "string" && embedded.type === "embedded-code") {
                            // get string content
                            var code = stringContent(embedded);
                            var alias = embedded.alias;
                            var language = Array.isArray(alias) ? alias[0] : alias;
                            var grammar = Prism.languages[language];
                            if (!grammar) continue;
                            content[1] = tokenizeEmbedded(code, grammar, language);
                        }
                    } else findTemplateStrings(content);
                }
            }
            findTemplateStrings(env.tokens);
        });
        /**
     * Returns the string content of a token or token stream.
     *
     * @param {string | Token | (string | Token)[]} value
     * @returns {string}
     */ function stringContent(value) {
            if (typeof value === "string") return value;
            else if (Array.isArray(value)) return value.map(stringContent).join("");
            else return stringContent(value.content);
        }
    })(Prism1);
}

});

parcelRequire.register("9fh53", function(module, exports) {
"use strict";

var $krlJ1 = parcelRequire("krlJ1");

var $aQinA = parcelRequire("aQinA");
module.exports = $6bb2c39f146829c9$var$jsdoc;
$6bb2c39f146829c9$var$jsdoc.displayName = "jsdoc";
$6bb2c39f146829c9$var$jsdoc.aliases = [];
function $6bb2c39f146829c9$var$jsdoc(Prism1) {
    Prism1.register($krlJ1);
    Prism1.register($aQinA);
    (function(Prism) {
        var javascript = Prism.languages.javascript;
        var type = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source;
        var parameterPrefix = "(@(?:arg|argument|param|property)\\s+(?:" + type + "\\s+)?)";
        Prism.languages.jsdoc = Prism.languages.extend("javadoclike", {
            parameter: {
                // @param {string} foo - foo bar
                pattern: RegExp(parameterPrefix + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source),
                lookbehind: true,
                inside: {
                    punctuation: /\./
                }
            }
        });
        Prism.languages.insertBefore("jsdoc", "keyword", {
            "optional-parameter": {
                // @param {string} [baz.foo="bar"] foo bar
                pattern: RegExp(parameterPrefix + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source),
                lookbehind: true,
                inside: {
                    parameter: {
                        pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/,
                        lookbehind: true,
                        inside: {
                            punctuation: /\./
                        }
                    },
                    code: {
                        pattern: /(=)[\s\S]*(?=\]$)/,
                        lookbehind: true,
                        inside: javascript,
                        alias: "language-javascript"
                    },
                    punctuation: /[=[\]]/
                }
            },
            "class-name": [
                {
                    pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function() {
                        return type;
                    })),
                    lookbehind: true,
                    inside: {
                        punctuation: /\./
                    }
                },
                {
                    pattern: RegExp("(@[a-z]+\\s+)" + type),
                    lookbehind: true,
                    inside: {
                        string: javascript.string,
                        number: javascript.number,
                        boolean: javascript.boolean,
                        keyword: Prism.languages.typescript.keyword,
                        operator: /=>|\.\.\.|[&|?:*]/,
                        punctuation: /[.,;=<>{}()[\]]/
                    }
                }
            ],
            example: {
                pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,
                lookbehind: true,
                inside: {
                    code: {
                        pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m,
                        lookbehind: true,
                        inside: javascript,
                        alias: "language-javascript"
                    }
                }
            }
        });
        Prism.languages.javadoclike.addSupport("javascript", Prism.languages.jsdoc);
    })(Prism1);
}

});
parcelRequire.register("aQinA", function(module, exports) {
"use strict";
module.exports = $7e4d047569f6b3ce$var$typescript;
$7e4d047569f6b3ce$var$typescript.displayName = "typescript";
$7e4d047569f6b3ce$var$typescript.aliases = [
    "ts"
];
function $7e4d047569f6b3ce$var$typescript(Prism1) {
    (function(Prism) {
        Prism.languages.typescript = Prism.languages.extend("javascript", {
            "class-name": {
                pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
                lookbehind: true,
                greedy: true,
                inside: null // see below
            },
            builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
        }) // The keywords TypeScript adds to JavaScript
        ;
        Prism.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/) // doesn't work with TS because TS is too complex
        ;
        delete Prism.languages.typescript["parameter"];
        delete Prism.languages.typescript["literal-property"] // a version of typescript specifically for highlighting types
        ;
        var typeInside = Prism.languages.extend("typescript", {});
        delete typeInside["class-name"];
        Prism.languages.typescript["class-name"].inside = typeInside;
        Prism.languages.insertBefore("typescript", "function", {
            decorator: {
                pattern: /@[$\w\xA0-\uFFFF]+/,
                inside: {
                    at: {
                        pattern: /^@/,
                        alias: "operator"
                    },
                    function: /^[\s\S]+/
                }
            },
            "generic-function": {
                // e.g. foo<T extends "bar" | "baz">( ...
                pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
                greedy: true,
                inside: {
                    function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
                    generic: {
                        pattern: /<[\s\S]+/,
                        // everything after the first <
                        alias: "class-name",
                        inside: typeInside
                    }
                }
            }
        });
        Prism.languages.ts = Prism.languages.typescript;
    })(Prism1);
}

});


parcelRequire.register("foj5y", function(module, exports) {
"use strict";
module.exports = $b347e77d751a7867$var$json;
$b347e77d751a7867$var$json.displayName = "json";
$b347e77d751a7867$var$json.aliases = [
    "webmanifest"
];
function $b347e77d751a7867$var$json(Prism) {
    // https://www.json.org/json-en.html
    Prism.languages.json = {
        property: {
            pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
            lookbehind: true,
            greedy: true
        },
        string: {
            pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
            lookbehind: true,
            greedy: true
        },
        comment: {
            pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
            greedy: true
        },
        number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        punctuation: /[{}[\],]/,
        operator: /:/,
        boolean: /\b(?:false|true)\b/,
        null: {
            pattern: /\bnull\b/,
            alias: "keyword"
        }
    };
    Prism.languages.webmanifest = Prism.languages.json;
}

});

parcelRequire.register("eOFsZ", function(module, exports) {
"use strict";

var $foj5y = parcelRequire("foj5y");
module.exports = $ac95e69a9e9ce312$var$json5;
$ac95e69a9e9ce312$var$json5.displayName = "json5";
$ac95e69a9e9ce312$var$json5.aliases = [];
function $ac95e69a9e9ce312$var$json5(Prism1) {
    Prism1.register($foj5y);
    (function(Prism) {
        var string = /("|')(?:\\(?:\r\n?|\n|.)|(?!\1)[^\\\r\n])*\1/;
        Prism.languages.json5 = Prism.languages.extend("json", {
            property: [
                {
                    pattern: RegExp(string.source + "(?=\\s*:)"),
                    greedy: true
                },
                {
                    pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/,
                    alias: "unquoted"
                }
            ],
            string: {
                pattern: string,
                greedy: true
            },
            number: /[+-]?\b(?:NaN|Infinity|0x[a-fA-F\d]+)\b|[+-]?(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+\b)?/
        });
    })(Prism1);
}

});

parcelRequire.register("50bhI", function(module, exports) {
"use strict";

var $foj5y = parcelRequire("foj5y");
module.exports = $3a45b4ba10aed29d$var$jsonp;
$3a45b4ba10aed29d$var$jsonp.displayName = "jsonp";
$3a45b4ba10aed29d$var$jsonp.aliases = [];
function $3a45b4ba10aed29d$var$jsonp(Prism) {
    Prism.register($foj5y);
    Prism.languages.jsonp = Prism.languages.extend("json", {
        punctuation: /[{}[\]();,.]/
    });
    Prism.languages.insertBefore("jsonp", "punctuation", {
        function: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*\()/
    });
}

});

parcelRequire.register("7uLIf", function(module, exports) {
"use strict";
module.exports = $5750587c207c299a$var$jsstacktrace;
$5750587c207c299a$var$jsstacktrace.displayName = "jsstacktrace";
$5750587c207c299a$var$jsstacktrace.aliases = [];
function $5750587c207c299a$var$jsstacktrace(Prism) {
    Prism.languages.jsstacktrace = {
        "error-message": {
            pattern: /^\S.*/m,
            alias: "string"
        },
        "stack-frame": {
            pattern: /(^[ \t]+)at[ \t].*/m,
            lookbehind: true,
            inside: {
                "not-my-code": {
                    pattern: /^at[ \t]+(?!\s)(?:node\.js|<unknown>|.*(?:node_modules|\(<anonymous>\)|\(<unknown>|<anonymous>$|\(internal\/|\(node\.js)).*/m,
                    alias: "comment"
                },
                filename: {
                    pattern: /(\bat\s+(?!\s)|\()(?:[a-zA-Z]:)?[^():]+(?=:)/,
                    lookbehind: true,
                    alias: "url"
                },
                function: {
                    pattern: /(\bat\s+(?:new\s+)?)(?!\s)[_$a-zA-Z\xA0-\uFFFF<][.$\w\xA0-\uFFFF<>]*/,
                    lookbehind: true,
                    inside: {
                        punctuation: /\./
                    }
                },
                punctuation: /[()]/,
                keyword: /\b(?:at|new)\b/,
                alias: {
                    pattern: /\[(?:as\s+)?(?!\s)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\]/,
                    alias: "variable"
                },
                "line-number": {
                    pattern: /:\d+(?::\d+)?\b/,
                    alias: "number",
                    inside: {
                        punctuation: /:/
                    }
                }
            }
        }
    };
}

});

parcelRequire.register("059OA", function(module, exports) {
"use strict";
module.exports = $00f814c52c294640$var$jsx;
$00f814c52c294640$var$jsx.displayName = "jsx";
$00f814c52c294640$var$jsx.aliases = [];
function $00f814c52c294640$var$jsx(Prism1) {
    (function(Prism) {
        var javascript = Prism.util.clone(Prism.languages.javascript);
        var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
        var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
        var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
        /**
     * @param {string} source
     * @param {string} [flags]
     */ function re(source, flags) {
            source = source.replace(/<S>/g, function() {
                return space;
            }).replace(/<BRACES>/g, function() {
                return braces;
            }).replace(/<SPREAD>/g, function() {
                return spread;
            });
            return RegExp(source, flags);
        }
        spread = re(spread).source;
        Prism.languages.jsx = Prism.languages.extend("markup", javascript);
        Prism.languages.jsx.tag.pattern = re(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
        Prism.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
        Prism.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
        Prism.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
        Prism.languages.jsx.tag.inside["comment"] = javascript["comment"];
        Prism.languages.insertBefore("inside", "attr-name", {
            spread: {
                pattern: re(/<SPREAD>/.source),
                inside: Prism.languages.jsx
            }
        }, Prism.languages.jsx.tag);
        Prism.languages.insertBefore("inside", "special-attr", {
            script: {
                // Allow for two levels of nesting
                pattern: re(/=<BRACES>/.source),
                alias: "language-javascript",
                inside: {
                    "script-punctuation": {
                        pattern: /^=(?=\{)/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.jsx
                }
            }
        }, Prism.languages.jsx.tag) // The following will handle plain text inside tags
        ;
        var stringifyToken = function(token) {
            if (!token) return "";
            if (typeof token === "string") return token;
            if (typeof token.content === "string") return token.content;
            return token.content.map(stringifyToken).join("");
        };
        var walkTokens = function(tokens) {
            var openedTags = [];
            for(var i = 0; i < tokens.length; i++){
                var token = tokens[i];
                var notTagNorBrace = false;
                if (typeof token !== "string") {
                    if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
                        // We found a tag, now find its kind
                        if (token.content[0].content[0].content === "</") // Closing tag
                        {
                            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) // Pop matching opening tag
                            openedTags.pop();
                        } else {
                            if (token.content[token.content.length - 1].content === "/>") ;
                            else // Opening tag
                            openedTags.push({
                                tagName: stringifyToken(token.content[0].content[1]),
                                openedBraces: 0
                            });
                        }
                    } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") // Here we might have entered a JSX context inside a tag
                    openedTags[openedTags.length - 1].openedBraces++;
                    else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") // Here we might have left a JSX context inside a tag
                    openedTags[openedTags.length - 1].openedBraces--;
                    else notTagNorBrace = true;
                }
                if (notTagNorBrace || typeof token === "string") {
                    if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
                        // Here we are inside a tag, and not inside a JSX context.
                        // That's plain text: drop any tokens matched.
                        var plainText = stringifyToken(token) // And merge text with adjacent text
                        ;
                        if (i < tokens.length - 1 && (typeof tokens[i + 1] === "string" || tokens[i + 1].type === "plain-text")) {
                            plainText += stringifyToken(tokens[i + 1]);
                            tokens.splice(i + 1, 1);
                        }
                        if (i > 0 && (typeof tokens[i - 1] === "string" || tokens[i - 1].type === "plain-text")) {
                            plainText = stringifyToken(tokens[i - 1]) + plainText;
                            tokens.splice(i - 1, 1);
                            i--;
                        }
                        tokens[i] = new Prism.Token("plain-text", plainText, null, plainText);
                    }
                }
                if (token.content && typeof token.content !== "string") walkTokens(token.content);
            }
        };
        Prism.hooks.add("after-tokenize", function(env) {
            if (env.language !== "jsx" && env.language !== "tsx") return;
            walkTokens(env.tokens);
        });
    })(Prism1);
}

});

parcelRequire.register("iYfv3", function(module, exports) {
"use strict";
module.exports = $dcf9da88f9c529e7$var$julia;
$dcf9da88f9c529e7$var$julia.displayName = "julia";
$dcf9da88f9c529e7$var$julia.aliases = [];
function $dcf9da88f9c529e7$var$julia(Prism) {
    Prism.languages.julia = {
        comment: {
            // support one level of nested comments
            // https://github.com/JuliaLang/julia/pull/6128
            pattern: /(^|[^\\])(?:#=(?:[^#=]|=(?!#)|#(?!=)|#=(?:[^#=]|=(?!#)|#(?!=))*=#)*=#|#.*)/,
            lookbehind: true
        },
        regex: {
            // https://docs.julialang.org/en/v1/manual/strings/#Regular-Expressions-1
            pattern: /r"(?:\\.|[^"\\\r\n])*"[imsx]{0,4}/,
            greedy: true
        },
        string: {
            // https://docs.julialang.org/en/v1/manual/strings/#String-Basics-1
            // https://docs.julialang.org/en/v1/manual/strings/#non-standard-string-literals-1
            // https://docs.julialang.org/en/v1/manual/running-external-programs/#Running-External-Programs-1
            pattern: /"""[\s\S]+?"""|(?:\b\w+)?"(?:\\.|[^"\\\r\n])*"|`(?:[^\\`\r\n]|\\.)*`/,
            greedy: true
        },
        char: {
            // https://docs.julialang.org/en/v1/manual/strings/#man-characters-1
            pattern: /(^|[^\w'])'(?:\\[^\r\n][^'\r\n]*|[^\\\r\n])'/,
            lookbehind: true,
            greedy: true
        },
        keyword: /\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|in|let|local|macro|module|print|println|quote|return|struct|try|type|typealias|using|while)\b/,
        boolean: /\b(?:false|true)\b/,
        number: /(?:\b(?=\d)|\B(?=\.))(?:0[box])?(?:[\da-f]+(?:_[\da-f]+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[efp][+-]?\d+(?:_\d+)*)?j?/i,
        // https://docs.julialang.org/en/v1/manual/mathematical-operations/
        // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity-1
        operator: /&&|\|\||[-+*^%÷⊻&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:|])?|>(?:=|>>?=?)?|==?=?|[~≠≤≥'√∛]/,
        punctuation: /::?|[{}[\]();,.?]/,
        // https://docs.julialang.org/en/v1/base/numbers/#Base.im
        constant: /\b(?:(?:Inf|NaN)(?:16|32|64)?|im|pi)\b|[πℯ]/
    };
}

});

parcelRequire.register("egaM8", function(module, exports) {
"use strict";
module.exports = $a61aeb1753416bec$var$keepalived;
$a61aeb1753416bec$var$keepalived.displayName = "keepalived";
$a61aeb1753416bec$var$keepalived.aliases = [];
function $a61aeb1753416bec$var$keepalived(Prism) {
    Prism.languages.keepalived = {
        comment: {
            pattern: /[#!].*/,
            greedy: true
        },
        string: {
            pattern: /(^|[^\\])(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,
            lookbehind: true,
            greedy: true
        },
        // support IPv4, IPv6, subnet mask
        ip: {
            pattern: RegExp(/\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source.replace(/<ipv4>/g, function() {
                return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/.source;
            }), "i"),
            alias: "number"
        },
        // support *nix / Windows, directory / file
        path: {
            pattern: /(\s)\/(?:[^\/\s]+\/)*[^\/\s]*|\b[a-zA-Z]:\\(?:[^\\\s]+\\)*[^\\\s]*/,
            lookbehind: true,
            alias: "string"
        },
        variable: /\$\{?\w+\}?/,
        email: {
            pattern: /[\w-]+@[\w-]+(?:\.[\w-]{2,3}){1,2}/,
            alias: "string"
        },
        "conditional-configuration": {
            pattern: /@\^?[\w-]+/,
            alias: "variable"
        },
        operator: /=/,
        property: /\b(?:BFD_CHECK|DNS_CHECK|FILE_CHECK|HTTP_GET|MISC_CHECK|NAME|PING_CHECK|SCRIPTS|SMTP_CHECK|SSL|SSL_GET|TCP_CHECK|UDP_CHECK|accept|advert_int|alpha|auth_pass|auth_type|authentication|bfd_cpu_affinity|bfd_instance|bfd_no_swap|bfd_priority|bfd_process_name|bfd_rlimit_rttime|bfd_rt_priority|bind_if|bind_port|bindto|ca|certificate|check_unicast_src|checker|checker_cpu_affinity|checker_log_all_failures|checker_no_swap|checker_priority|checker_rlimit_rttime|checker_rt_priority|child_wait_time|connect_ip|connect_port|connect_timeout|dbus_service_name|debug|default_interface|delay|delay_before_retry|delay_loop|digest|dont_track_primary|dynamic|dynamic_interfaces|enable_(?:dbus|script_security|sni|snmp_checker|snmp_rfc|snmp_rfcv2|snmp_rfcv3|snmp_vrrp|traps)|end|fall|fast_recovery|file|flag-[123]|fork_delay|full_command|fwmark|garp_group|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|global_defs|global_tracking|gna_interval|group|ha_suspend|hashed|helo_name|higher_prio_send_advert|hoplimit|http_protocol|hysteresis|idle_tx|include|inhibit_on_failure|init_fail|init_file|instance|interface|interfaces|interval|ip_family|ipvs_process_name|keepalived.conf|kernel_rx_buf_size|key|linkbeat_interfaces|linkbeat_use_polling|log_all_failures|log_unknown_vrids|lower_prio_no_advert|lthreshold|lvs_flush|lvs_flush_onstop|lvs_method|lvs_netlink_cmd_rcv_bufs|lvs_netlink_cmd_rcv_bufs_force|lvs_netlink_monitor_rcv_bufs|lvs_netlink_monitor_rcv_bufs_force|lvs_notify_fifo|lvs_notify_fifo_script|lvs_sched|lvs_sync_daemon|max_auto_priority|max_hops|mcast_src_ip|mh-fallback|mh-port|min_auto_priority_delay|min_rx|min_tx|misc_dynamic|misc_path|misc_timeout|multiplier|name|namespace_with_ipsets|native_ipv6|neighbor_ip|net_namespace|net_namespace_ipvs|nftables|nftables_counters|nftables_ifindex|nftables_priority|no_accept|no_checker_emails|no_email_faults|nopreempt|notification_email|notification_email_from|notify|notify_backup|notify_deleted|notify_down|notify_fault|notify_fifo|notify_fifo_script|notify_master|notify_master_rx_lower_pri|notify_priority_changes|notify_stop|notify_up|old_unicast_checksum|omega|ops|param_match|passive|password|path|persistence_engine|persistence_granularity|persistence_timeout|preempt|preempt_delay|priority|process|process_monitor_rcv_bufs|process_monitor_rcv_bufs_force|process_name|process_names|promote_secondaries|protocol|proxy_arp|proxy_arp_pvlan|quorum|quorum_down|quorum_max|quorum_up|random_seed|real_server|regex|regex_max_offset|regex_min_offset|regex_no_match|regex_options|regex_stack|reload_repeat|reload_time_file|require_reply|retry|rise|router_id|rs_init_notifies|script|script_user|sh-fallback|sh-port|shutdown_script|shutdown_script_timeout|skip_check_adv_addr|smtp_alert|smtp_alert_checker|smtp_alert_vrrp|smtp_connect_timeout|smtp_helo_name|smtp_server|snmp_socket|sorry_server|sorry_server_inhibit|sorry_server_lvs_method|source_ip|start|startup_script|startup_script_timeout|state|static_ipaddress|static_routes|static_rules|status_code|step|strict_mode|sync_group_tracking_weight|terminate_delay|timeout|track_bfd|track_file|track_group|track_interface|track_process|track_script|track_src_ip|ttl|type|umask|unicast_peer|unicast_src_ip|unicast_ttl|url|use_ipvlan|use_pid_dir|use_vmac|user|uthreshold|val[123]|version|virtual_ipaddress|virtual_ipaddress_excluded|virtual_router_id|virtual_routes|virtual_rules|virtual_server|virtual_server_group|virtualhost|vmac_xmit_base|vrrp|vrrp_(?:check_unicast_src|cpu_affinity|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|gna_interval|higher_prio_send_advert|instance|ipsets|iptables|lower_prio_no_advert|mcast_group4|mcast_group6|min_garp|netlink_cmd_rcv_bufs|netlink_cmd_rcv_bufs_force|netlink_monitor_rcv_bufs|netlink_monitor_rcv_bufs_force|no_swap|notify_fifo|notify_fifo_script|notify_priority_changes|priority|process_name|rlimit_rttime|rt_priority|rx_bufs_multiplier|rx_bufs_policy|script|skip_check_adv_addr|startup_delay|strict|sync_group|track_process|version)|warmup|weight)\b/,
        constant: /\b(?:A|AAAA|AH|BACKUP|CNAME|DR|MASTER|MX|NAT|NS|PASS|SCTP|SOA|TCP|TUN|TXT|UDP|dh|fo|lblc|lblcr|lc|mh|nq|ovf|rr|sed|sh|wlc|wrr)\b/,
        number: {
            pattern: /(^|[^\w.-])-?\d+(?:\.\d+)?/,
            lookbehind: true
        },
        boolean: /\b(?:false|no|off|on|true|yes)\b/,
        punctuation: /[\{\}]/
    };
}

});

parcelRequire.register("fi74q", function(module, exports) {
"use strict";
module.exports = $b21e057e3c754513$var$keyman;
$b21e057e3c754513$var$keyman.displayName = "keyman";
$b21e057e3c754513$var$keyman.aliases = [];
function $b21e057e3c754513$var$keyman(Prism) {
    Prism.languages.keyman = {
        comment: {
            pattern: /\bc .*/i,
            greedy: true
        },
        string: {
            pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
            greedy: true
        },
        "virtual-key": {
            pattern: /\[\s*(?:(?:ALT|CAPS|CTRL|LALT|LCTRL|NCAPS|RALT|RCTRL|SHIFT)\s+)*(?:[TKU]_[\w?]+|[A-E]\d\d?|"[^"\r\n]*"|'[^'\r\n]*')\s*\]/i,
            greedy: true,
            alias: "function" // alias for styles
        },
        // https://help.keyman.com/developer/language/guide/headers
        "header-keyword": {
            pattern: /&\w+/,
            alias: "bold" // alias for styles
        },
        "header-statement": {
            pattern: /\b(?:bitmap|bitmaps|caps always off|caps on only|copyright|hotkey|language|layout|message|name|shift frees caps|version)\b/i,
            alias: "bold" // alias for styles
        },
        "rule-keyword": {
            pattern: /\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|reset|return|save|set|store|use)\b/i,
            alias: "keyword"
        },
        "structural-keyword": {
            pattern: /\b(?:ansi|begin|group|match|nomatch|unicode|using keys)\b/i,
            alias: "keyword"
        },
        "compile-target": {
            pattern: /\$(?:keyman|keymanonly|keymanweb|kmfl|weaver):/i,
            alias: "property"
        },
        // U+####, x###, d### characters and numbers
        number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,
        operator: /[+>\\$]|\.\./,
        punctuation: /[()=,]/
    };
}

});

parcelRequire.register("7a9de", function(module, exports) {
"use strict";
module.exports = $53709cf2ab02a224$var$kotlin;
$53709cf2ab02a224$var$kotlin.displayName = "kotlin";
$53709cf2ab02a224$var$kotlin.aliases = [
    "kt",
    "kts"
];
function $53709cf2ab02a224$var$kotlin(Prism1) {
    (function(Prism) {
        Prism.languages.kotlin = Prism.languages.extend("clike", {
            keyword: {
                // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
                pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
                lookbehind: true
            },
            function: [
                {
                    pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
                    greedy: true
                },
                {
                    pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
                    lookbehind: true,
                    greedy: true
                }
            ],
            number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
            operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
        });
        delete Prism.languages.kotlin["class-name"];
        var interpolationInside = {
            "interpolation-punctuation": {
                pattern: /^\$\{?|\}$/,
                alias: "punctuation"
            },
            expression: {
                pattern: /[\s\S]+/,
                inside: Prism.languages.kotlin
            }
        };
        Prism.languages.insertBefore("kotlin", "string", {
            // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
            "string-literal": [
                {
                    pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
                    alias: "multiline",
                    inside: {
                        interpolation: {
                            pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                            inside: interpolationInside
                        },
                        string: /[\s\S]+/
                    }
                },
                {
                    pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
                    alias: "singleline",
                    inside: {
                        interpolation: {
                            pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                            lookbehind: true,
                            inside: interpolationInside
                        },
                        string: /[\s\S]+/
                    }
                }
            ],
            char: {
                // https://kotlinlang.org/spec/expressions.html#character-literals
                pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
                greedy: true
            }
        });
        delete Prism.languages.kotlin["string"];
        Prism.languages.insertBefore("kotlin", "keyword", {
            annotation: {
                pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
                alias: "builtin"
            }
        });
        Prism.languages.insertBefore("kotlin", "function", {
            label: {
                pattern: /\b\w+@|@\w+\b/,
                alias: "symbol"
            }
        });
        Prism.languages.kt = Prism.languages.kotlin;
        Prism.languages.kts = Prism.languages.kotlin;
    })(Prism1);
}

});

parcelRequire.register("eeAnV", function(module, exports) {
"use strict";
module.exports = $a5ce98c68667ca71$var$kumir;
$a5ce98c68667ca71$var$kumir.displayName = "kumir";
$a5ce98c68667ca71$var$kumir.aliases = [
    "kum"
];
function $a5ce98c68667ca71$var$kumir(Prism1) {
    (function(Prism) {
        /**
     * Regular expression for characters that are not allowed in identifiers.
     *
     * @type {string}
     */ var nonId = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
        /**
     * Surround a regular expression for IDs with patterns for non-ID sequences.
     *
     * @param {string} pattern A regular expression for identifiers.
     * @param {string} [flags] The regular expression flags.
     * @returns {RegExp} A wrapped regular expression for identifiers.
     */ function wrapId(pattern, flags) {
            return RegExp(pattern.replace(/<nonId>/g, nonId), flags);
        }
        Prism.languages.kumir = {
            comment: {
                pattern: /\|.*/
            },
            prolog: {
                pattern: /#.*/,
                greedy: true
            },
            string: {
                pattern: /"[^\n\r"]*"|'[^\n\r']*'/,
                greedy: true
            },
            boolean: {
                pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),
                lookbehind: true
            },
            "operator-word": {
                pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),
                lookbehind: true,
                alias: "keyword"
            },
            "system-variable": {
                pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),
                lookbehind: true,
                alias: "keyword"
            },
            type: [
                {
                    pattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\x20*таб)?(?=[<nonId>]|$)/.source),
                    lookbehind: true,
                    alias: "builtin"
                },
                {
                    pattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),
                    lookbehind: true,
                    alias: "important"
                }
            ],
            /**
       * Should be performed after searching for type names because of "таб".
       * "таб" is a reserved word, but never used without a preceding type name.
       * "НАЗНАЧИТЬ", "Фввод", and "Фвывод" are not reserved words.
       */ keyword: {
                pattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\x20+|_)исп)?|кц(?:(?:\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),
                lookbehind: true
            },
            /** Should be performed after searching for reserved words. */ name: {
                // eslint-disable-next-line regexp/no-super-linear-backtracking
                pattern: wrapId(/(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),
                lookbehind: true
            },
            /** Should be performed after searching for names. */ number: {
                pattern: wrapId(/(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/.source, "i"),
                lookbehind: true
            },
            /** Should be performed after searching for words. */ punctuation: /:=|[(),:;\[\]]/,
            /**
       * Should be performed after searching for
       * - numeric constants (because of "+" and "-");
       * - punctuation marks (because of ":=" and "=").
       */ "operator-char": {
                pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
                alias: "operator"
            }
        };
        Prism.languages.kum = Prism.languages.kumir;
    })(Prism1);
}

});

parcelRequire.register("eOXdT", function(module, exports) {
"use strict";
module.exports = $aca3acab0a8fb465$var$kusto;
$aca3acab0a8fb465$var$kusto.displayName = "kusto";
$aca3acab0a8fb465$var$kusto.aliases = [];
function $aca3acab0a8fb465$var$kusto(Prism) {
    Prism.languages.kusto = {
        comment: {
            pattern: /\/\/.*/,
            greedy: true
        },
        string: {
            pattern: /```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
            greedy: true
        },
        verb: {
            pattern: /(\|\s*)[a-z][\w-]*/i,
            lookbehind: true,
            alias: "keyword"
        },
        command: {
            pattern: /\.[a-z][a-z\d-]*\b/,
            alias: "keyword"
        },
        "class-name": /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
        keyword: /\b(?:access|alias|and|anti|as|asc|auto|between|by|(?:contains|(?:ends|starts)with|has(?:perfix|suffix)?)(?:_cs)?|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
        boolean: /\b(?:false|null|true)\b/,
        function: /\b[a-z_]\w*(?=\s*\()/,
        datetime: [
            {
                // RFC 822 + RFC 850
                pattern: /\b(?:(?:Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:[A-Z]|(?:[ECMT][DS]|GM|U)T)|[+-]\d{4}))?\b/,
                alias: "number"
            },
            {
                // ISO 8601
                pattern: /[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
                alias: "number"
            }
        ],
        number: /\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mnµ]s|[dhms]|microsecond|tick)\b)?|[+-]?\binf\b/,
        operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
        punctuation: /[()\[\]{},;.:]/
    };
}

});

parcelRequire.register("arXqb", function(module, exports) {
"use strict";
module.exports = $79ba84d1d214f64a$var$latex;
$79ba84d1d214f64a$var$latex.displayName = "latex";
$79ba84d1d214f64a$var$latex.aliases = [
    "tex",
    "context"
];
function $79ba84d1d214f64a$var$latex(Prism1) {
    (function(Prism) {
        var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
        var insideEqu = {
            "equation-command": {
                pattern: funcPattern,
                alias: "regex"
            }
        };
        Prism.languages.latex = {
            comment: /%.*/,
            // the verbatim environment prints whitespace to the document
            cdata: {
                pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
                lookbehind: true
            },
            /*
       * equations can be between $$ $$ or $ $ or \( \) or \[ \]
       * (all are multiline)
       */ equation: [
                {
                    pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
                    inside: insideEqu,
                    alias: "string"
                },
                {
                    pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
                    lookbehind: true,
                    inside: insideEqu,
                    alias: "string"
                }
            ],
            /*
       * arguments which are keywords or references are highlighted
       * as keywords
       */ keyword: {
                pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
                lookbehind: true
            },
            url: {
                pattern: /(\\url\{)[^}]+(?=\})/,
                lookbehind: true
            },
            /*
       * section or chapter headlines are highlighted as bold so that
       * they stand out more
       */ headline: {
                pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
                lookbehind: true,
                alias: "class-name"
            },
            function: {
                pattern: funcPattern,
                alias: "selector"
            },
            punctuation: /[[\]{}&]/
        };
        Prism.languages.tex = Prism.languages.latex;
        Prism.languages.context = Prism.languages.latex;
    })(Prism1);
}

});

parcelRequire.register("lVwRg", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");

var $dgm8B = parcelRequire("dgm8B");
module.exports = $ff6868cb3fe7f755$var$latte;
$ff6868cb3fe7f755$var$latte.displayName = "latte";
$ff6868cb3fe7f755$var$latte.aliases = [];
function $ff6868cb3fe7f755$var$latte(Prism1) {
    Prism1.register($cekeD);
    Prism1.register($dgm8B);
    (function(Prism) {
        Prism.languages.latte = {
            comment: /^\{\*[\s\S]*/,
            "latte-tag": {
                // https://latte.nette.org/en/tags
                pattern: /(^\{(?:\/(?=[a-z]))?)(?:[=_]|[a-z]\w*\b(?!\())/i,
                lookbehind: true,
                alias: "important"
            },
            delimiter: {
                pattern: /^\{\/?|\}$/,
                alias: "punctuation"
            },
            php: {
                pattern: /\S(?:[\s\S]*\S)?/,
                alias: "language-php",
                inside: Prism.languages.php
            }
        };
        var markupLatte = Prism.languages.extend("markup", {});
        Prism.languages.insertBefore("inside", "attr-value", {
            "n-attr": {
                pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
                inside: {
                    "attr-name": {
                        pattern: /^[^\s=]+/,
                        alias: "important"
                    },
                    "attr-value": {
                        pattern: /=[\s\S]+/,
                        inside: {
                            punctuation: [
                                /^=/,
                                {
                                    pattern: /^(\s*)["']|["']$/,
                                    lookbehind: true
                                }
                            ],
                            php: {
                                pattern: /\S(?:[\s\S]*\S)?/,
                                inside: Prism.languages.php
                            }
                        }
                    }
                }
            }
        }, markupLatte.tag);
        Prism.hooks.add("before-tokenize", function(env) {
            if (env.language !== "latte") return;
            var lattePattern = /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
            Prism.languages["markup-templating"].buildPlaceholders(env, "latte", lattePattern);
            env.grammar = markupLatte;
        });
        Prism.hooks.add("after-tokenize", function(env) {
            Prism.languages["markup-templating"].tokenizePlaceholders(env, "latte");
        });
    })(Prism1);
}

});
parcelRequire.register("dgm8B", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");
module.exports = $9a7df11041cfaea6$var$php;
$9a7df11041cfaea6$var$php.displayName = "php";
$9a7df11041cfaea6$var$php.aliases = [];
function $9a7df11041cfaea6$var$php(Prism1) {
    Prism1.register($cekeD) /**
   * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
   * Modified by Miles Johnson: http://milesj.me
   * Rewritten by Tom Pavelec
   *
   * Supports PHP 5.3 - 8.0
   */ ;
    (function(Prism) {
        var comment = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
        var constant = [
            {
                pattern: /\b(?:false|true)\b/i,
                alias: "boolean"
            },
            {
                pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
                greedy: true,
                lookbehind: true
            },
            {
                pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
                greedy: true,
                lookbehind: true
            },
            /\b(?:null)\b/i,
            /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
        ];
        var number = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
        var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
        var punctuation = /[{}\[\](),:;]/;
        Prism.languages.php = {
            delimiter: {
                pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
                alias: "important"
            },
            comment: comment,
            variable: /\$+(?:\w+\b|(?=\{))/,
            package: {
                pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
                lookbehind: true,
                inside: {
                    punctuation: /\\/
                }
            },
            "class-name-definition": {
                pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
                lookbehind: true,
                alias: "class-name"
            },
            "function-definition": {
                pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
                lookbehind: true,
                alias: "function"
            },
            keyword: [
                {
                    pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
                    alias: "type-casting",
                    greedy: true,
                    lookbehind: true
                },
                {
                    pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
                    alias: "type-hint",
                    greedy: true,
                    lookbehind: true
                },
                {
                    pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string|void)\b/i,
                    alias: "return-type",
                    greedy: true,
                    lookbehind: true
                },
                {
                    pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
                    alias: "type-declaration",
                    greedy: true
                },
                {
                    pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
                    alias: "type-declaration",
                    greedy: true,
                    lookbehind: true
                },
                {
                    pattern: /\b(?:parent|self|static)(?=\s*::)/i,
                    alias: "static-context",
                    greedy: true
                },
                {
                    // yield from
                    pattern: /(\byield\s+)from\b/i,
                    lookbehind: true
                },
                /\bclass\b/i,
                {
                    // https://www.php.net/manual/en/reserved.keywords.php
                    //
                    // keywords cannot be preceded by "->"
                    // the complex lookbehind means `(?<!(?:->|::)\s*)`
                    pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
                    lookbehind: true
                }
            ],
            "argument-name": {
                pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i,
                lookbehind: true
            },
            "class-name": [
                {
                    pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
                    greedy: true,
                    lookbehind: true
                },
                {
                    pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
                    greedy: true,
                    lookbehind: true
                },
                {
                    pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
                    greedy: true
                },
                {
                    pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
                    alias: "class-name-fully-qualified",
                    greedy: true,
                    lookbehind: true,
                    inside: {
                        punctuation: /\\/
                    }
                },
                {
                    pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
                    alias: "class-name-fully-qualified",
                    greedy: true,
                    inside: {
                        punctuation: /\\/
                    }
                },
                {
                    pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
                    alias: "class-name-fully-qualified",
                    greedy: true,
                    lookbehind: true,
                    inside: {
                        punctuation: /\\/
                    }
                },
                {
                    pattern: /\b[a-z_]\w*(?=\s*\$)/i,
                    alias: "type-declaration",
                    greedy: true
                },
                {
                    pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
                    alias: [
                        "class-name-fully-qualified",
                        "type-declaration"
                    ],
                    greedy: true,
                    inside: {
                        punctuation: /\\/
                    }
                },
                {
                    pattern: /\b[a-z_]\w*(?=\s*::)/i,
                    alias: "static-context",
                    greedy: true
                },
                {
                    pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
                    alias: [
                        "class-name-fully-qualified",
                        "static-context"
                    ],
                    greedy: true,
                    inside: {
                        punctuation: /\\/
                    }
                },
                {
                    pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
                    alias: "type-hint",
                    greedy: true,
                    lookbehind: true
                },
                {
                    pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
                    alias: [
                        "class-name-fully-qualified",
                        "type-hint"
                    ],
                    greedy: true,
                    lookbehind: true,
                    inside: {
                        punctuation: /\\/
                    }
                },
                {
                    pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
                    alias: "return-type",
                    greedy: true,
                    lookbehind: true
                },
                {
                    pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
                    alias: [
                        "class-name-fully-qualified",
                        "return-type"
                    ],
                    greedy: true,
                    lookbehind: true,
                    inside: {
                        punctuation: /\\/
                    }
                }
            ],
            constant: constant,
            function: {
                pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
                lookbehind: true,
                inside: {
                    punctuation: /\\/
                }
            },
            property: {
                pattern: /(->\s*)\w+/,
                lookbehind: true
            },
            number: number,
            operator: operator,
            punctuation: punctuation
        };
        var string_interpolation = {
            pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
            lookbehind: true,
            inside: Prism.languages.php
        };
        var string = [
            {
                pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
                alias: "nowdoc-string",
                greedy: true,
                inside: {
                    delimiter: {
                        pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
                        alias: "symbol",
                        inside: {
                            punctuation: /^<<<'?|[';]$/
                        }
                    }
                }
            },
            {
                pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
                alias: "heredoc-string",
                greedy: true,
                inside: {
                    delimiter: {
                        pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
                        alias: "symbol",
                        inside: {
                            punctuation: /^<<<"?|[";]$/
                        }
                    },
                    interpolation: string_interpolation
                }
            },
            {
                pattern: /`(?:\\[\s\S]|[^\\`])*`/,
                alias: "backtick-quoted-string",
                greedy: true
            },
            {
                pattern: /'(?:\\[\s\S]|[^\\'])*'/,
                alias: "single-quoted-string",
                greedy: true
            },
            {
                pattern: /"(?:\\[\s\S]|[^\\"])*"/,
                alias: "double-quoted-string",
                greedy: true,
                inside: {
                    interpolation: string_interpolation
                }
            }
        ];
        Prism.languages.insertBefore("php", "variable", {
            string: string,
            attribute: {
                pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
                greedy: true,
                inside: {
                    "attribute-content": {
                        pattern: /^(#\[)[\s\S]+(?=\]$)/,
                        lookbehind: true,
                        // inside can appear subset of php
                        inside: {
                            comment: comment,
                            string: string,
                            "attribute-class-name": [
                                {
                                    pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                                    alias: "class-name",
                                    greedy: true,
                                    lookbehind: true
                                },
                                {
                                    pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                                    alias: [
                                        "class-name",
                                        "class-name-fully-qualified"
                                    ],
                                    greedy: true,
                                    lookbehind: true,
                                    inside: {
                                        punctuation: /\\/
                                    }
                                }
                            ],
                            constant: constant,
                            number: number,
                            operator: operator,
                            punctuation: punctuation
                        }
                    },
                    delimiter: {
                        pattern: /^#\[|\]$/,
                        alias: "punctuation"
                    }
                }
            }
        });
        Prism.hooks.add("before-tokenize", function(env) {
            if (!/<\?/.test(env.code)) return;
            var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
            Prism.languages["markup-templating"].buildPlaceholders(env, "php", phpPattern);
        });
        Prism.hooks.add("after-tokenize", function(env) {
            Prism.languages["markup-templating"].tokenizePlaceholders(env, "php");
        });
    })(Prism1);
}

});


parcelRequire.register("dh8tA", function(module, exports) {
"use strict";
module.exports = $9aa37014d950c4e2$var$less;
$9aa37014d950c4e2$var$less.displayName = "less";
$9aa37014d950c4e2$var$less.aliases = [];
function $9aa37014d950c4e2$var$less(Prism) {
    /* FIXME :
:extend() is not handled specifically : its highlighting is buggy.
Mixin usage must be inside a ruleset to be highlighted.
At-rules (e.g. import) containing interpolations are buggy.
Detached rulesets are highlighted as at-rules.
A comment before a mixin usage prevents the latter to be properly highlighted.
*/ Prism.languages.less = Prism.languages.extend("css", {
        comment: [
            /\/\*[\s\S]*?\*\//,
            {
                pattern: /(^|[^\\])\/\/.*/,
                lookbehind: true
            }
        ],
        atrule: {
            pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
            inside: {
                punctuation: /[:()]/
            }
        },
        // selectors and mixins are considered the same
        selector: {
            pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
            inside: {
                // mixin parameters
                variable: /@+[\w-]+/
            }
        },
        property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
        operator: /[+\-*\/]/
    });
    Prism.languages.insertBefore("less", "property", {
        variable: [
            // Variable declaration (the colon must be consumed!)
            {
                pattern: /@[\w-]+\s*:/,
                inside: {
                    punctuation: /:/
                }
            },
            /@@?[\w-]+/
        ],
        "mixin-usage": {
            pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
            lookbehind: true,
            alias: "function"
        }
    });
}

});

parcelRequire.register("6TZG2", function(module, exports) {
"use strict";

var $7AD6t = parcelRequire("7AD6t");
module.exports = $5067b8ea76fb9749$var$lilypond;
$5067b8ea76fb9749$var$lilypond.displayName = "lilypond";
$5067b8ea76fb9749$var$lilypond.aliases = [];
function $5067b8ea76fb9749$var$lilypond(Prism1) {
    Prism1.register($7AD6t);
    (function(Prism) {
        var schemeExpression = /\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/.source // allow for up to pow(2, recursivenessLog2) many levels of recursive brace expressions
        ;
        // For some reason, this can't be 4
        var recursivenessLog2 = 5;
        for(var i = 0; i < recursivenessLog2; i++)schemeExpression = schemeExpression.replace(/<expr>/g, function() {
            return schemeExpression;
        });
        schemeExpression = schemeExpression.replace(/<expr>/g, /[^\s\S]/.source);
        var lilypond1 = Prism.languages.lilypond = {
            comment: /%(?:(?!\{).*|\{[\s\S]*?%\})/,
            "embedded-scheme": {
                pattern: RegExp(/(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(/<expr>/g, function() {
                    return schemeExpression;
                }), "m"),
                lookbehind: true,
                greedy: true,
                inside: {
                    scheme: {
                        pattern: /^(#)[\s\S]+$/,
                        lookbehind: true,
                        alias: "language-scheme",
                        inside: {
                            "embedded-lilypond": {
                                pattern: /#\{[\s\S]*?#\}/,
                                greedy: true,
                                inside: {
                                    punctuation: /^#\{|#\}$/,
                                    lilypond: {
                                        pattern: /[\s\S]+/,
                                        alias: "language-lilypond",
                                        inside: null // see below
                                    }
                                }
                            },
                            rest: Prism.languages.scheme
                        }
                    },
                    punctuation: /#/
                }
            },
            string: {
                pattern: /"(?:[^"\\]|\\.)*"/,
                greedy: true
            },
            "class-name": {
                pattern: /(\\new\s+)[\w-]+/,
                lookbehind: true
            },
            keyword: {
                pattern: /\\[a-z][-\w]*/i,
                inside: {
                    punctuation: /^\\/
                }
            },
            operator: /[=|]|<<|>>/,
            punctuation: {
                pattern: /(^|[a-z\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\d))|[_^]\.?|[.!])|[{}()[\]<>^~]|\\[()[\]<>\\!]|--|__/,
                lookbehind: true
            },
            number: /\b\d+(?:\/\d+)?\b/
        };
        lilypond1["embedded-scheme"].inside["scheme"].inside["embedded-lilypond"].inside["lilypond"].inside = lilypond1;
        Prism.languages.ly = lilypond1;
    })(Prism1);
}

});
parcelRequire.register("7AD6t", function(module, exports) {
"use strict";
module.exports = $586a3a56521c6564$var$scheme;
$586a3a56521c6564$var$scheme.displayName = "scheme";
$586a3a56521c6564$var$scheme.aliases = [];
function $586a3a56521c6564$var$scheme(Prism1) {
    (function(Prism) {
        Prism.languages.scheme = {
            // this supports "normal" single-line comments:
            //   ; comment
            // and (potentially nested) multiline comments:
            //   #| comment #| nested |# still comment |#
            // (only 1 level of nesting is supported)
            comment: /;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
            string: {
                pattern: /"(?:[^"\\]|\\.)*"/,
                greedy: true
            },
            symbol: {
                pattern: /'[^()\[\]#'\s]+/,
                greedy: true
            },
            char: {
                pattern: /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
                greedy: true
            },
            "lambda-parameter": [
                // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30
                {
                    pattern: /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
                    lookbehind: true
                },
                {
                    pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
                    lookbehind: true
                }
            ],
            keyword: {
                pattern: /((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
                lookbehind: true
            },
            builtin: {
                // all functions of the base library of R7RS plus some of built-ins of R5Rs
                pattern: /((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
                lookbehind: true
            },
            operator: {
                pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
                lookbehind: true
            },
            number: {
                // The number pattern from [the R7RS spec](https://small.r7rs.org/attachment/r7rs.pdf).
                //
                // <number>      := <num 2>|<num 8>|<num 10>|<num 16>
                // <num R>       := <prefix R><complex R>
                // <complex R>   := <real R>(?:@<real R>|<imaginary R>)?|<imaginary R>
                // <imaginary R> := [+-](?:<ureal R>|(?:inf|nan)\.0)?i
                // <real R>      := [+-]?<ureal R>|[+-](?:inf|nan)\.0
                // <ureal R>     := <uint R>(?:\/<uint R>)?
                //                | <decimal R>
                //
                // <decimal 10>  := (?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?
                // <uint R>      := <digit R>+
                // <prefix R>    := <radix R>(?:#[ei])?|(?:#[ei])?<radix R>
                // <radix 2>     := #b
                // <radix 8>     := #o
                // <radix 10>    := (?:#d)?
                // <radix 16>    := #x
                // <digit 2>     := [01]
                // <digit 8>     := [0-7]
                // <digit 10>    := \d
                // <digit 16>    := [0-9a-f]
                //
                // The problem with this grammar is that the resulting regex is way to complex, so we simplify by grouping all
                // non-decimal bases together. This results in a decimal (dec) and combined binary, octal, and hexadecimal (box)
                // pattern:
                pattern: RegExp(SortedBNF({
                    "<ureal dec>": /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
                    "<real dec>": /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
                    "<imaginary dec>": /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
                    "<complex dec>": /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/.source,
                    "<num dec>": /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
                    "<ureal box>": /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
                    "<real box>": /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
                    "<imaginary box>": /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
                    "<complex box>": /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/.source,
                    "<num box>": /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,
                    "<number>": /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/.source
                }), "i"),
                lookbehind: true
            },
            boolean: {
                pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
                lookbehind: true
            },
            function: {
                pattern: /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
                lookbehind: true
            },
            identifier: {
                pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
                lookbehind: true,
                greedy: true
            },
            punctuation: /[()\[\]']/
        };
        /**
     * Given a topologically sorted BNF grammar, this will return the RegExp source of last rule of the grammar.
     *
     * @param {Record<string, string>} grammar
     * @returns {string}
     */ function SortedBNF(grammar) {
            for(var key1 in grammar)grammar[key1] = grammar[key1].replace(/<[\w\s]+>/g, function(key) {
                return "(?:" + grammar[key].trim() + ")";
            });
             // return the last item
            return grammar[key1];
        }
    })(Prism1);
}

});


parcelRequire.register("0v4qf", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");
module.exports = $00181a1f25d7e69b$var$liquid;
$00181a1f25d7e69b$var$liquid.displayName = "liquid";
$00181a1f25d7e69b$var$liquid.aliases = [];
function $00181a1f25d7e69b$var$liquid(Prism) {
    Prism.register($cekeD);
    Prism.languages.liquid = {
        comment: {
            pattern: /(^\{%\s*comment\s*%\})[\s\S]+(?=\{%\s*endcomment\s*%\}$)/,
            lookbehind: true
        },
        delimiter: {
            pattern: /^\{(?:\{\{|[%\{])-?|-?(?:\}\}|[%\}])\}$/,
            alias: "punctuation"
        },
        string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
        },
        keyword: /\b(?:as|assign|break|(?:end)?(?:capture|case|comment|for|form|if|paginate|raw|style|tablerow|unless)|continue|cycle|decrement|echo|else|elsif|in|include|increment|limit|liquid|offset|range|render|reversed|section|when|with)\b/,
        object: /\b(?:address|all_country_option_tags|article|block|blog|cart|checkout|collection|color|country|country_option_tags|currency|current_page|current_tags|customer|customer_address|date|discount_allocation|discount_application|external_video|filter|filter_value|font|forloop|fulfillment|generic_file|gift_card|group|handle|image|line_item|link|linklist|localization|location|measurement|media|metafield|model|model_source|order|page|page_description|page_image|page_title|part|policy|product|product_option|recommendations|request|robots|routes|rule|script|search|selling_plan|selling_plan_allocation|selling_plan_group|shipping_method|shop|shop_locale|sitemap|store_availability|tax_line|template|theme|transaction|unit_price_measurement|user_agent|variant|video|video_source)\b/,
        function: [
            {
                pattern: /(\|\s*)\w+/,
                lookbehind: true,
                alias: "filter"
            },
            {
                // array functions
                pattern: /(\.\s*)(?:first|last|size)/,
                lookbehind: true
            }
        ],
        boolean: /\b(?:false|nil|true)\b/,
        range: {
            pattern: /\.\./,
            alias: "operator"
        },
        // https://github.com/Shopify/liquid/blob/698f5e0d967423e013f6169d9111bd969bd78337/lib/liquid/lexer.rb#L21
        number: /\b\d+(?:\.\d+)?\b/,
        operator: /[!=]=|<>|[<>]=?|[|?:=-]|\b(?:and|contains(?=\s)|or)\b/,
        punctuation: /[.,\[\]()]/,
        empty: {
            pattern: /\bempty\b/,
            alias: "keyword"
        }
    };
    Prism.hooks.add("before-tokenize", function(env) {
        var liquidPattern = /\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g;
        var insideRaw = false;
        Prism.languages["markup-templating"].buildPlaceholders(env, "liquid", liquidPattern, function(match) {
            var tagMatch = /^\{%-?\s*(\w+)/.exec(match);
            if (tagMatch) {
                var tag = tagMatch[1];
                if (tag === "raw" && !insideRaw) {
                    insideRaw = true;
                    return true;
                } else if (tag === "endraw") {
                    insideRaw = false;
                    return true;
                }
            }
            return !insideRaw;
        });
    });
    Prism.hooks.add("after-tokenize", function(env) {
        Prism.languages["markup-templating"].tokenizePlaceholders(env, "liquid");
    });
}

});

parcelRequire.register("dl2ma", function(module, exports) {
"use strict";
module.exports = $9b5f1081431260ec$var$lisp;
$9b5f1081431260ec$var$lisp.displayName = "lisp";
$9b5f1081431260ec$var$lisp.aliases = [];
function $9b5f1081431260ec$var$lisp(Prism1) {
    (function(Prism) {
        /**
     * Functions to construct regular expressions
     * e.g. (interactive ... or (interactive)
     *
     * @param {string} name
     * @returns {RegExp}
     */ function simple_form(name) {
            return RegExp(/(\()/.source + "(?:" + name + ")" + /(?=[\s\)])/.source);
        }
        /**
     * booleans and numbers
     *
     * @param {string} pattern
     * @returns {RegExp}
     */ function primitive(pattern) {
            return RegExp(/([\s([])/.source + "(?:" + pattern + ")" + /(?=[\s)])/.source);
        } // Patterns in regular expressions
        // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html
        // & and : are excluded as they are usually used for special purposes
        var symbol = /(?!\d)[-+*/~!@$%^=<>{}\w]+/.source // symbol starting with & used in function arguments
        ;
        var marker = "&" + symbol // Open parenthesis for look-behind
        ;
        var par = "(\\()";
        var endpar = "(?=\\))" // End the pattern with look-ahead space
        ;
        var space = "(?=\\s)";
        var nestedPar = /(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/.source;
        var language = {
            // Three or four semicolons are considered a heading.
            // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html
            heading: {
                pattern: /;;;.*/,
                alias: [
                    "comment",
                    "title"
                ]
            },
            comment: /;.*/,
            string: {
                pattern: /"(?:[^"\\]|\\.)*"/,
                greedy: true,
                inside: {
                    argument: /[-A-Z]+(?=[.,\s])/,
                    symbol: RegExp("`" + symbol + "'")
                }
            },
            "quoted-symbol": {
                pattern: RegExp("#?'" + symbol),
                alias: [
                    "variable",
                    "symbol"
                ]
            },
            "lisp-property": {
                pattern: RegExp(":" + symbol),
                alias: "property"
            },
            splice: {
                pattern: RegExp(",@?" + symbol),
                alias: [
                    "symbol",
                    "variable"
                ]
            },
            keyword: [
                {
                    pattern: RegExp(par + "(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)" + space),
                    lookbehind: true
                },
                {
                    pattern: RegExp(par + "(?:append|by|collect|concat|do|finally|for|in|return)" + space),
                    lookbehind: true
                }
            ],
            declare: {
                pattern: simple_form(/declare/.source),
                lookbehind: true,
                alias: "keyword"
            },
            interactive: {
                pattern: simple_form(/interactive/.source),
                lookbehind: true,
                alias: "keyword"
            },
            boolean: {
                pattern: primitive(/nil|t/.source),
                lookbehind: true
            },
            number: {
                pattern: primitive(/[-+]?\d+(?:\.\d*)?/.source),
                lookbehind: true
            },
            defvar: {
                pattern: RegExp(par + "def(?:const|custom|group|var)\\s+" + symbol),
                lookbehind: true,
                inside: {
                    keyword: /^def[a-z]+/,
                    variable: RegExp(symbol)
                }
            },
            defun: {
                pattern: RegExp(par + /(?:cl-)?(?:defmacro|defun\*?)\s+/.source + symbol + /\s+\(/.source + nestedPar + /\)/.source),
                lookbehind: true,
                greedy: true,
                inside: {
                    keyword: /^(?:cl-)?def\S+/,
                    // See below, this property needs to be defined later so that it can
                    // reference the language object.
                    arguments: null,
                    function: {
                        pattern: RegExp("(^\\s)" + symbol),
                        lookbehind: true
                    },
                    punctuation: /[()]/
                }
            },
            lambda: {
                pattern: RegExp(par + "lambda\\s+\\(\\s*(?:&?" + symbol + "(?:\\s+&?" + symbol + ")*\\s*)?\\)"),
                lookbehind: true,
                greedy: true,
                inside: {
                    keyword: /^lambda/,
                    // See below, this property needs to be defined later so that it can
                    // reference the language object.
                    arguments: null,
                    punctuation: /[()]/
                }
            },
            car: {
                pattern: RegExp(par + symbol),
                lookbehind: true
            },
            punctuation: [
                // open paren, brackets, and close paren
                /(?:['`,]?\(|[)\[\]])/,
                {
                    pattern: /(\s)\.(?=\s)/,
                    lookbehind: true
                }
            ]
        };
        var arg = {
            "lisp-marker": RegExp(marker),
            varform: {
                pattern: RegExp(/\(/.source + symbol + /\s+(?=\S)/.source + nestedPar + /\)/.source),
                inside: language
            },
            argument: {
                pattern: RegExp(/(^|[\s(])/.source + symbol),
                lookbehind: true,
                alias: "variable"
            },
            rest: language
        };
        var forms = "\\S+(?:\\s+\\S+)*";
        var arglist = {
            pattern: RegExp(par + nestedPar + endpar),
            lookbehind: true,
            inside: {
                "rest-vars": {
                    pattern: RegExp("&(?:body|rest)\\s+" + forms),
                    inside: arg
                },
                "other-marker-vars": {
                    pattern: RegExp("&(?:aux|optional)\\s+" + forms),
                    inside: arg
                },
                keys: {
                    pattern: RegExp("&key\\s+" + forms + "(?:\\s+&allow-other-keys)?"),
                    inside: arg
                },
                argument: {
                    pattern: RegExp(symbol),
                    alias: "variable"
                },
                punctuation: /[()]/
            }
        };
        language["lambda"].inside.arguments = arglist;
        language["defun"].inside.arguments = Prism.util.clone(arglist);
        language["defun"].inside.arguments.inside.sublist = arglist;
        Prism.languages.lisp = language;
        Prism.languages.elisp = language;
        Prism.languages.emacs = language;
        Prism.languages["emacs-lisp"] = language;
    })(Prism1);
}

});

parcelRequire.register("kpHun", function(module, exports) {
"use strict";
module.exports = $edc7e075e6f20464$var$livescript;
$edc7e075e6f20464$var$livescript.displayName = "livescript";
$edc7e075e6f20464$var$livescript.aliases = [];
function $edc7e075e6f20464$var$livescript(Prism) {
    Prism.languages.livescript = {
        comment: [
            {
                pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
                lookbehind: true
            },
            {
                pattern: /(^|[^\\])#.*/,
                lookbehind: true
            }
        ],
        "interpolated-string": {
            /* Look-behind and look-ahead prevents wrong behavior of the greedy pattern
       * forcing it to match """-quoted string when it would otherwise match "-quoted first. */ pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
            lookbehind: true,
            greedy: true,
            inside: {
                variable: {
                    pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
                    lookbehind: true
                },
                interpolation: {
                    pattern: /(^|[^\\])#\{[^}]+\}/m,
                    lookbehind: true,
                    inside: {
                        "interpolation-punctuation": {
                            pattern: /^#\{|\}$/,
                            alias: "variable"
                        } // See rest below
                    }
                },
                string: /[\s\S]+/
            }
        },
        string: [
            {
                pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
                greedy: true
            },
            {
                pattern: /<\[[\s\S]*?\]>/,
                greedy: true
            },
            /\\[^\s,;\])}]+/
        ],
        regex: [
            {
                pattern: /\/\/(?:\[[^\r\n\]]*\]|\\.|(?!\/\/)[^\\\[])+\/\/[gimyu]{0,5}/,
                greedy: true,
                inside: {
                    comment: {
                        pattern: /(^|[^\\])#.*/,
                        lookbehind: true
                    }
                }
            },
            {
                pattern: /\/(?:\[[^\r\n\]]*\]|\\.|[^/\\\r\n\[])+\/[gimyu]{0,5}/,
                greedy: true
            }
        ],
        keyword: {
            pattern: /(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
            lookbehind: true
        },
        "keyword-operator": {
            pattern: /(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?: not|nt)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
            lookbehind: true,
            alias: "operator"
        },
        boolean: {
            pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
            lookbehind: true
        },
        argument: {
            // Don't match .&. nor &&
            pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
            lookbehind: true,
            alias: "variable"
        },
        number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
        identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
        operator: [
            // Spaced .
            {
                pattern: /( )\.(?= )/,
                lookbehind: true
            },
            // .= .~ .. ...
            // .&. .^. .<<. .>>. .>>>.
            // := :: ::=
            // &&
            // || |>
            // < << <<< <<<<
            // <- <-- <-! <--!
            // <~ <~~ <~! <~~!
            // <| <= <?
            // > >> >= >?
            // - -- -> -->
            // + ++
            // @ @@
            // % %%
            // * **
            // ! != !~=
            // !~> !~~>
            // !-> !-->
            // ~ ~> ~~> ~=
            // = ==
            // ^ ^^
            // / ?
            /\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/
        ],
        punctuation: /[(){}\[\]|.,:;`]/
    };
    Prism.languages.livescript["interpolated-string"].inside["interpolation"].inside.rest = Prism.languages.livescript;
}

});

parcelRequire.register("7PhLK", function(module, exports) {
"use strict";
module.exports = $5b2b14641bedb494$var$llvm;
$5b2b14641bedb494$var$llvm.displayName = "llvm";
$5b2b14641bedb494$var$llvm.aliases = [];
function $5b2b14641bedb494$var$llvm(Prism1) {
    (function(Prism) {
        Prism.languages.llvm = {
            comment: /;.*/,
            string: {
                pattern: /"[^"]*"/,
                greedy: true
            },
            boolean: /\b(?:false|true)\b/,
            variable: /[%@!#](?:(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+|\d+)/i,
            label: /(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+:/i,
            type: {
                pattern: /\b(?:double|float|fp128|half|i[1-9]\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\b/,
                alias: "class-name"
            },
            keyword: /\b[a-z_][a-z_0-9]*\b/,
            number: /[+-]?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-Fa-f]+\b|\b0xK[\dA-Fa-f]{20}\b|\b0x[ML][\dA-Fa-f]{32}\b|\b0xH[\dA-Fa-f]{4}\b/,
            punctuation: /[{}[\];(),.!*=<>]/
        };
    })(Prism1);
}

});

parcelRequire.register("9lsgl", function(module, exports) {
"use strict";
module.exports = $6cdbff9d69b18410$var$log;
$6cdbff9d69b18410$var$log.displayName = "log";
$6cdbff9d69b18410$var$log.aliases = [];
function $6cdbff9d69b18410$var$log(Prism) {
    // This is a language definition for generic log files.
    // Since there is no one log format, this language definition has to support all formats to some degree.
    //
    // Based on https://github.com/MTDL9/vim-log-highlighting
    Prism.languages.log = {
        string: {
            // Single-quoted strings must not be confused with plain text. E.g. Can't isn't Susan's Chris' toy
            pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
            greedy: true
        },
        exception: {
            pattern: /(^|[^\w.])[a-z][\w.]*(?:Error|Exception):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
            lookbehind: true,
            greedy: true,
            alias: [
                "javastacktrace",
                "language-javastacktrace"
            ],
            inside: Prism.languages["javastacktrace"] || {
                keyword: /\bat\b/,
                function: /[a-z_][\w$]*(?=\()/,
                punctuation: /[.:()]/
            }
        },
        level: [
            {
                pattern: /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
                alias: [
                    "error",
                    "important"
                ]
            },
            {
                pattern: /\b(?:WARN|WARNING|WRN)\b/,
                alias: [
                    "warning",
                    "important"
                ]
            },
            {
                pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
                alias: [
                    "info",
                    "keyword"
                ]
            },
            {
                pattern: /\b(?:DBG|DEBUG|FINE)\b/,
                alias: [
                    "debug",
                    "keyword"
                ]
            },
            {
                pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
                alias: [
                    "trace",
                    "comment"
                ]
            }
        ],
        property: {
            pattern: /((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
            lookbehind: true
        },
        separator: {
            pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
            lookbehind: true,
            alias: "comment"
        },
        url: /\b(?:file|ftp|https?):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
        email: {
            pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
            lookbehind: true,
            alias: "url"
        },
        "ip-address": {
            pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/,
            alias: "constant"
        },
        "mac-address": {
            pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
            alias: "constant"
        },
        domain: {
            pattern: /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
            lookbehind: true,
            alias: "constant"
        },
        uuid: {
            pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
            alias: "constant"
        },
        hash: {
            pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i,
            alias: "constant"
        },
        "file-path": {
            pattern: /\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
            lookbehind: true,
            greedy: true,
            alias: "string"
        },
        date: {
            pattern: RegExp(/\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source + "|" + /\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/.source + "|" + /\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/.source, "i"),
            alias: "number"
        },
        time: {
            pattern: /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
            alias: "number"
        },
        boolean: /\b(?:false|null|true)\b/i,
        number: {
            pattern: /(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
            lookbehind: true
        },
        operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
        punctuation: /[\[\].,]/
    };
}

});

parcelRequire.register("kkEiL", function(module, exports) {
"use strict";
module.exports = $ecd4eff6615aec71$var$lolcode;
$ecd4eff6615aec71$var$lolcode.displayName = "lolcode";
$ecd4eff6615aec71$var$lolcode.aliases = [];
function $ecd4eff6615aec71$var$lolcode(Prism) {
    Prism.languages.lolcode = {
        comment: [
            /\bOBTW\s[\s\S]*?\sTLDR\b/,
            /\bBTW.+/
        ],
        string: {
            pattern: /"(?::.|[^":])*"/,
            inside: {
                variable: /:\{[^}]+\}/,
                symbol: [
                    /:\([a-f\d]+\)/i,
                    /:\[[^\]]+\]/,
                    /:[)>o":]/
                ]
            },
            greedy: true
        },
        number: /(?:\B-)?(?:\b\d+(?:\.\d*)?|\B\.\d+)/,
        symbol: {
            pattern: /(^|\s)(?:A )?(?:BUKKIT|NOOB|NUMBAR|NUMBR|TROOF|YARN)(?=\s|,|$)/,
            lookbehind: true,
            inside: {
                keyword: /A(?=\s)/
            }
        },
        label: {
            pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
            lookbehind: true,
            alias: "string"
        },
        function: {
            pattern: /((?:^|\s)(?:HOW IZ I|I IZ|IZ) )[a-zA-Z]\w*/,
            lookbehind: true
        },
        keyword: [
            {
                pattern: /(^|\s)(?:AN|FOUND YR|GIMMEH|GTFO|HAI|HAS A|HOW IZ I|I HAS A|I IZ|IF U SAY SO|IM IN YR|IM OUTTA YR|IS NOW(?: A)?|ITZ(?: A)?|IZ|KTHX|KTHXBYE|LIEK(?: A)?|MAEK|MEBBE|MKAY|NERFIN|NO WAI|O HAI IM|O RLY\?|OIC|OMG|OMGWTF|R|SMOOSH|SRS|TIL|UPPIN|VISIBLE|WILE|WTF\?|YA RLY|YR)(?=\s|,|$)/,
                lookbehind: true
            },
            /'Z(?=\s|,|$)/
        ],
        boolean: {
            pattern: /(^|\s)(?:FAIL|WIN)(?=\s|,|$)/,
            lookbehind: true
        },
        variable: {
            pattern: /(^|\s)IT(?=\s|,|$)/,
            lookbehind: true
        },
        operator: {
            pattern: /(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:ALL|ANY|BIGGR|BOTH|DIFF|EITHER|MOD|PRODUKT|QUOSHUNT|SMALLR|SUM|WON) OF)(?=\s|,|$)/,
            lookbehind: true
        },
        punctuation: /\.{3}|…|,|!/
    };
}

});

parcelRequire.register("gf0AF", function(module, exports) {
"use strict";
module.exports = $bd2e815079cad6c0$var$magma;
$bd2e815079cad6c0$var$magma.displayName = "magma";
$bd2e815079cad6c0$var$magma.aliases = [];
function $bd2e815079cad6c0$var$magma(Prism) {
    Prism.languages.magma = {
        output: {
            pattern: /^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
            lookbehind: true,
            greedy: true
        },
        comment: {
            pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
            greedy: true
        },
        string: {
            pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
            lookbehind: true,
            greedy: true
        },
        // http://magma.maths.usyd.edu.au/magma/handbook/text/82
        keyword: /\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
        boolean: /\b(?:false|true)\b/,
        generator: {
            pattern: /\b[a-z_]\w*(?=\s*<)/i,
            alias: "class-name"
        },
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: {
            pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
            lookbehind: true
        },
        operator: /->|[-+*/^~!|#=]|:=|\.\./,
        punctuation: /[()[\]{}<>,;.:]/
    };
}

});

parcelRequire.register("e9LrW", function(module, exports) {
"use strict";
module.exports = $a4e6b675ac10b5db$var$makefile;
$a4e6b675ac10b5db$var$makefile.displayName = "makefile";
$a4e6b675ac10b5db$var$makefile.aliases = [];
function $a4e6b675ac10b5db$var$makefile(Prism) {
    Prism.languages.makefile = {
        comment: {
            pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
            lookbehind: true
        },
        string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        "builtin-target": {
            pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
            alias: "builtin"
        },
        target: {
            pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
            alias: "symbol",
            inside: {
                variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
            }
        },
        variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
        // Directives
        keyword: /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
        function: {
            pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
            lookbehind: true
        },
        operator: /(?:::|[?:+!])?=|[|@]/,
        punctuation: /[:;(){}]/
    };
}

});

parcelRequire.register("5k2L6", function(module, exports) {
"use strict";
module.exports = $3e00f5cfc14d2e91$var$markdown;
$3e00f5cfc14d2e91$var$markdown.displayName = "markdown";
$3e00f5cfc14d2e91$var$markdown.aliases = [
    "md"
];
function $3e00f5cfc14d2e91$var$markdown(Prism1) {
    (function(Prism) {
        // Allow only one line break
        var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
        /**
     * This function is intended for the creation of the bold or italic pattern.
     *
     * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
     *
     * _Note:_ Keep in mind that this adds a capturing group.
     *
     * @param {string} pattern
     * @returns {RegExp}
     */ function createInline(pattern) {
            pattern = pattern.replace(/<inner>/g, function() {
                return inner;
            });
            return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
        }
        var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
        var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
            return tableCell;
        });
        var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
        Prism.languages.markdown = Prism.languages.extend("markup", {});
        Prism.languages.insertBefore("markdown", "prolog", {
            "front-matter-block": {
                pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
                lookbehind: true,
                greedy: true,
                inside: {
                    punctuation: /^---|---$/,
                    "front-matter": {
                        pattern: /\S+(?:\s+\S+)*/,
                        alias: [
                            "yaml",
                            "language-yaml"
                        ],
                        inside: Prism.languages.yaml
                    }
                }
            },
            blockquote: {
                // > ...
                pattern: /^>(?:[\t ]*>)*/m,
                alias: "punctuation"
            },
            table: {
                pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
                inside: {
                    "table-data-rows": {
                        pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
                        lookbehind: true,
                        inside: {
                            "table-data": {
                                pattern: RegExp(tableCell),
                                inside: Prism.languages.markdown
                            },
                            punctuation: /\|/
                        }
                    },
                    "table-line": {
                        pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
                        lookbehind: true,
                        inside: {
                            punctuation: /\||:?-{3,}:?/
                        }
                    },
                    "table-header-row": {
                        pattern: RegExp("^" + tableRow + "$"),
                        inside: {
                            "table-header": {
                                pattern: RegExp(tableCell),
                                alias: "important",
                                inside: Prism.languages.markdown
                            },
                            punctuation: /\|/
                        }
                    }
                }
            },
            code: [
                {
                    // Prefixed by 4 spaces or 1 tab and preceded by an empty line
                    pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
                    lookbehind: true,
                    alias: "keyword"
                },
                {
                    // ```optional language
                    // code block
                    // ```
                    pattern: /^```[\s\S]*?^```$/m,
                    greedy: true,
                    inside: {
                        "code-block": {
                            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
                            lookbehind: true
                        },
                        "code-language": {
                            pattern: /^(```).+/,
                            lookbehind: true
                        },
                        punctuation: /```/
                    }
                }
            ],
            title: [
                {
                    // title 1
                    // =======
                    // title 2
                    // -------
                    pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
                    alias: "important",
                    inside: {
                        punctuation: /==+$|--+$/
                    }
                },
                {
                    // # title 1
                    // ###### title 6
                    pattern: /(^\s*)#.+/m,
                    lookbehind: true,
                    alias: "important",
                    inside: {
                        punctuation: /^#+|#+$/
                    }
                }
            ],
            hr: {
                // ***
                // ---
                // * * *
                // -----------
                pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
                lookbehind: true,
                alias: "punctuation"
            },
            list: {
                // * item
                // + item
                // - item
                // 1. item
                pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
                lookbehind: true,
                alias: "punctuation"
            },
            "url-reference": {
                // [id]: http://example.com "Optional title"
                // [id]: http://example.com 'Optional title'
                // [id]: http://example.com (Optional title)
                // [id]: <http://example.com> "Optional title"
                pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
                inside: {
                    variable: {
                        pattern: /^(!?\[)[^\]]+/,
                        lookbehind: true
                    },
                    string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
                    punctuation: /^[\[\]!:]|[<>]/
                },
                alias: "url"
            },
            bold: {
                // **strong**
                // __strong__
                // allow one nested instance of italic text using the same delimiter
                pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
                lookbehind: true,
                greedy: true,
                inside: {
                    content: {
                        pattern: /(^..)[\s\S]+(?=..$)/,
                        lookbehind: true,
                        inside: {} // see below
                    },
                    punctuation: /\*\*|__/
                }
            },
            italic: {
                // *em*
                // _em_
                // allow one nested instance of bold text using the same delimiter
                pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
                lookbehind: true,
                greedy: true,
                inside: {
                    content: {
                        pattern: /(^.)[\s\S]+(?=.$)/,
                        lookbehind: true,
                        inside: {} // see below
                    },
                    punctuation: /[*_]/
                }
            },
            strike: {
                // ~~strike through~~
                // ~strike~
                // eslint-disable-next-line regexp/strict
                pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
                lookbehind: true,
                greedy: true,
                inside: {
                    content: {
                        pattern: /(^~~?)[\s\S]+(?=\1$)/,
                        lookbehind: true,
                        inside: {} // see below
                    },
                    punctuation: /~~?/
                }
            },
            "code-snippet": {
                // `code`
                // ``code``
                pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
                lookbehind: true,
                greedy: true,
                alias: [
                    "code",
                    "keyword"
                ]
            },
            url: {
                // [example](http://example.com "Optional title")
                // [example][id]
                // [example] [id]
                pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
                lookbehind: true,
                greedy: true,
                inside: {
                    operator: /^!/,
                    content: {
                        pattern: /(^\[)[^\]]+(?=\])/,
                        lookbehind: true,
                        inside: {} // see below
                    },
                    variable: {
                        pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
                        lookbehind: true
                    },
                    url: {
                        pattern: /(^\]\()[^\s)]+/,
                        lookbehind: true
                    },
                    string: {
                        pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
                        lookbehind: true
                    }
                }
            }
        });
        [
            "url",
            "bold",
            "italic",
            "strike"
        ].forEach(function(token) {
            [
                "url",
                "bold",
                "italic",
                "strike",
                "code-snippet"
            ].forEach(function(inside) {
                if (token !== inside) Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];
            });
        });
        Prism.hooks.add("after-tokenize", function(env) {
            if (env.language !== "markdown" && env.language !== "md") return;
            function walkTokens(tokens) {
                if (!tokens || typeof tokens === "string") return;
                for(var i = 0, l = tokens.length; i < l; i++){
                    var token = tokens[i];
                    if (token.type !== "code") {
                        walkTokens(token.content);
                        continue;
                    }
                    /*
           * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token
           * is optional. But the grammar is defined so that there is only one case we have to handle:
           *
           * token.content = [
           *     <span class="punctuation">```</span>,
           *     <span class="code-language">xxxx</span>,
           *     '\n', // exactly one new lines (\r or \n or \r\n)
           *     <span class="code-block">...</span>,
           *     '\n', // exactly one new lines again
           *     <span class="punctuation">```</span>
           * ];
           */ var codeLang = token.content[1];
                    var codeBlock = token.content[3];
                    if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
                        // this might be a language that Prism does not support
                        // do some replacements to support C++, C#, and F#
                        var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp") // only use the first word
                        ;
                        lang = (/[a-z][\w-]*/i.exec(lang) || [
                            ""
                        ])[0].toLowerCase();
                        var alias = "language-" + lang // add alias
                        ;
                        if (!codeBlock.alias) codeBlock.alias = [
                            alias
                        ];
                        else if (typeof codeBlock.alias === "string") codeBlock.alias = [
                            codeBlock.alias,
                            alias
                        ];
                        else codeBlock.alias.push(alias);
                    }
                }
            }
            walkTokens(env.tokens);
        });
        Prism.hooks.add("wrap", function(env) {
            if (env.type !== "code-block") return;
            var codeLang = "";
            for(var i = 0, l = env.classes.length; i < l; i++){
                var cls = env.classes[i];
                var match = /language-(.+)/.exec(cls);
                if (match) {
                    codeLang = match[1];
                    break;
                }
            }
            var grammar = Prism.languages[codeLang];
            if (!grammar) {
                if (codeLang && codeLang !== "none" && Prism.plugins.autoloader) {
                    var id = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
                    env.attributes["id"] = id;
                    Prism.plugins.autoloader.loadLanguages(codeLang, function() {
                        var ele = document.getElementById(id);
                        if (ele) ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);
                    });
                }
            } else env.content = Prism.highlight(textContent(env.content.value), grammar, codeLang);
        });
        var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, "gi");
        /**
     * A list of known entity names.
     *
     * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.
     *
     * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}
     */ var KNOWN_ENTITY_NAMES = {
            amp: "&",
            lt: "<",
            gt: ">",
            quot: '"'
        } // IE 11 doesn't support `String.fromCodePoint`
        ;
        var fromCodePoint = String.fromCodePoint || String.fromCharCode;
        /**
     * Returns the text content of a given HTML source code string.
     *
     * @param {string} html
     * @returns {string}
     */ function textContent(html) {
            // remove all tags
            var text = html.replace(tagPattern, "") // decode known entities
            ;
            text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, code) {
                code = code.toLowerCase();
                if (code[0] === "#") {
                    var value;
                    if (code[1] === "x") value = parseInt(code.slice(2), 16);
                    else value = Number(code.slice(1));
                    return fromCodePoint(value);
                } else {
                    var known = KNOWN_ENTITY_NAMES[code];
                    if (known) return known;
                     // unable to decode
                    return m;
                }
            });
            return text;
        }
        Prism.languages.md = Prism.languages.markdown;
    })(Prism1);
}

});

parcelRequire.register("lSxtO", function(module, exports) {
"use strict";
module.exports = $fed89c892552dcde$var$matlab;
$fed89c892552dcde$var$matlab.displayName = "matlab";
$fed89c892552dcde$var$matlab.aliases = [];
function $fed89c892552dcde$var$matlab(Prism) {
    Prism.languages.matlab = {
        comment: [
            /%\{[\s\S]*?\}%/,
            /%.+/
        ],
        string: {
            pattern: /\B'(?:''|[^'\r\n])*'/,
            greedy: true
        },
        // FIXME We could handle imaginary numbers as a whole
        number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
        keyword: /\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
        function: /\b(?!\d)\w+(?=\s*\()/,
        operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
        punctuation: /\.{3}|[.,;\[\](){}!]/
    };
}

});

parcelRequire.register("iMMJF", function(module, exports) {
"use strict";
module.exports = $dad283922cf78cc6$var$maxscript;
$dad283922cf78cc6$var$maxscript.displayName = "maxscript";
$dad283922cf78cc6$var$maxscript.aliases = [];
function $dad283922cf78cc6$var$maxscript(Prism1) {
    (function(Prism) {
        var keywords = /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
        Prism.languages.maxscript = {
            comment: {
                pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
                greedy: true
            },
            string: {
                pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
                lookbehind: true,
                greedy: true
            },
            path: {
                pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
                greedy: true,
                alias: "string"
            },
            "function-call": {
                pattern: RegExp("((?:" + (/^/.source + "|" + /[;=<>+\-*/^({\[]/.source + "|" + /\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/.source) + ")[ 	]*)" + "(?!" + keywords.source + ")" + /[a-z_]\w*\b/.source + "(?=[ 	]*(?:" + ("(?!" + keywords.source + ")" + /[a-z_]/.source + "|" + /\d|-\.?\d/.source + "|" + /[({'"$@#?]/.source) + "))", "im"),
                lookbehind: true,
                greedy: true,
                alias: "function"
            },
            "function-definition": {
                pattern: /(\b(?:fn|function)\s+)\w+\b/i,
                lookbehind: true,
                alias: "function"
            },
            argument: {
                pattern: /\b[a-z_]\w*(?=:)/i,
                alias: "attr-name"
            },
            keyword: keywords,
            boolean: /\b(?:false|true)\b/,
            time: {
                pattern: /(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
                lookbehind: true,
                alias: "number"
            },
            number: [
                {
                    pattern: /(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
                    lookbehind: true
                },
                /\b(?:e|pi)\b/
            ],
            constant: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/,
            color: {
                pattern: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/i,
                alias: "constant"
            },
            operator: /[-+*/<>=!]=?|[&^?]|#(?!\()/,
            punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
        };
    })(Prism1);
}

});

parcelRequire.register("hyGu8", function(module, exports) {
"use strict";
module.exports = $cc869148f61249a5$var$mel;
$cc869148f61249a5$var$mel.displayName = "mel";
$cc869148f61249a5$var$mel.aliases = [];
function $cc869148f61249a5$var$mel(Prism) {
    Prism.languages.mel = {
        comment: /\/\/.*/,
        code: {
            pattern: /`(?:\\.|[^\\`\r\n])*`/,
            greedy: true,
            alias: "italic",
            inside: {
                delimiter: {
                    pattern: /^`|`$/,
                    alias: "punctuation"
                } // See rest below
            }
        },
        string: {
            pattern: /"(?:\\.|[^\\"\r\n])*"/,
            greedy: true
        },
        variable: /\$\w+/,
        number: /\b0x[\da-fA-F]+\b|\b\d+(?:\.\d*)?|\B\.\d+/,
        flag: {
            pattern: /-[^\d\W]\w*/,
            alias: "operator"
        },
        keyword: /\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
        function: /\b\w+(?=\()|\b(?:CBG|HfAddAttractorToAS|HfAssignAS|HfBuildEqualMap|HfBuildFurFiles|HfBuildFurImages|HfCancelAFR|HfConnectASToHF|HfCreateAttractor|HfDeleteAS|HfEditAS|HfPerformCreateAS|HfRemoveAttractorFromAS|HfSelectAttached|HfSelectAttractors|HfUnAssignAS|Mayatomr|about|abs|addAttr|addAttributeEditorNodeHelp|addDynamic|addNewShelfTab|addPP|addPanelCategory|addPrefixToName|advanceToNextDrivenKey|affectedNet|affects|aimConstraint|air|alias|aliasAttr|align|alignCtx|alignCurve|alignSurface|allViewFit|ambientLight|angle|angleBetween|animCone|animCurveEditor|animDisplay|animView|annotate|appendStringArray|applicationName|applyAttrPreset|applyTake|arcLenDimContext|arcLengthDimension|arclen|arrayMapper|art3dPaintCtx|artAttrCtx|artAttrPaintVertexCtx|artAttrSkinPaintCtx|artAttrTool|artBuildPaintMenu|artFluidAttrCtx|artPuttyCtx|artSelectCtx|artSetPaintCtx|artUserPaintCtx|assignCommand|assignInputDevice|assignViewportFactories|attachCurve|attachDeviceAttr|attachSurface|attrColorSliderGrp|attrCompatibility|attrControlGrp|attrEnumOptionMenu|attrEnumOptionMenuGrp|attrFieldGrp|attrFieldSliderGrp|attrNavigationControlGrp|attrPresetEditWin|attributeExists|attributeInfo|attributeMenu|attributeQuery|autoKeyframe|autoPlace|bakeClip|bakeFluidShading|bakePartialHistory|bakeResults|bakeSimulation|basename|basenameEx|batchRender|bessel|bevel|bevelPlus|binMembership|bindSkin|blend2|blendShape|blendShapeEditor|blendShapePanel|blendTwoAttr|blindDataType|boneLattice|boundary|boxDollyCtx|boxZoomCtx|bufferCurve|buildBookmarkMenu|buildKeyframeMenu|button|buttonManip|cacheFile|cacheFileCombine|cacheFileMerge|cacheFileTrack|camera|cameraView|canCreateManip|canvas|capitalizeString|catch|catchQuiet|ceil|changeSubdivComponentDisplayLevel|changeSubdivRegion|channelBox|character|characterMap|characterOutlineEditor|characterize|chdir|checkBox|checkBoxGrp|checkDefaultRenderGlobals|choice|circle|circularFillet|clamp|clear|clearCache|clip|clipEditor|clipEditorCurrentTimeCtx|clipSchedule|clipSchedulerOutliner|clipTrimBefore|closeCurve|closeSurface|cluster|cmdFileOutput|cmdScrollFieldExecuter|cmdScrollFieldReporter|cmdShell|coarsenSubdivSelectionList|collision|color|colorAtPoint|colorEditor|colorIndex|colorIndexSliderGrp|colorSliderButtonGrp|colorSliderGrp|columnLayout|commandEcho|commandLine|commandPort|compactHairSystem|componentEditor|compositingInterop|computePolysetVolume|condition|cone|confirmDialog|connectAttr|connectControl|connectDynamic|connectJoint|connectionInfo|constrain|constrainValue|constructionHistory|container|containsMultibyte|contextInfo|control|convertFromOldLayers|convertIffToPsd|convertLightmap|convertSolidTx|convertTessellation|convertUnit|copyArray|copyFlexor|copyKey|copySkinWeights|cos|cpButton|cpCache|cpClothSet|cpCollision|cpConstraint|cpConvClothToMesh|cpForces|cpGetSolverAttr|cpPanel|cpProperty|cpRigidCollisionFilter|cpSeam|cpSetEdit|cpSetSolverAttr|cpSolver|cpSolverTypes|cpTool|cpUpdateClothUVs|createDisplayLayer|createDrawCtx|createEditor|createLayeredPsdFile|createMotionField|createNewShelf|createNode|createRenderLayer|createSubdivRegion|cross|crossProduct|ctxAbort|ctxCompletion|ctxEditMode|ctxTraverse|currentCtx|currentTime|currentTimeCtx|currentUnit|curve|curveAddPtCtx|curveCVCtx|curveEPCtx|curveEditorCtx|curveIntersect|curveMoveEPCtx|curveOnSurface|curveSketchCtx|cutKey|cycleCheck|cylinder|dagPose|date|defaultLightListCheckBox|defaultNavigation|defineDataServer|defineVirtualDevice|deformer|deg_to_rad|delete|deleteAttr|deleteShadingGroupsAndMaterials|deleteShelfTab|deleteUI|deleteUnusedBrushes|delrandstr|detachCurve|detachDeviceAttr|detachSurface|deviceEditor|devicePanel|dgInfo|dgdirty|dgeval|dgtimer|dimWhen|directKeyCtx|directionalLight|dirmap|dirname|disable|disconnectAttr|disconnectJoint|diskCache|displacementToPoly|displayAffected|displayColor|displayCull|displayLevelOfDetail|displayPref|displayRGBColor|displaySmoothness|displayStats|displayString|displaySurface|distanceDimContext|distanceDimension|doBlur|dolly|dollyCtx|dopeSheetEditor|dot|dotProduct|doubleProfileBirailSurface|drag|dragAttrContext|draggerContext|dropoffLocator|duplicate|duplicateCurve|duplicateSurface|dynCache|dynControl|dynExport|dynExpression|dynGlobals|dynPaintEditor|dynParticleCtx|dynPref|dynRelEdPanel|dynRelEditor|dynamicLoad|editAttrLimits|editDisplayLayerGlobals|editDisplayLayerMembers|editRenderLayerAdjustment|editRenderLayerGlobals|editRenderLayerMembers|editor|editorTemplate|effector|emit|emitter|enableDevice|encodeString|endString|endsWith|env|equivalent|equivalentTol|erf|error|eval|evalDeferred|evalEcho|event|exactWorldBoundingBox|exclusiveLightCheckBox|exec|executeForEachObject|exists|exp|expression|expressionEditorListen|extendCurve|extendSurface|extrude|fcheck|fclose|feof|fflush|fgetline|fgetword|file|fileBrowserDialog|fileDialog|fileExtension|fileInfo|filetest|filletCurve|filter|filterCurve|filterExpand|filterStudioImport|findAllIntersections|findAnimCurves|findKeyframe|findMenuItem|findRelatedSkinCluster|finder|firstParentOf|fitBspline|flexor|floatEq|floatField|floatFieldGrp|floatScrollBar|floatSlider|floatSlider2|floatSliderButtonGrp|floatSliderGrp|floor|flow|fluidCacheInfo|fluidEmitter|fluidVoxelInfo|flushUndo|fmod|fontDialog|fopen|formLayout|format|fprint|frameLayout|fread|freeFormFillet|frewind|fromNativePath|fwrite|gamma|gauss|geometryConstraint|getApplicationVersionAsFloat|getAttr|getClassification|getDefaultBrush|getFileList|getFluidAttr|getInputDeviceRange|getMayaPanelTypes|getModifiers|getPanel|getParticleAttr|getPluginResource|getenv|getpid|glRender|glRenderEditor|globalStitch|gmatch|goal|gotoBindPose|grabColor|gradientControl|gradientControlNoAttr|graphDollyCtx|graphSelectContext|graphTrackCtx|gravity|grid|gridLayout|group|groupObjectsByName|hardenPointCurve|hardware|hardwareRenderPanel|headsUpDisplay|headsUpMessage|help|helpLine|hermite|hide|hilite|hitTest|hotBox|hotkey|hotkeyCheck|hsv_to_rgb|hudButton|hudSlider|hudSliderButton|hwReflectionMap|hwRender|hwRenderLoad|hyperGraph|hyperPanel|hyperShade|hypot|iconTextButton|iconTextCheckBox|iconTextRadioButton|iconTextRadioCollection|iconTextScrollList|iconTextStaticLabel|ikHandle|ikHandleCtx|ikHandleDisplayScale|ikSolver|ikSplineHandleCtx|ikSystem|ikSystemInfo|ikfkDisplayMethod|illustratorCurves|image|imfPlugins|inheritTransform|insertJoint|insertJointCtx|insertKeyCtx|insertKnotCurve|insertKnotSurface|instance|instanceable|instancer|intField|intFieldGrp|intScrollBar|intSlider|intSliderGrp|interToUI|internalVar|intersect|iprEngine|isAnimCurve|isConnected|isDirty|isParentOf|isSameObject|isTrue|isValidObjectName|isValidString|isValidUiName|isolateSelect|itemFilter|itemFilterAttr|itemFilterRender|itemFilterType|joint|jointCluster|jointCtx|jointDisplayScale|jointLattice|keyTangent|keyframe|keyframeOutliner|keyframeRegionCurrentTimeCtx|keyframeRegionDirectKeyCtx|keyframeRegionDollyCtx|keyframeRegionInsertKeyCtx|keyframeRegionMoveKeyCtx|keyframeRegionScaleKeyCtx|keyframeRegionSelectKeyCtx|keyframeRegionSetKeyCtx|keyframeRegionTrackCtx|keyframeStats|lassoContext|lattice|latticeDeformKeyCtx|launch|launchImageEditor|layerButton|layeredShaderPort|layeredTexturePort|layout|layoutDialog|lightList|lightListEditor|lightListPanel|lightlink|lineIntersection|linearPrecision|linstep|listAnimatable|listAttr|listCameras|listConnections|listDeviceAttachments|listHistory|listInputDeviceAxes|listInputDeviceButtons|listInputDevices|listMenuAnnotation|listNodeTypes|listPanelCategories|listRelatives|listSets|listTransforms|listUnselected|listerEditor|loadFluid|loadNewShelf|loadPlugin|loadPluginLanguageResources|loadPrefObjects|localizedPanelLabel|lockNode|loft|log|longNameOf|lookThru|ls|lsThroughFilter|lsType|lsUI|mag|makeIdentity|makeLive|makePaintable|makeRoll|makeSingleSurface|makeTubeOn|makebot|manipMoveContext|manipMoveLimitsCtx|manipOptions|manipRotateContext|manipRotateLimitsCtx|manipScaleContext|manipScaleLimitsCtx|marker|match|max|memory|menu|menuBarLayout|menuEditor|menuItem|menuItemToShelf|menuSet|menuSetPref|messageLine|min|minimizeApp|mirrorJoint|modelCurrentTimeCtx|modelEditor|modelPanel|mouse|movIn|movOut|move|moveIKtoFK|moveKeyCtx|moveVertexAlongDirection|multiProfileBirailSurface|mute|nParticle|nameCommand|nameField|namespace|namespaceInfo|newPanelItems|newton|nodeCast|nodeIconButton|nodeOutliner|nodePreset|nodeType|noise|nonLinear|normalConstraint|normalize|nurbsBoolean|nurbsCopyUVSet|nurbsCube|nurbsEditUV|nurbsPlane|nurbsSelect|nurbsSquare|nurbsToPoly|nurbsToPolygonsPref|nurbsToSubdiv|nurbsToSubdivPref|nurbsUVSet|nurbsViewDirectionVector|objExists|objectCenter|objectLayer|objectType|objectTypeUI|obsoleteProc|oceanNurbsPreviewPlane|offsetCurve|offsetCurveOnSurface|offsetSurface|openGLExtension|openMayaPref|optionMenu|optionMenuGrp|optionVar|orbit|orbitCtx|orientConstraint|outlinerEditor|outlinerPanel|overrideModifier|paintEffectsDisplay|pairBlend|palettePort|paneLayout|panel|panelConfiguration|panelHistory|paramDimContext|paramDimension|paramLocator|parent|parentConstraint|particle|particleExists|particleInstancer|particleRenderInfo|partition|pasteKey|pathAnimation|pause|pclose|percent|performanceOptions|pfxstrokes|pickWalk|picture|pixelMove|planarSrf|plane|play|playbackOptions|playblast|plugAttr|plugNode|pluginInfo|pluginResourceUtil|pointConstraint|pointCurveConstraint|pointLight|pointMatrixMult|pointOnCurve|pointOnSurface|pointPosition|poleVectorConstraint|polyAppend|polyAppendFacetCtx|polyAppendVertex|polyAutoProjection|polyAverageNormal|polyAverageVertex|polyBevel|polyBlendColor|polyBlindData|polyBoolOp|polyBridgeEdge|polyCacheMonitor|polyCheck|polyChipOff|polyClipboard|polyCloseBorder|polyCollapseEdge|polyCollapseFacet|polyColorBlindData|polyColorDel|polyColorPerVertex|polyColorSet|polyCompare|polyCone|polyCopyUV|polyCrease|polyCreaseCtx|polyCreateFacet|polyCreateFacetCtx|polyCube|polyCut|polyCutCtx|polyCylinder|polyCylindricalProjection|polyDelEdge|polyDelFacet|polyDelVertex|polyDuplicateAndConnect|polyDuplicateEdge|polyEditUV|polyEditUVShell|polyEvaluate|polyExtrudeEdge|polyExtrudeFacet|polyExtrudeVertex|polyFlipEdge|polyFlipUV|polyForceUV|polyGeoSampler|polyHelix|polyInfo|polyInstallAction|polyLayoutUV|polyListComponentConversion|polyMapCut|polyMapDel|polyMapSew|polyMapSewMove|polyMergeEdge|polyMergeEdgeCtx|polyMergeFacet|polyMergeFacetCtx|polyMergeUV|polyMergeVertex|polyMirrorFace|polyMoveEdge|polyMoveFacet|polyMoveFacetUV|polyMoveUV|polyMoveVertex|polyNormal|polyNormalPerVertex|polyNormalizeUV|polyOptUvs|polyOptions|polyOutput|polyPipe|polyPlanarProjection|polyPlane|polyPlatonicSolid|polyPoke|polyPrimitive|polyPrism|polyProjection|polyPyramid|polyQuad|polyQueryBlindData|polyReduce|polySelect|polySelectConstraint|polySelectConstraintMonitor|polySelectCtx|polySelectEditCtx|polySeparate|polySetToFaceNormal|polySewEdge|polyShortestPathCtx|polySmooth|polySoftEdge|polySphere|polySphericalProjection|polySplit|polySplitCtx|polySplitEdge|polySplitRing|polySplitVertex|polyStraightenUVBorder|polySubdivideEdge|polySubdivideFacet|polyToSubdiv|polyTorus|polyTransfer|polyTriangulate|polyUVSet|polyUnite|polyWedgeFace|popen|popupMenu|pose|pow|preloadRefEd|print|progressBar|progressWindow|projFileViewer|projectCurve|projectTangent|projectionContext|projectionManip|promptDialog|propModCtx|propMove|psdChannelOutliner|psdEditTextureFile|psdExport|psdTextureFile|putenv|pwd|python|querySubdiv|quit|rad_to_deg|radial|radioButton|radioButtonGrp|radioCollection|radioMenuItemCollection|rampColorPort|rand|randomizeFollicles|randstate|rangeControl|readTake|rebuildCurve|rebuildSurface|recordAttr|recordDevice|redo|reference|referenceEdit|referenceQuery|refineSubdivSelectionList|refresh|refreshAE|registerPluginResource|rehash|reloadImage|removeJoint|removeMultiInstance|removePanelCategory|rename|renameAttr|renameSelectionList|renameUI|render|renderGlobalsNode|renderInfo|renderLayerButton|renderLayerParent|renderLayerPostProcess|renderLayerUnparent|renderManip|renderPartition|renderQualityNode|renderSettings|renderThumbnailUpdate|renderWindowEditor|renderWindowSelectContext|renderer|reorder|reorderDeformers|requires|reroot|resampleFluid|resetAE|resetPfxToPolyCamera|resetTool|resolutionNode|retarget|reverseCurve|reverseSurface|revolve|rgb_to_hsv|rigidBody|rigidSolver|roll|rollCtx|rootOf|rot|rotate|rotationInterpolation|roundConstantRadius|rowColumnLayout|rowLayout|runTimeCommand|runup|sampleImage|saveAllShelves|saveAttrPreset|saveFluid|saveImage|saveInitialState|saveMenu|savePrefObjects|savePrefs|saveShelf|saveToolSettings|scale|scaleBrushBrightness|scaleComponents|scaleConstraint|scaleKey|scaleKeyCtx|sceneEditor|sceneUIReplacement|scmh|scriptCtx|scriptEditorInfo|scriptJob|scriptNode|scriptTable|scriptToShelf|scriptedPanel|scriptedPanelType|scrollField|scrollLayout|sculpt|searchPathArray|seed|selLoadSettings|select|selectContext|selectCurveCV|selectKey|selectKeyCtx|selectKeyframeRegionCtx|selectMode|selectPref|selectPriority|selectType|selectedNodes|selectionConnection|separator|setAttr|setAttrEnumResource|setAttrMapping|setAttrNiceNameResource|setConstraintRestPosition|setDefaultShadingGroup|setDrivenKeyframe|setDynamic|setEditCtx|setEditor|setFluidAttr|setFocus|setInfinity|setInputDeviceMapping|setKeyCtx|setKeyPath|setKeyframe|setKeyframeBlendshapeTargetWts|setMenuMode|setNodeNiceNameResource|setNodeTypeFlag|setParent|setParticleAttr|setPfxToPolyCamera|setPluginResource|setProject|setStampDensity|setStartupMessage|setState|setToolTo|setUITemplate|setXformManip|sets|shadingConnection|shadingGeometryRelCtx|shadingLightRelCtx|shadingNetworkCompare|shadingNode|shapeCompare|shelfButton|shelfLayout|shelfTabLayout|shellField|shortNameOf|showHelp|showHidden|showManipCtx|showSelectionInTitle|showShadingGroupAttrEditor|showWindow|sign|simplify|sin|singleProfileBirailSurface|size|sizeBytes|skinCluster|skinPercent|smoothCurve|smoothTangentSurface|smoothstep|snap2to2|snapKey|snapMode|snapTogetherCtx|snapshot|soft|softMod|softModCtx|sort|sound|soundControl|source|spaceLocator|sphere|sphrand|spotLight|spotLightPreviewPort|spreadSheetEditor|spring|sqrt|squareSurface|srtContext|stackTrace|startString|startsWith|stitchAndExplodeShell|stitchSurface|stitchSurfacePoints|strcmp|stringArrayCatenate|stringArrayContains|stringArrayCount|stringArrayInsertAtIndex|stringArrayIntersector|stringArrayRemove|stringArrayRemoveAtIndex|stringArrayRemoveDuplicates|stringArrayRemoveExact|stringArrayToString|stringToStringArray|strip|stripPrefixFromName|stroke|subdAutoProjection|subdCleanTopology|subdCollapse|subdDuplicateAndConnect|subdEditUV|subdListComponentConversion|subdMapCut|subdMapSewMove|subdMatchTopology|subdMirror|subdToBlind|subdToPoly|subdTransferUVsToCache|subdiv|subdivCrease|subdivDisplaySmoothness|substitute|substituteAllString|substituteGeometry|substring|surface|surfaceSampler|surfaceShaderList|swatchDisplayPort|switchTable|symbolButton|symbolCheckBox|sysFile|system|tabLayout|tan|tangentConstraint|texLatticeDeformContext|texManipContext|texMoveContext|texMoveUVShellContext|texRotateContext|texScaleContext|texSelectContext|texSelectShortestPathCtx|texSmudgeUVContext|texWinToolCtx|text|textCurves|textField|textFieldButtonGrp|textFieldGrp|textManip|textScrollList|textToShelf|textureDisplacePlane|textureHairColor|texturePlacementContext|textureWindow|threadCount|threePointArcCtx|timeControl|timePort|timerX|toNativePath|toggle|toggleAxis|toggleWindowVisibility|tokenize|tokenizeList|tolerance|tolower|toolButton|toolCollection|toolDropped|toolHasOptions|toolPropertyWindow|torus|toupper|trace|track|trackCtx|transferAttributes|transformCompare|transformLimits|translator|trim|trunc|truncateFluidCache|truncateHairCache|tumble|tumbleCtx|turbulence|twoPointArcCtx|uiRes|uiTemplate|unassignInputDevice|undo|undoInfo|ungroup|uniform|unit|unloadPlugin|untangleUV|untitledFileName|untrim|upAxis|updateAE|userCtx|uvLink|uvSnapshot|validateShelfName|vectorize|view2dToolCtx|viewCamera|viewClipPlane|viewFit|viewHeadOn|viewLookAt|viewManip|viewPlace|viewSet|visor|volumeAxis|vortex|waitCursor|warning|webBrowser|webBrowserPrefs|whatIs|window|windowPref|wire|wireContext|workspace|wrinkle|wrinkleContext|writeTake|xbmLangPathList|xform)\b/,
        operator: [
            /\+[+=]?|-[-=]?|&&|\|\||[<>]=|[*\/!=]=?|[%^]/,
            {
                // We don't want to match <<
                pattern: /(^|[^<])<(?!<)/,
                lookbehind: true
            },
            {
                // We don't want to match >>
                pattern: /(^|[^>])>(?!>)/,
                lookbehind: true
            }
        ],
        punctuation: /<<|>>|[.,:;?\[\](){}]/
    };
    Prism.languages.mel["code"].inside.rest = Prism.languages.mel;
}

});

parcelRequire.register("lRMCr", function(module, exports) {
"use strict";
module.exports = $feb442ec3da9ca72$var$mermaid;
$feb442ec3da9ca72$var$mermaid.displayName = "mermaid";
$feb442ec3da9ca72$var$mermaid.aliases = [];
function $feb442ec3da9ca72$var$mermaid(Prism) {
    Prism.languages.mermaid = {
        comment: {
            pattern: /%%.*/,
            greedy: true
        },
        style: {
            pattern: /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
            lookbehind: true,
            inside: {
                property: /\b\w[\w-]*(?=[ \t]*:)/,
                operator: /:/,
                punctuation: /,/
            }
        },
        "inter-arrow-label": {
            pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
            lookbehind: true,
            greedy: true,
            inside: {
                arrow: {
                    pattern: /(?:\.+->?|--+[->]|==+[=>])$/,
                    alias: "operator"
                },
                label: {
                    pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
                    lookbehind: true,
                    alias: "property"
                },
                "arrow-head": {
                    pattern: /^\S+/,
                    alias: [
                        "arrow",
                        "operator"
                    ]
                }
            }
        },
        arrow: [
            // This might look complex but it really isn't.
            // There are many possible arrows (see tests) and it's impossible to fit all of them into one pattern. The
            // problem is that we only have one lookbehind per pattern. However, we cannot disallow too many arrow
            // characters in the one lookbehind because that would create too many false negatives. So we have to split the
            // arrows into different patterns.
            {
                // ER diagram
                pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
                lookbehind: true,
                alias: "operator"
            },
            {
                // flow chart
                // (?:==+|--+|-\.*-)
                pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
                lookbehind: true,
                alias: "operator"
            },
            {
                // sequence diagram
                pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
                lookbehind: true,
                alias: "operator"
            },
            {
                // class diagram
                pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
                lookbehind: true,
                alias: "operator"
            }
        ],
        label: {
            pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
            lookbehind: true,
            greedy: true,
            alias: "property"
        },
        text: {
            pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
            alias: "string"
        },
        string: {
            pattern: /"[^"\r\n]*"/,
            greedy: true
        },
        annotation: {
            pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
            alias: "important"
        },
        keyword: [
            // This language has both case-sensitive and case-insensitive keywords
            {
                pattern: /(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
                lookbehind: true,
                greedy: true
            },
            {
                pattern: /(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
                lookbehind: true,
                greedy: true
            }
        ],
        entity: /#[a-z0-9]+;/,
        operator: {
            pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/,
            lookbehind: true
        },
        punctuation: /[(){};]/
    };
}

});

parcelRequire.register("b6Pkx", function(module, exports) {
"use strict";
module.exports = $8168125ed67808d4$var$mizar;
$8168125ed67808d4$var$mizar.displayName = "mizar";
$8168125ed67808d4$var$mizar.aliases = [];
function $8168125ed67808d4$var$mizar(Prism) {
    Prism.languages.mizar = {
        comment: /::.+/,
        keyword: /@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|end|environ|equals|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:ies|y)|when|where|with|wrt)\b/,
        parameter: {
            pattern: /\$(?:10|\d)/,
            alias: "variable"
        },
        variable: /\b\w+(?=:)/,
        number: /(?:\b|-)\d+\b/,
        operator: /\.\.\.|->|&|\.?=/,
        punctuation: /\(#|#\)|[,:;\[\](){}]/
    };
}

});

parcelRequire.register("593Eo", function(module, exports) {
"use strict";
module.exports = $3bf09fe73735a286$var$mongodb;
$3bf09fe73735a286$var$mongodb.displayName = "mongodb";
$3bf09fe73735a286$var$mongodb.aliases = [];
function $3bf09fe73735a286$var$mongodb(Prism1) {
    (function(Prism) {
        var operators = [
            // query and projection
            "$eq",
            "$gt",
            "$gte",
            "$in",
            "$lt",
            "$lte",
            "$ne",
            "$nin",
            "$and",
            "$not",
            "$nor",
            "$or",
            "$exists",
            "$type",
            "$expr",
            "$jsonSchema",
            "$mod",
            "$regex",
            "$text",
            "$where",
            "$geoIntersects",
            "$geoWithin",
            "$near",
            "$nearSphere",
            "$all",
            "$elemMatch",
            "$size",
            "$bitsAllClear",
            "$bitsAllSet",
            "$bitsAnyClear",
            "$bitsAnySet",
            "$comment",
            "$elemMatch",
            "$meta",
            "$slice",
            "$currentDate",
            "$inc",
            "$min",
            "$max",
            "$mul",
            "$rename",
            "$set",
            "$setOnInsert",
            "$unset",
            "$addToSet",
            "$pop",
            "$pull",
            "$push",
            "$pullAll",
            "$each",
            "$position",
            "$slice",
            "$sort",
            "$bit",
            "$addFields",
            "$bucket",
            "$bucketAuto",
            "$collStats",
            "$count",
            "$currentOp",
            "$facet",
            "$geoNear",
            "$graphLookup",
            "$group",
            "$indexStats",
            "$limit",
            "$listLocalSessions",
            "$listSessions",
            "$lookup",
            "$match",
            "$merge",
            "$out",
            "$planCacheStats",
            "$project",
            "$redact",
            "$replaceRoot",
            "$replaceWith",
            "$sample",
            "$set",
            "$skip",
            "$sort",
            "$sortByCount",
            "$unionWith",
            "$unset",
            "$unwind",
            "$setWindowFields",
            "$abs",
            "$accumulator",
            "$acos",
            "$acosh",
            "$add",
            "$addToSet",
            "$allElementsTrue",
            "$and",
            "$anyElementTrue",
            "$arrayElemAt",
            "$arrayToObject",
            "$asin",
            "$asinh",
            "$atan",
            "$atan2",
            "$atanh",
            "$avg",
            "$binarySize",
            "$bsonSize",
            "$ceil",
            "$cmp",
            "$concat",
            "$concatArrays",
            "$cond",
            "$convert",
            "$cos",
            "$dateFromParts",
            "$dateToParts",
            "$dateFromString",
            "$dateToString",
            "$dayOfMonth",
            "$dayOfWeek",
            "$dayOfYear",
            "$degreesToRadians",
            "$divide",
            "$eq",
            "$exp",
            "$filter",
            "$first",
            "$floor",
            "$function",
            "$gt",
            "$gte",
            "$hour",
            "$ifNull",
            "$in",
            "$indexOfArray",
            "$indexOfBytes",
            "$indexOfCP",
            "$isArray",
            "$isNumber",
            "$isoDayOfWeek",
            "$isoWeek",
            "$isoWeekYear",
            "$last",
            "$last",
            "$let",
            "$literal",
            "$ln",
            "$log",
            "$log10",
            "$lt",
            "$lte",
            "$ltrim",
            "$map",
            "$max",
            "$mergeObjects",
            "$meta",
            "$min",
            "$millisecond",
            "$minute",
            "$mod",
            "$month",
            "$multiply",
            "$ne",
            "$not",
            "$objectToArray",
            "$or",
            "$pow",
            "$push",
            "$radiansToDegrees",
            "$range",
            "$reduce",
            "$regexFind",
            "$regexFindAll",
            "$regexMatch",
            "$replaceOne",
            "$replaceAll",
            "$reverseArray",
            "$round",
            "$rtrim",
            "$second",
            "$setDifference",
            "$setEquals",
            "$setIntersection",
            "$setIsSubset",
            "$setUnion",
            "$size",
            "$sin",
            "$slice",
            "$split",
            "$sqrt",
            "$stdDevPop",
            "$stdDevSamp",
            "$strcasecmp",
            "$strLenBytes",
            "$strLenCP",
            "$substr",
            "$substrBytes",
            "$substrCP",
            "$subtract",
            "$sum",
            "$switch",
            "$tan",
            "$toBool",
            "$toDate",
            "$toDecimal",
            "$toDouble",
            "$toInt",
            "$toLong",
            "$toObjectId",
            "$toString",
            "$toLower",
            "$toUpper",
            "$trim",
            "$trunc",
            "$type",
            "$week",
            "$year",
            "$zip",
            "$count",
            "$dateAdd",
            "$dateDiff",
            "$dateSubtract",
            "$dateTrunc",
            "$getField",
            "$rand",
            "$sampleRate",
            "$setField",
            "$unsetField",
            "$comment",
            "$explain",
            "$hint",
            "$max",
            "$maxTimeMS",
            "$min",
            "$orderby",
            "$query",
            "$returnKey",
            "$showDiskLoc",
            "$natural"
        ];
        var builtinFunctions = [
            "ObjectId",
            "Code",
            "BinData",
            "DBRef",
            "Timestamp",
            "NumberLong",
            "NumberDecimal",
            "MaxKey",
            "MinKey",
            "RegExp",
            "ISODate",
            "UUID"
        ];
        operators = operators.map(function(operator) {
            return operator.replace("$", "\\$");
        });
        var operatorsSource = "(?:" + operators.join("|") + ")\\b";
        Prism.languages.mongodb = Prism.languages.extend("javascript", {});
        Prism.languages.insertBefore("mongodb", "string", {
            property: {
                pattern: /(?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)(?=\s*:)/,
                greedy: true,
                inside: {
                    keyword: RegExp("^(['\"])?" + operatorsSource + "(?:\\1)?$")
                }
            }
        });
        Prism.languages.mongodb.string.inside = {
            url: {
                // url pattern
                pattern: /https?:\/\/[-\w@:%.+~#=]{1,256}\.[a-z0-9()]{1,6}\b[-\w()@:%+.~#?&/=]*/i,
                greedy: true
            },
            entity: {
                // ipv4
                pattern: /\b(?:(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d\d?|2[0-4]\d|25[0-5])\b/,
                greedy: true
            }
        };
        Prism.languages.insertBefore("mongodb", "constant", {
            builtin: {
                pattern: RegExp("\\b(?:" + builtinFunctions.join("|") + ")\\b"),
                alias: "keyword"
            }
        });
    })(Prism1);
}

});

parcelRequire.register("2cqwT", function(module, exports) {
"use strict";
module.exports = $19a147f995c98b9c$var$monkey;
$19a147f995c98b9c$var$monkey.displayName = "monkey";
$19a147f995c98b9c$var$monkey.aliases = [];
function $19a147f995c98b9c$var$monkey(Prism) {
    Prism.languages.monkey = {
        comment: {
            pattern: /^#Rem\s[\s\S]*?^#End|'.+/im,
            greedy: true
        },
        string: {
            pattern: /"[^"\r\n]*"/,
            greedy: true
        },
        preprocessor: {
            pattern: /(^[ \t]*)#.+/m,
            lookbehind: true,
            greedy: true,
            alias: "property"
        },
        function: /\b\w+(?=\()/,
        "type-char": {
            pattern: /\b[?%#$]/,
            alias: "class-name"
        },
        number: {
            pattern: /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
            lookbehind: true
        },
        keyword: /\b(?:Abstract|Array|Bool|Case|Catch|Class|Const|Continue|Default|Eachin|Else|ElseIf|End|EndIf|Exit|Extends|Extern|False|Field|Final|Float|For|Forever|Function|Global|If|Implements|Import|Inline|Int|Interface|Local|Method|Module|New|Next|Null|Object|Private|Property|Public|Repeat|Return|Select|Self|Step|Strict|String|Super|Then|Throw|To|True|Try|Until|Void|Wend|While)\b/i,
        operator: /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
        punctuation: /[.,:;()\[\]]/
    };
}

});

parcelRequire.register("jM2KR", function(module, exports) {
"use strict";
module.exports = $e654a3153be7b43c$var$moonscript;
$e654a3153be7b43c$var$moonscript.displayName = "moonscript";
$e654a3153be7b43c$var$moonscript.aliases = [
    "moon"
];
function $e654a3153be7b43c$var$moonscript(Prism) {
    Prism.languages.moonscript = {
        comment: /--.*/,
        string: [
            {
                pattern: /'[^']*'|\[(=*)\[[\s\S]*?\]\1\]/,
                greedy: true
            },
            {
                pattern: /"[^"]*"/,
                greedy: true,
                inside: {
                    interpolation: {
                        pattern: /#\{[^{}]*\}/,
                        inside: {
                            moonscript: {
                                pattern: /(^#\{)[\s\S]+(?=\})/,
                                lookbehind: true,
                                inside: null // see beow
                            },
                            "interpolation-punctuation": {
                                pattern: /#\{|\}/,
                                alias: "punctuation"
                            }
                        }
                    }
                }
            }
        ],
        "class-name": [
            {
                pattern: /(\b(?:class|extends)[ \t]+)\w+/,
                lookbehind: true
            },
            /\b[A-Z]\w*/
        ],
        keyword: /\b(?:class|continue|do|else|elseif|export|extends|for|from|if|import|in|local|nil|return|self|super|switch|then|unless|using|when|while|with)\b/,
        variable: /@@?\w*/,
        property: {
            pattern: /\b(?!\d)\w+(?=:)|(:)(?!\d)\w+/,
            lookbehind: true
        },
        function: {
            pattern: /\b(?:_G|_VERSION|assert|collectgarbage|coroutine\.(?:create|resume|running|status|wrap|yield)|debug\.(?:debug|getfenv|gethook|getinfo|getlocal|getmetatable|getregistry|getupvalue|setfenv|sethook|setlocal|setmetatable|setupvalue|traceback)|dofile|error|getfenv|getmetatable|io\.(?:close|flush|input|lines|open|output|popen|read|stderr|stdin|stdout|tmpfile|type|write)|ipairs|load|loadfile|loadstring|math\.(?:abs|acos|asin|atan|atan2|ceil|cos|cosh|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pi|pow|rad|random|randomseed|sin|sinh|sqrt|tan|tanh)|module|next|os\.(?:clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(?:cpath|loaded|loadlib|path|preload|seeall)|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|string\.(?:byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|table\.(?:concat|insert|maxn|remove|sort)|tonumber|tostring|type|unpack|xpcall)\b/,
            inside: {
                punctuation: /\./
            }
        },
        boolean: /\b(?:false|true)\b/,
        number: /(?:\B\.\d+|\b\d+\.\d+|\b\d+(?=[eE]))(?:[eE][-+]?\d+)?\b|\b(?:0x[a-fA-F\d]+|\d+)(?:U?LL)?\b/,
        operator: /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
        punctuation: /[.,()[\]{}\\]/
    };
    Prism.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside = Prism.languages.moonscript;
    Prism.languages.moon = Prism.languages.moonscript;
}

});

parcelRequire.register("22sMC", function(module, exports) {
"use strict";
module.exports = $17c2186f64d19d6a$var$n1ql;
$17c2186f64d19d6a$var$n1ql.displayName = "n1ql";
$17c2186f64d19d6a$var$n1ql.aliases = [];
function $17c2186f64d19d6a$var$n1ql(Prism) {
    // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/index.html
    Prism.languages.n1ql = {
        comment: {
            pattern: /\/\*[\s\S]*?(?:$|\*\/)|--.*/,
            greedy: true
        },
        string: {
            pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\]|\1\1)*\1/,
            greedy: true
        },
        identifier: {
            pattern: /`(?:\\[\s\S]|[^\\`]|``)*`/,
            greedy: true
        },
        parameter: /\$[\w.]+/,
        // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html#n1ql-reserved-words
        keyword: /\b(?:ADVISE|ALL|ALTER|ANALYZE|AS|ASC|AT|BEGIN|BINARY|BOOLEAN|BREAK|BUCKET|BUILD|BY|CALL|CAST|CLUSTER|COLLATE|COLLECTION|COMMIT|COMMITTED|CONNECT|CONTINUE|CORRELATE|CORRELATED|COVER|CREATE|CURRENT|DATABASE|DATASET|DATASTORE|DECLARE|DECREMENT|DELETE|DERIVED|DESC|DESCRIBE|DISTINCT|DO|DROP|EACH|ELEMENT|EXCEPT|EXCLUDE|EXECUTE|EXPLAIN|FETCH|FILTER|FLATTEN|FLUSH|FOLLOWING|FOR|FORCE|FROM|FTS|FUNCTION|GOLANG|GRANT|GROUP|GROUPS|GSI|HASH|HAVING|IF|IGNORE|ILIKE|INCLUDE|INCREMENT|INDEX|INFER|INLINE|INNER|INSERT|INTERSECT|INTO|IS|ISOLATION|JAVASCRIPT|JOIN|KEY|KEYS|KEYSPACE|KNOWN|LANGUAGE|LAST|LEFT|LET|LETTING|LEVEL|LIMIT|LSM|MAP|MAPPING|MATCHED|MATERIALIZED|MERGE|MINUS|MISSING|NAMESPACE|NEST|NL|NO|NTH_VALUE|NULL|NULLS|NUMBER|OBJECT|OFFSET|ON|OPTION|OPTIONS|ORDER|OTHERS|OUTER|OVER|PARSE|PARTITION|PASSWORD|PATH|POOL|PRECEDING|PREPARE|PRIMARY|PRIVATE|PRIVILEGE|PROBE|PROCEDURE|PUBLIC|RANGE|RAW|REALM|REDUCE|RENAME|RESPECT|RETURN|RETURNING|REVOKE|RIGHT|ROLE|ROLLBACK|ROW|ROWS|SATISFIES|SAVEPOINT|SCHEMA|SCOPE|SELECT|SELF|SEMI|SET|SHOW|SOME|START|STATISTICS|STRING|SYSTEM|TIES|TO|TRAN|TRANSACTION|TRIGGER|TRUNCATE|UNBOUNDED|UNDER|UNION|UNIQUE|UNKNOWN|UNNEST|UNSET|UPDATE|UPSERT|USE|USER|USING|VALIDATE|VALUE|VALUES|VIA|VIEW|WHERE|WHILE|WINDOW|WITH|WORK|XOR)\b/i,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        boolean: /\b(?:FALSE|TRUE)\b/i,
        number: /(?:\b\d+\.|\B\.)\d+e[+\-]?\d+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
        operator: /[-+*\/%]|!=|==?|\|\||<[>=]?|>=?|\b(?:AND|ANY|ARRAY|BETWEEN|CASE|ELSE|END|EVERY|EXISTS|FIRST|IN|LIKE|NOT|OR|THEN|VALUED|WHEN|WITHIN)\b/i,
        punctuation: /[;[\](),.{}:]/
    };
}

});

parcelRequire.register("8kz8s", function(module, exports) {
"use strict";
module.exports = $610b7228e6381964$var$n4js;
$610b7228e6381964$var$n4js.displayName = "n4js";
$610b7228e6381964$var$n4js.aliases = [
    "n4jsd"
];
function $610b7228e6381964$var$n4js(Prism) {
    Prism.languages.n4js = Prism.languages.extend("javascript", {
        // Keywords from N4JS language spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html
        keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/
    });
    Prism.languages.insertBefore("n4js", "constant", {
        // Annotations in N4JS spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html#_annotations
        annotation: {
            pattern: /@+\w+/,
            alias: "operator"
        }
    });
    Prism.languages.n4jsd = Prism.languages.n4js;
}

});

parcelRequire.register("36CmC", function(module, exports) {
"use strict";
module.exports = $242fb0e60339900e$var$nand2tetrisHdl;
$242fb0e60339900e$var$nand2tetrisHdl.displayName = "nand2tetrisHdl";
$242fb0e60339900e$var$nand2tetrisHdl.aliases = [];
function $242fb0e60339900e$var$nand2tetrisHdl(Prism) {
    Prism.languages["nand2tetris-hdl"] = {
        comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
        keyword: /\b(?:BUILTIN|CHIP|CLOCKED|IN|OUT|PARTS)\b/,
        boolean: /\b(?:false|true)\b/,
        function: /\b[A-Za-z][A-Za-z0-9]*(?=\()/,
        number: /\b\d+\b/,
        operator: /=|\.\./,
        punctuation: /[{}[\];(),:]/
    };
}

});

parcelRequire.register("kJBmc", function(module, exports) {
"use strict";
module.exports = $f184fced44723418$var$naniscript;
$f184fced44723418$var$naniscript.displayName = "naniscript";
$f184fced44723418$var$naniscript.aliases = [];
function $f184fced44723418$var$naniscript(Prism1) {
    (function(Prism) {
        var expressionDef = /\{[^\r\n\[\]{}]*\}/;
        var params = {
            "quoted-string": {
                pattern: /"(?:[^"\\]|\\.)*"/,
                alias: "operator"
            },
            "command-param-id": {
                pattern: /(\s)\w+:/,
                lookbehind: true,
                alias: "property"
            },
            "command-param-value": [
                {
                    pattern: expressionDef,
                    alias: "selector"
                },
                {
                    pattern: /([\t ])\S+/,
                    lookbehind: true,
                    greedy: true,
                    alias: "operator"
                },
                {
                    pattern: /\S(?:.*\S)?/,
                    alias: "operator"
                }
            ]
        };
        Prism.languages.naniscript = {
            // ; ...
            comment: {
                pattern: /^([\t ]*);.*/m,
                lookbehind: true
            },
            // > ...
            // Define is a control line starting with '>' followed by a word, a space and a text.
            define: {
                pattern: /^>.+/m,
                alias: "tag",
                inside: {
                    value: {
                        pattern: /(^>\w+[\t ]+)(?!\s)[^{}\r\n]+/,
                        lookbehind: true,
                        alias: "operator"
                    },
                    key: {
                        pattern: /(^>)\w+/,
                        lookbehind: true
                    }
                }
            },
            // # ...
            label: {
                pattern: /^([\t ]*)#[\t ]*\w+[\t ]*$/m,
                lookbehind: true,
                alias: "regex"
            },
            command: {
                pattern: /^([\t ]*)@\w+(?=[\t ]|$).*/m,
                lookbehind: true,
                alias: "function",
                inside: {
                    "command-name": /^@\w+/,
                    expression: {
                        pattern: expressionDef,
                        greedy: true,
                        alias: "selector"
                    },
                    "command-params": {
                        pattern: /\s*\S[\s\S]*/,
                        inside: params
                    }
                }
            },
            // Generic is any line that doesn't start with operators: ;>#@
            "generic-text": {
                pattern: /(^[ \t]*)[^#@>;\s].*/m,
                lookbehind: true,
                alias: "punctuation",
                inside: {
                    // \{ ... \} ... \[ ... \] ... \"
                    "escaped-char": /\\[{}\[\]"]/,
                    expression: {
                        pattern: expressionDef,
                        greedy: true,
                        alias: "selector"
                    },
                    "inline-command": {
                        pattern: /\[[\t ]*\w[^\r\n\[\]]*\]/,
                        greedy: true,
                        alias: "function",
                        inside: {
                            "command-params": {
                                pattern: /(^\[[\t ]*\w+\b)[\s\S]+(?=\]$)/,
                                lookbehind: true,
                                inside: params
                            },
                            "command-param-name": {
                                pattern: /^(\[[\t ]*)\w+/,
                                lookbehind: true,
                                alias: "name"
                            },
                            "start-stop-char": /[\[\]]/
                        }
                    }
                }
            }
        };
        Prism.languages.nani = Prism.languages["naniscript"];
        /** @typedef {InstanceType<import("./prism-core")["Token"]>} Token */ /**
     * This hook is used to validate generic-text tokens for balanced brackets.
     * Mark token as bad-line when contains not balanced brackets: {},[]
     */ Prism.hooks.add("after-tokenize", function(env) {
            /** @type {(Token | string)[]} */ var tokens = env.tokens;
            tokens.forEach(function(token) {
                if (typeof token !== "string" && token.type === "generic-text") {
                    var content = getTextContent(token);
                    if (!isBracketsBalanced(content)) {
                        token.type = "bad-line";
                        token.content = content;
                    }
                }
            });
        });
        /**
     * @param {string} input
     * @returns {boolean}
     */ function isBracketsBalanced(input) {
            var brackets = "[]{}";
            var stack = [];
            for(var i = 0; i < input.length; i++){
                var bracket = input[i];
                var bracketsIndex = brackets.indexOf(bracket);
                if (bracketsIndex !== -1) {
                    if (bracketsIndex % 2 === 0) stack.push(bracketsIndex + 1);
                    else if (stack.pop() !== bracketsIndex) return false;
                }
            }
            return stack.length === 0;
        }
        /**
     * @param {string | Token | (string | Token)[]} token
     * @returns {string}
     */ function getTextContent(token) {
            if (typeof token === "string") return token;
            else if (Array.isArray(token)) return token.map(getTextContent).join("");
            else return getTextContent(token.content);
        }
    })(Prism1);
}

});

parcelRequire.register("YDp9F", function(module, exports) {
"use strict";
module.exports = $0b642bab3d2fe065$var$nasm;
$0b642bab3d2fe065$var$nasm.displayName = "nasm";
$0b642bab3d2fe065$var$nasm.aliases = [];
function $0b642bab3d2fe065$var$nasm(Prism) {
    Prism.languages.nasm = {
        comment: /;.*$/m,
        string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        label: {
            pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
            lookbehind: true,
            alias: "function"
        },
        keyword: [
            /\[?BITS (?:16|32|64)\]?/,
            {
                pattern: /(^\s*)section\s*[a-z.]+:?/im,
                lookbehind: true
            },
            /(?:extern|global)[^;\r\n]*/i,
            /(?:CPU|DEFAULT|FLOAT).*$/m
        ],
        register: {
            pattern: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s)\b/i,
            alias: "variable"
        },
        number: /(?:\b|(?=\$))(?:0[hx](?:\.[\da-f]+|[\da-f]+(?:\.[\da-f]+)?)(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
        operator: /[\[\]*+\-\/%<>=&|$!]/
    };
}

});

parcelRequire.register("bS79M", function(module, exports) {
"use strict";
module.exports = $8a4a4a05bb9acc12$var$neon;
$8a4a4a05bb9acc12$var$neon.displayName = "neon";
$8a4a4a05bb9acc12$var$neon.aliases = [];
function $8a4a4a05bb9acc12$var$neon(Prism) {
    Prism.languages.neon = {
        comment: {
            pattern: /#.*/,
            greedy: true
        },
        datetime: {
            pattern: /(^|[[{(=:,\s])\d\d\d\d-\d\d?-\d\d?(?:(?:[Tt]| +)\d\d?:\d\d:\d\d(?:\.\d*)? *(?:Z|[-+]\d\d?(?::?\d\d)?)?)?(?=$|[\]}),\s])/,
            lookbehind: true,
            alias: "number"
        },
        key: {
            pattern: /(^|[[{(,\s])[^,:=[\]{}()'"\s]+(?=\s*:(?:$|[\]}),\s])|\s*=)/,
            lookbehind: true,
            alias: "atrule"
        },
        number: {
            pattern: /(^|[[{(=:,\s])[+-]?(?:0x[\da-fA-F]+|0o[0-7]+|0b[01]+|(?:\d+(?:\.\d*)?|\.?\d+)(?:[eE][+-]?\d+)?)(?=$|[\]}),:=\s])/,
            lookbehind: true
        },
        boolean: {
            pattern: /(^|[[{(=:,\s])(?:false|no|true|yes)(?=$|[\]}),:=\s])/i,
            lookbehind: true
        },
        null: {
            pattern: /(^|[[{(=:,\s])(?:null)(?=$|[\]}),:=\s])/i,
            lookbehind: true,
            alias: "keyword"
        },
        string: {
            pattern: /(^|[[{(=:,\s])(?:('''|""")\r?\n(?:(?:[^\r\n]|\r?\n(?![\t ]*\2))*\r?\n)?[\t ]*\2|'[^'\r\n]*'|"(?:\\.|[^\\"\r\n])*")/,
            lookbehind: true,
            greedy: true
        },
        literal: {
            pattern: /(^|[[{(=:,\s])(?:[^#"',:=[\]{}()\s`-]|[:-][^"',=[\]{}()\s])(?:[^,:=\]})(\s]|:(?![\s,\]})]|$)|[ \t]+[^#,:=\]})(\s])*/,
            lookbehind: true,
            alias: "string"
        },
        punctuation: /[,:=[\]{}()-]/
    };
}

});

parcelRequire.register("9vpPI", function(module, exports) {
"use strict";
module.exports = $6ebb0c35ab24d5c5$var$nevod;
$6ebb0c35ab24d5c5$var$nevod.displayName = "nevod";
$6ebb0c35ab24d5c5$var$nevod.aliases = [];
function $6ebb0c35ab24d5c5$var$nevod(Prism) {
    Prism.languages.nevod = {
        comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
        string: {
            pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
            greedy: true,
            inside: {
                "string-attrs": /!$|!\*$|\*$/
            }
        },
        namespace: {
            pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
            lookbehind: true
        },
        pattern: {
            pattern: /(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
            lookbehind: true,
            inside: {
                "pattern-name": {
                    pattern: /^#?[a-zA-Z0-9\-.]+/,
                    alias: "class-name"
                },
                fields: {
                    pattern: /\(.*\)/,
                    inside: {
                        "field-name": {
                            pattern: /[a-zA-Z0-9\-.]+/,
                            alias: "variable"
                        },
                        punctuation: /[,()]/,
                        operator: {
                            pattern: /~/,
                            alias: "field-hidden-mark"
                        }
                    }
                }
            }
        },
        search: {
            pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
            alias: "function",
            lookbehind: true
        },
        keyword: /@(?:having|inside|namespace|outside|pattern|require|search|where)\b/,
        "standard-pattern": {
            pattern: /\b(?:Alpha|AlphaNum|Any|Blank|End|LineBreak|Num|NumAlpha|Punct|Space|Start|Symbol|Word|WordBreak)\b(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
            inside: {
                "standard-pattern-name": {
                    pattern: /^[a-zA-Z0-9\-.]+/,
                    alias: "builtin"
                },
                quantifier: {
                    pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
                    alias: "number"
                },
                "standard-pattern-attr": {
                    pattern: /[a-zA-Z0-9\-.]+/,
                    alias: "builtin"
                },
                punctuation: /[,()]/
            }
        },
        quantifier: {
            pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
            alias: "number"
        },
        operator: [
            {
                pattern: /=/,
                alias: "pattern-def"
            },
            {
                pattern: /&/,
                alias: "conjunction"
            },
            {
                pattern: /~/,
                alias: "exception"
            },
            {
                pattern: /\?/,
                alias: "optionality"
            },
            {
                pattern: /[[\]]/,
                alias: "repetition"
            },
            {
                pattern: /[{}]/,
                alias: "variation"
            },
            {
                pattern: /[+_]/,
                alias: "sequence"
            },
            {
                pattern: /\.{2,3}/,
                alias: "span"
            }
        ],
        "field-capture": [
            {
                pattern: /([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
                lookbehind: true,
                inside: {
                    "field-name": {
                        pattern: /[a-zA-Z0-9\-.]+/,
                        alias: "variable"
                    },
                    colon: /:/
                }
            },
            {
                pattern: /[a-zA-Z0-9\-.]+\s*:/,
                inside: {
                    "field-name": {
                        pattern: /[a-zA-Z0-9\-.]+/,
                        alias: "variable"
                    },
                    colon: /:/
                }
            }
        ],
        punctuation: /[:;,()]/,
        name: /[a-zA-Z0-9\-.]+/
    };
}

});

parcelRequire.register("6SbCL", function(module, exports) {
"use strict";
module.exports = $5010cd8bf72b09b8$var$nginx;
$5010cd8bf72b09b8$var$nginx.displayName = "nginx";
$5010cd8bf72b09b8$var$nginx.aliases = [];
function $5010cd8bf72b09b8$var$nginx(Prism1) {
    (function(Prism) {
        var variable = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
        Prism.languages.nginx = {
            comment: {
                pattern: /(^|[\s{};])#.*/,
                lookbehind: true,
                greedy: true
            },
            directive: {
                pattern: /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
                lookbehind: true,
                greedy: true,
                inside: {
                    string: {
                        pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
                        lookbehind: true,
                        greedy: true,
                        inside: {
                            escape: {
                                pattern: /\\["'\\nrt]/,
                                alias: "entity"
                            },
                            variable: variable
                        }
                    },
                    comment: {
                        pattern: /(\s)#.*/,
                        lookbehind: true,
                        greedy: true
                    },
                    keyword: {
                        pattern: /^\S+/,
                        greedy: true
                    },
                    // other patterns
                    boolean: {
                        pattern: /(\s)(?:off|on)(?!\S)/,
                        lookbehind: true
                    },
                    number: {
                        pattern: /(\s)\d+[a-z]*(?!\S)/i,
                        lookbehind: true
                    },
                    variable: variable
                }
            },
            punctuation: /[{};]/
        };
    })(Prism1);
}

});

parcelRequire.register("1eIXh", function(module, exports) {
"use strict";
module.exports = $0e69f862bdc16faf$var$nim;
$0e69f862bdc16faf$var$nim.displayName = "nim";
$0e69f862bdc16faf$var$nim.aliases = [];
function $0e69f862bdc16faf$var$nim(Prism) {
    Prism.languages.nim = {
        comment: {
            pattern: /#.*/,
            greedy: true
        },
        string: {
            // Double-quoted strings can be prefixed by an identifier (Generalized raw string literals)
            pattern: /(?:\b(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")/,
            greedy: true
        },
        char: {
            // Character literals are handled specifically to prevent issues with numeric type suffixes
            pattern: /'(?:\\(?:\d+|x[\da-fA-F]{0,2}|.)|[^'])'/,
            greedy: true
        },
        function: {
            pattern: /(?:(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
            greedy: true,
            inside: {
                operator: /\*$/
            }
        },
        // We don't want to highlight operators (and anything really) inside backticks
        identifier: {
            pattern: /`[^`\r\n]+`/,
            greedy: true,
            inside: {
                punctuation: /`/
            }
        },
        // The negative look ahead prevents wrong highlighting of the .. operator
        number: /\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
        keyword: /\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
        operator: {
            // Look behind and look ahead prevent wrong highlighting of punctuations [. .] {. .} (. .)
            // but allow the slice operator .. to take precedence over them
            // One can define his own operators in Nim so all combination of operators might be an operator.
            pattern: /(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\b)/m,
            lookbehind: true
        },
        punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
    };
}

});

parcelRequire.register("f0nKm", function(module, exports) {
"use strict";
module.exports = $aec946b18c318de4$var$nix;
$aec946b18c318de4$var$nix.displayName = "nix";
$aec946b18c318de4$var$nix.aliases = [];
function $aec946b18c318de4$var$nix(Prism) {
    Prism.languages.nix = {
        comment: {
            pattern: /\/\*[\s\S]*?\*\/|#.*/,
            greedy: true
        },
        string: {
            pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
            greedy: true,
            inside: {
                interpolation: {
                    // The lookbehind ensures the ${} is not preceded by \ or ''
                    pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
                    lookbehind: true,
                    inside: null // see below
                }
            }
        },
        url: [
            /\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/,
            {
                pattern: /([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
                lookbehind: true
            }
        ],
        antiquotation: {
            pattern: /\$(?=\{)/,
            alias: "important"
        },
        number: /\b\d+\b/,
        keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
        function: /\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:Tarball|url)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
        boolean: /\b(?:false|true)\b/,
        operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
        punctuation: /[{}()[\].,:;]/
    };
    Prism.languages.nix.string.inside.interpolation.inside = Prism.languages.nix;
}

});

parcelRequire.register("lN64z", function(module, exports) {
"use strict";
module.exports = $fdd2e282fd7f1aee$var$nsis;
$fdd2e282fd7f1aee$var$nsis.displayName = "nsis";
$fdd2e282fd7f1aee$var$nsis.aliases = [];
function $fdd2e282fd7f1aee$var$nsis(Prism) {
    /**
   * Original by Jan T. Sott (http://github.com/idleberg)
   *
   * Includes all commands and plug-ins shipped with NSIS 3.08
   */ Prism.languages.nsis = {
        comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|[#;].*)/,
            lookbehind: true,
            greedy: true
        },
        string: {
            pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        keyword: {
            pattern: /(^[\t ]*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|BG(?:Font|Gradient|Image)|Banner|BrandingText|BringToFront|CRCCheck|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|Seek|Write|WriteByte|WriteUTF16LE|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DLLVersion(?:Local)?|DlgItem|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|LabelAddress|TempFileName)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|Silent)|InitPluginsDir|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|Int(?:64|Ptr)?CmpU?|Int(?:64)?Fmt|Int(?:Ptr)?Op|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|NSISdl|Name|Nop|OutFile|PE(?:DllCharacteristics|SubsysVer)|Page(?:Callbacks)?|Pop|Push|Quit|RMDir|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|UnRegDLL|Unicode|UninstPage|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UserInfo|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|Var|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle|ns(?:Dialogs|Exec))\b/m,
            lookbehind: true
        },
        property: /\b(?:ARCHIVE|FILE_(?:ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(?:(?:CR|CU|LM)(?:32|64)?|DD|PD|U)|HKEY_(?:CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(?:ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(?:ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY|admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user)\b/,
        constant: /\$\{[!\w\.:\^-]+\}|\$\([!\w\.:\^-]+\)/,
        variable: /\$\w[\w\.]*/,
        number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
        operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
        punctuation: /[{}[\];(),.:]/,
        important: {
            pattern: /(^[\t ]*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversion|gettlbversion|if|ifdef|ifmacrodef|ifmacrondef|ifndef|include|insertmacro|macro|macroend|makensis|packhdr|pragma|searchparse|searchreplace|system|tempfile|undef|verbose|warning)\b/im,
            lookbehind: true
        }
    };
}

});

parcelRequire.register("k8Tvy", function(module, exports) {
"use strict";

var $bEqqd = parcelRequire("bEqqd");
module.exports = $ea9f9cbfbb308ae5$var$objectivec;
$ea9f9cbfbb308ae5$var$objectivec.displayName = "objectivec";
$ea9f9cbfbb308ae5$var$objectivec.aliases = [
    "objc"
];
function $ea9f9cbfbb308ae5$var$objectivec(Prism) {
    Prism.register($bEqqd);
    Prism.languages.objectivec = Prism.languages.extend("c", {
        string: {
            pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
            greedy: true
        },
        keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
        operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
    });
    delete Prism.languages.objectivec["class-name"];
    Prism.languages.objc = Prism.languages.objectivec;
}

});

parcelRequire.register("asjxC", function(module, exports) {
"use strict";
module.exports = $79cbad61ee5a6371$var$ocaml;
$79cbad61ee5a6371$var$ocaml.displayName = "ocaml";
$79cbad61ee5a6371$var$ocaml.aliases = [];
function $79cbad61ee5a6371$var$ocaml(Prism) {
    // https://ocaml.org/manual/lex.html
    Prism.languages.ocaml = {
        comment: {
            pattern: /\(\*[\s\S]*?\*\)/,
            greedy: true
        },
        char: {
            pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
            greedy: true
        },
        string: [
            {
                pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
                greedy: true
            },
            {
                pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
                greedy: true
            }
        ],
        number: [
            // binary and octal
            /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
            /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
            /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
        ],
        directive: {
            pattern: /\B#\w+/,
            alias: "property"
        },
        label: {
            pattern: /\B~\w+/,
            alias: "property"
        },
        "type-variable": {
            pattern: /\B'\w+/,
            alias: "function"
        },
        variant: {
            pattern: /`\w+/,
            alias: "symbol"
        },
        // For the list of keywords and operators,
        // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84
        keyword: /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
        boolean: /\b(?:false|true)\b/,
        "operator-like-punctuation": {
            pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
            alias: "punctuation"
        },
        // Custom operators are allowed
        operator: /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
        punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
    };
}

});

parcelRequire.register("iyxZt", function(module, exports) {
"use strict";

var $bEqqd = parcelRequire("bEqqd");
module.exports = $d825c4c1b21e0107$var$opencl;
$d825c4c1b21e0107$var$opencl.displayName = "opencl";
$d825c4c1b21e0107$var$opencl.aliases = [];
function $d825c4c1b21e0107$var$opencl(Prism1) {
    Prism1.register($bEqqd);
    (function(Prism) {
        /* OpenCL kernel language */ Prism.languages.opencl = Prism.languages.extend("c", {
            // Extracted from the official specs (2.0) and http://streamcomputing.eu/downloads/?opencl.lang (opencl-keywords, opencl-types) and http://sourceforge.net/tracker/?func=detail&aid=2957794&group_id=95717&atid=612384 (Words2, partly Words3)
            keyword: /\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
            // Extracted from http://streamcomputing.eu/downloads/?opencl.lang (opencl-const)
            // Math Constants: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/mathConstants.html
            // Macros and Limits: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/macroLimits.html
            number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
            boolean: /\b(?:false|true)\b/,
            "constant-opencl-kernel": {
                pattern: /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:2|10)E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
                alias: "constant"
            }
        });
        Prism.languages.insertBefore("opencl", "class-name", {
            // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/scalarDataTypes.html
            // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/otherDataTypes.html
            "builtin-type": {
                pattern: /\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|intptr_t|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|uintptr_t)\b/,
                alias: "keyword"
            }
        });
        var attributes = {
            // Extracted from http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-types and opencl-host)
            "type-opencl-host": {
                pattern: /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
                alias: "keyword"
            },
            "boolean-opencl-host": {
                pattern: /\bCL_(?:FALSE|TRUE)\b/,
                alias: "boolean"
            },
            // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-const)
            "constant-opencl-host": {
                pattern: /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
                alias: "constant"
            },
            // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-host)
            "function-opencl-host": {
                pattern: /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
                alias: "function"
            }
        };
        /* OpenCL host API */ Prism.languages.insertBefore("c", "keyword", attributes) // C++ includes everything from the OpenCL C host API plus the classes defined in cl2.h
        ;
        if (Prism.languages.cpp) {
            // Extracted from doxygen class list http://github.khronos.org/OpenCL-CLHPP/annotated.html
            attributes["type-opencl-host-cpp"] = {
                pattern: /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|Sampler|UserEvent)\b/,
                alias: "keyword"
            };
            Prism.languages.insertBefore("cpp", "keyword", attributes);
        }
    })(Prism1);
}

});

parcelRequire.register("g2ebv", function(module, exports) {
"use strict";
module.exports = $bac7d6066f4eabd0$var$openqasm;
$bac7d6066f4eabd0$var$openqasm.displayName = "openqasm";
$bac7d6066f4eabd0$var$openqasm.aliases = [
    "qasm"
];
function $bac7d6066f4eabd0$var$openqasm(Prism) {
    // https://qiskit.github.io/openqasm/grammar/index.html
    Prism.languages.openqasm = {
        comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
        string: {
            pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/,
            greedy: true
        },
        keyword: /\b(?:CX|OPENQASM|U|barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while)\b|#pragma\b/,
        "class-name": /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
        function: /\b(?:cos|exp|ln|popcount|rotl|rotr|sin|sqrt|tan)\b(?=\s*\()/,
        constant: /\b(?:euler|pi|tau)\b|π|𝜏|ℇ/,
        number: {
            pattern: /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|µs|ms|s)?/i,
            lookbehind: true
        },
        operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
        punctuation: /[(){}\[\];,:.]/
    };
    Prism.languages.qasm = Prism.languages.openqasm;
}

});

parcelRequire.register("eaPDu", function(module, exports) {
"use strict";
module.exports = $a51a0da94b59d58d$var$oz;
$a51a0da94b59d58d$var$oz.displayName = "oz";
$a51a0da94b59d58d$var$oz.aliases = [];
function $a51a0da94b59d58d$var$oz(Prism) {
    Prism.languages.oz = {
        comment: {
            pattern: /\/\*[\s\S]*?\*\/|%.*/,
            greedy: true
        },
        string: {
            pattern: /"(?:[^"\\]|\\[\s\S])*"/,
            greedy: true
        },
        atom: {
            pattern: /'(?:[^'\\]|\\[\s\S])*'/,
            greedy: true,
            alias: "builtin"
        },
        keyword: /\$|\[\]|\b(?:_|at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
        function: [
            /\b[a-z][A-Za-z\d]*(?=\()/,
            {
                pattern: /(\{)[A-Z][A-Za-z\d]*\b/,
                lookbehind: true
            }
        ],
        number: /\b(?:0[bx][\da-f]+|\d+(?:\.\d*)?(?:e~?\d+)?)\b|&(?:[^\\]|\\(?:\d{3}|.))/i,
        variable: /`(?:[^`\\]|\\.)+`/,
        "attr-name": /\b\w+(?=[ \t]*:(?![:=]))/,
        operator: /:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
        punctuation: /[\[\](){}.:;?]/
    };
}

});

parcelRequire.register("tsZWK", function(module, exports) {
"use strict";
module.exports = $058933f96b51157d$var$parigp;
$058933f96b51157d$var$parigp.displayName = "parigp";
$058933f96b51157d$var$parigp.aliases = [];
function $058933f96b51157d$var$parigp(Prism) {
    Prism.languages.parigp = {
        comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
        string: {
            pattern: /"(?:[^"\\\r\n]|\\.)*"/,
            greedy: true
        },
        // PARI/GP does not care about white spaces at all
        // so let's process the keywords to build an appropriate regexp
        // (e.g. "b *r *e *a *k", etc.)
        keyword: function() {
            var keywords = [
                "breakpoint",
                "break",
                "dbg_down",
                "dbg_err",
                "dbg_up",
                "dbg_x",
                "forcomposite",
                "fordiv",
                "forell",
                "forpart",
                "forprime",
                "forstep",
                "forsubgroup",
                "forvec",
                "for",
                "iferr",
                "if",
                "local",
                "my",
                "next",
                "return",
                "until",
                "while"
            ];
            keywords = keywords.map(function(keyword) {
                return keyword.split("").join(" *");
            }).join("|");
            return RegExp("\\b(?:" + keywords + ")\\b");
        }(),
        function: /\b\w(?:[\w ]*\w)?(?= *\()/,
        number: {
            // The lookbehind and the negative lookahead prevent from breaking the .. operator
            pattern: /((?:\. *\. *)?)(?:\b\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *(?:[+-] *)?\d(?: *\d)*)?/i,
            lookbehind: true
        },
        operator: /\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
        punctuation: /[\[\]{}().,:;|]/
    };
}

});

parcelRequire.register("9qa8H", function(module, exports) {
"use strict";
module.exports = $6dbe683a45cd998c$var$parser;
$6dbe683a45cd998c$var$parser.displayName = "parser";
$6dbe683a45cd998c$var$parser.aliases = [];
function $6dbe683a45cd998c$var$parser(Prism1) {
    (function(Prism) {
        var parser1 = Prism.languages.parser = Prism.languages.extend("markup", {
            keyword: {
                pattern: /(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
                lookbehind: true
            },
            variable: {
                pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
                lookbehind: true,
                inside: {
                    punctuation: /\.|:+/
                }
            },
            function: {
                pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
                lookbehind: true,
                inside: {
                    keyword: {
                        pattern: /(^@)(?:GET_|SET_)/,
                        lookbehind: true
                    },
                    punctuation: /\.|:+/
                }
            },
            escape: {
                pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
                alias: "builtin"
            },
            punctuation: /[\[\](){};]/
        });
        parser1 = Prism.languages.insertBefore("parser", "keyword", {
            "parser-comment": {
                pattern: /(\s)#.*/,
                lookbehind: true,
                alias: "comment"
            },
            expression: {
                // Allow for 3 levels of depth
                pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
                greedy: true,
                lookbehind: true,
                inside: {
                    string: {
                        pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
                        lookbehind: true
                    },
                    keyword: parser1.keyword,
                    variable: parser1.variable,
                    function: parser1.function,
                    boolean: /\b(?:false|true)\b/,
                    number: /\b(?:0x[a-f\d]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?)\b/i,
                    escape: parser1.escape,
                    operator: /[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
                    punctuation: parser1.punctuation
                }
            }
        });
        Prism.languages.insertBefore("inside", "punctuation", {
            expression: parser1.expression,
            keyword: parser1.keyword,
            variable: parser1.variable,
            function: parser1.function,
            escape: parser1.escape,
            "parser-punctuation": {
                pattern: parser1.punctuation,
                alias: "punctuation"
            }
        }, parser1["tag"].inside["attr-value"]);
    })(Prism1);
}

});

parcelRequire.register("dt7cG", function(module, exports) {
"use strict";
module.exports = $9ce392429b5c3280$var$pascal;
$9ce392429b5c3280$var$pascal.displayName = "pascal";
$9ce392429b5c3280$var$pascal.aliases = [
    "objectpascal"
];
function $9ce392429b5c3280$var$pascal(Prism) {
    // Based on Free Pascal
    /* TODO
Support inline asm ?
*/ Prism.languages.pascal = {
        directive: {
            pattern: /\{\$[\s\S]*?\}/,
            greedy: true,
            alias: [
                "marco",
                "property"
            ]
        },
        comment: {
            pattern: /\(\*[\s\S]*?\*\)|\{[\s\S]*?\}|\/\/.*/,
            greedy: true
        },
        string: {
            pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
            greedy: true
        },
        asm: {
            pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
            lookbehind: true,
            greedy: true,
            inside: null // see below
        },
        keyword: [
            {
                // Turbo Pascal
                pattern: /(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
                lookbehind: true
            },
            {
                // Free Pascal
                pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
                lookbehind: true
            },
            {
                // Object Pascal
                pattern: /(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
                lookbehind: true
            },
            {
                // Modifiers
                pattern: /(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
                lookbehind: true
            }
        ],
        number: [
            // Hexadecimal, octal and binary
            /(?:[&%]\d+|\$[a-f\d]+)/i,
            /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i
        ],
        operator: [
            /\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/,
            {
                pattern: /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
                lookbehind: true
            }
        ],
        punctuation: /\(\.|\.\)|[()\[\]:;,.]/
    };
    Prism.languages.pascal.asm.inside = Prism.languages.extend("pascal", {
        asm: undefined,
        keyword: undefined,
        operator: undefined
    });
    Prism.languages.objectpascal = Prism.languages.pascal;
}

});

parcelRequire.register("23vWE", function(module, exports) {
"use strict";
module.exports = $17f4a43073753189$var$pascaligo;
$17f4a43073753189$var$pascaligo.displayName = "pascaligo";
$17f4a43073753189$var$pascaligo.aliases = [];
function $17f4a43073753189$var$pascaligo(Prism1) {
    (function(Prism) {
        // Pascaligo is a layer 2 smart contract language for the tezos blockchain
        var braces = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source;
        var type = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(/<braces>/g, function() {
            return braces;
        });
        var pascaligo1 = Prism.languages.pascaligo = {
            comment: /\(\*[\s\S]+?\*\)|\/\/.*/,
            string: {
                pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1|\^[a-z]/i,
                greedy: true
            },
            "class-name": [
                {
                    pattern: RegExp(/(\btype\s+\w+\s+is\s+)<type>/.source.replace(/<type>/g, function() {
                        return type;
                    }), "i"),
                    lookbehind: true,
                    inside: null // see below
                },
                {
                    pattern: RegExp(/<type>(?=\s+is\b)/.source.replace(/<type>/g, function() {
                        return type;
                    }), "i"),
                    inside: null // see below
                },
                {
                    pattern: RegExp(/(:\s*)<type>/.source.replace(/<type>/g, function() {
                        return type;
                    })),
                    lookbehind: true,
                    inside: null // see below
                }
            ],
            keyword: {
                pattern: /(^|[^&])\b(?:begin|block|case|const|else|end|fail|for|from|function|if|is|nil|of|remove|return|skip|then|type|var|while|with)\b/i,
                lookbehind: true
            },
            boolean: {
                pattern: /(^|[^&])\b(?:False|True)\b/i,
                lookbehind: true
            },
            builtin: {
                pattern: /(^|[^&])\b(?:bool|int|list|map|nat|record|string|unit)\b/i,
                lookbehind: true
            },
            function: /\b\w+(?=\s*\()/,
            number: [
                // Hexadecimal, octal and binary
                /%[01]+|&[0-7]+|\$[a-f\d]+/i,
                /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?(?:mtz|n)?/i
            ],
            operator: /->|=\/=|\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=|]|\b(?:and|mod|or)\b/,
            punctuation: /\(\.|\.\)|[()\[\]:;,.{}]/
        };
        var classNameInside = [
            "comment",
            "keyword",
            "builtin",
            "operator",
            "punctuation"
        ].reduce(function(accum, key) {
            accum[key] = pascaligo1[key];
            return accum;
        }, {});
        pascaligo1["class-name"].forEach(function(p) {
            p.inside = classNameInside;
        });
    })(Prism1);
}

});

parcelRequire.register("fNIXI", function(module, exports) {
"use strict";
module.exports = $02f7f904c07b136a$var$pcaxis;
$02f7f904c07b136a$var$pcaxis.displayName = "pcaxis";
$02f7f904c07b136a$var$pcaxis.aliases = [
    "px"
];
function $02f7f904c07b136a$var$pcaxis(Prism) {
    Prism.languages.pcaxis = {
        string: /"[^"]*"/,
        keyword: {
            pattern: /((?:^|;)\s*)[-A-Z\d]+(?:\s*\[[-\w]+\])?(?:\s*\("[^"]*"(?:,\s*"[^"]*")*\))?(?=\s*=)/,
            lookbehind: true,
            greedy: true,
            inside: {
                keyword: /^[-A-Z\d]+/,
                language: {
                    pattern: /^(\s*)\[[-\w]+\]/,
                    lookbehind: true,
                    inside: {
                        punctuation: /^\[|\]$/,
                        property: /[-\w]+/
                    }
                },
                "sub-key": {
                    pattern: /^(\s*)\S[\s\S]*/,
                    lookbehind: true,
                    inside: {
                        parameter: {
                            pattern: /"[^"]*"/,
                            alias: "property"
                        },
                        punctuation: /^\(|\)$|,/
                    }
                }
            }
        },
        operator: /=/,
        tlist: {
            pattern: /TLIST\s*\(\s*\w+(?:(?:\s*,\s*"[^"]*")+|\s*,\s*"[^"]*"-"[^"]*")?\s*\)/,
            greedy: true,
            inside: {
                function: /^TLIST/,
                property: {
                    pattern: /^(\s*\(\s*)\w+/,
                    lookbehind: true
                },
                string: /"[^"]*"/,
                punctuation: /[(),]/,
                operator: /-/
            }
        },
        punctuation: /[;,]/,
        number: {
            pattern: /(^|\s)\d+(?:\.\d+)?(?!\S)/,
            lookbehind: true
        },
        boolean: /NO|YES/
    };
    Prism.languages.px = Prism.languages.pcaxis;
}

});

parcelRequire.register("fdICy", function(module, exports) {
"use strict";
module.exports = $b14aaeb24933e2b2$var$peoplecode;
$b14aaeb24933e2b2$var$peoplecode.displayName = "peoplecode";
$b14aaeb24933e2b2$var$peoplecode.aliases = [
    "pcode"
];
function $b14aaeb24933e2b2$var$peoplecode(Prism) {
    Prism.languages.peoplecode = {
        comment: RegExp([
            // C-style multiline comments
            /\/\*[\s\S]*?\*\//.source,
            /\bREM[^;]*;/.source,
            /<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source,
            /\/\+[\s\S]*?\+\//.source
        ].join("|")),
        string: {
            pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
            greedy: true
        },
        variable: /%\w+/,
        "function-definition": {
            pattern: /((?:^|[^\w-])(?:function|method)\s+)\w+/i,
            lookbehind: true,
            alias: "function"
        },
        "class-name": {
            pattern: /((?:^|[^-\w])(?:as|catch|class|component|create|extends|global|implements|instance|local|of|property|returns)\s+)\w+(?::\w+)*/i,
            lookbehind: true,
            inside: {
                punctuation: /:/
            }
        },
        keyword: /\b(?:abstract|alias|as|catch|class|component|constant|create|declare|else|end-(?:class|evaluate|for|function|get|if|method|set|try|while)|evaluate|extends|for|function|get|global|if|implements|import|instance|library|local|method|null|of|out|peopleCode|private|program|property|protected|readonly|ref|repeat|returns?|set|step|then|throw|to|try|until|value|when(?:-other)?|while)\b/i,
        "operator-keyword": {
            pattern: /\b(?:and|not|or)\b/i,
            alias: "operator"
        },
        function: /[_a-z]\w*(?=\s*\()/i,
        boolean: /\b(?:false|true)\b/i,
        number: /\b\d+(?:\.\d+)?\b/,
        operator: /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
        punctuation: /[:.;,()[\]]/
    };
    Prism.languages.pcode = Prism.languages.peoplecode;
}

});

parcelRequire.register("jJhZG", function(module, exports) {
"use strict";
module.exports = $e5d02d7c145ef8be$var$perl;
$e5d02d7c145ef8be$var$perl.displayName = "perl";
$e5d02d7c145ef8be$var$perl.aliases = [];
function $e5d02d7c145ef8be$var$perl(Prism1) {
    (function(Prism) {
        var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
        Prism.languages.perl = {
            comment: [
                {
                    // POD
                    pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
                    lookbehind: true,
                    greedy: true
                },
                {
                    pattern: /(^|[^\\$])#.*/,
                    lookbehind: true,
                    greedy: true
                }
            ],
            // TODO Could be nice to handle Heredoc too.
            string: [
                {
                    pattern: RegExp(/\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                        // q/.../
                        /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                        // eslint-disable-next-line regexp/strict
                        /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                        // q{...}
                        // q[...]
                        // q<...>
                        brackets
                    ].join("|") + ")"),
                    greedy: true
                },
                {
                    pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
                    greedy: true
                },
                // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
                {
                    pattern: /'(?:[^'\\\r\n]|\\.)*'/,
                    greedy: true
                }
            ],
            regex: [
                {
                    pattern: RegExp(/\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                        // m/.../
                        /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                        // eslint-disable-next-line regexp/strict
                        /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                        // m{...}
                        // m[...]
                        // m<...>
                        brackets
                    ].join("|") + ")" + /[msixpodualngc]*/.source),
                    greedy: true
                },
                {
                    pattern: RegExp(/(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                        // s/.../.../
                        // eslint-disable-next-line regexp/strict
                        /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                        // eslint-disable-next-line regexp/strict
                        /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
                        // s{...}{...}
                        // s[...][...]
                        // s<...><...>
                        // s(...)[...]
                        brackets + /\s*/.source + brackets
                    ].join("|") + ")" + /[msixpodualngcer]*/.source),
                    lookbehind: true,
                    greedy: true
                },
                // The look-ahead tries to prevent two divisions on
                // the same line from being highlighted as regex.
                // This does not support multi-line regex.
                {
                    pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
                    greedy: true
                }
            ],
            // FIXME Not sure about the handling of ::, ', and #
            variable: [
                // ${^POSTMATCH}
                /[&*$@%]\{\^[A-Z]+\}/,
                /[&*$@%]\^[A-Z_]/,
                /[&*$@%]#?(?=\{)/,
                /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
                /[&*$@%]\d+/,
                // The negative lookahead prevents from breaking the %= operator
                /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
            ],
            filehandle: {
                // <>, <FOO>, _
                pattern: /<(?![<=])\S*?>|\b_\b/,
                alias: "symbol"
            },
            "v-string": {
                // v1.2, 1.2.3
                pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
                alias: "string"
            },
            function: {
                pattern: /(\bsub[ \t]+)\w+/,
                lookbehind: true
            },
            keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
            number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
            operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
            punctuation: /[{}[\];(),:]/
        };
    })(Prism1);
}

});

parcelRequire.register("dRcHg", function(module, exports) {
"use strict";

var $dgm8B = parcelRequire("dgm8B");
module.exports = $a16a12e73439a609$var$phpExtras;
$a16a12e73439a609$var$phpExtras.displayName = "phpExtras";
$a16a12e73439a609$var$phpExtras.aliases = [];
function $a16a12e73439a609$var$phpExtras(Prism) {
    Prism.register($dgm8B);
    Prism.languages.insertBefore("php", "variable", {
        this: {
            pattern: /\$this\b/,
            alias: "keyword"
        },
        global: /\$(?:GLOBALS|HTTP_RAW_POST_DATA|_(?:COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)|argc|argv|http_response_header|php_errormsg)\b/,
        scope: {
            pattern: /\b[\w\\]+::/,
            inside: {
                keyword: /\b(?:parent|self|static)\b/,
                punctuation: /::|\\/
            }
        }
    });
}

});

parcelRequire.register("2houC", function(module, exports) {
"use strict";

var $dgm8B = parcelRequire("dgm8B");

var $krlJ1 = parcelRequire("krlJ1");
module.exports = $1a902b0c4e45b373$var$phpdoc;
$1a902b0c4e45b373$var$phpdoc.displayName = "phpdoc";
$1a902b0c4e45b373$var$phpdoc.aliases = [];
function $1a902b0c4e45b373$var$phpdoc(Prism1) {
    Prism1.register($dgm8B);
    Prism1.register($krlJ1);
    (function(Prism) {
        var typeExpression = /(?:\b[a-zA-Z]\w*|[|\\[\]])+/.source;
        Prism.languages.phpdoc = Prism.languages.extend("javadoclike", {
            parameter: {
                pattern: RegExp("(@(?:global|param|property(?:-read|-write)?|var)\\s+(?:" + typeExpression + "\\s+)?)\\$\\w+"),
                lookbehind: true
            }
        });
        Prism.languages.insertBefore("phpdoc", "keyword", {
            "class-name": [
                {
                    pattern: RegExp("(@(?:global|package|param|property(?:-read|-write)?|return|subpackage|throws|var)\\s+)" + typeExpression),
                    lookbehind: true,
                    inside: {
                        keyword: /\b(?:array|bool|boolean|callback|double|false|float|int|integer|mixed|null|object|resource|self|string|true|void)\b/,
                        punctuation: /[|\\[\]()]/
                    }
                }
            ]
        });
        Prism.languages.javadoclike.addSupport("php", Prism.languages.phpdoc);
    })(Prism1);
}

});

parcelRequire.register("6yqDR", function(module, exports) {
"use strict";

var $aeREZ = parcelRequire("aeREZ");
module.exports = $4c5a9597983ab6d6$var$plsql;
$4c5a9597983ab6d6$var$plsql.displayName = "plsql";
$4c5a9597983ab6d6$var$plsql.aliases = [];
function $4c5a9597983ab6d6$var$plsql(Prism) {
    Prism.register($aeREZ);
    Prism.languages.plsql = Prism.languages.extend("sql", {
        comment: {
            pattern: /\/\*[\s\S]*?\*\/|--.*/,
            greedy: true
        },
        // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-reserved-words-keywords.html
        keyword: /\b(?:A|ACCESSIBLE|ADD|AGENT|AGGREGATE|ALL|ALTER|AND|ANY|ARRAY|AS|ASC|AT|ATTRIBUTE|AUTHID|AVG|BEGIN|BETWEEN|BFILE_BASE|BINARY|BLOB_BASE|BLOCK|BODY|BOTH|BOUND|BULK|BY|BYTE|C|CALL|CALLING|CASCADE|CASE|CHAR|CHARACTER|CHARSET|CHARSETFORM|CHARSETID|CHAR_BASE|CHECK|CLOB_BASE|CLONE|CLOSE|CLUSTER|CLUSTERS|COLAUTH|COLLECT|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPILED|COMPRESS|CONNECT|CONSTANT|CONSTRUCTOR|CONTEXT|CONTINUE|CONVERT|COUNT|CRASH|CREATE|CREDENTIAL|CURRENT|CURSOR|CUSTOMDATUM|DANGLING|DATA|DATE|DATE_BASE|DAY|DECLARE|DEFAULT|DEFINE|DELETE|DESC|DETERMINISTIC|DIRECTORY|DISTINCT|DOUBLE|DROP|DURATION|ELEMENT|ELSE|ELSIF|EMPTY|END|ESCAPE|EXCEPT|EXCEPTION|EXCEPTIONS|EXCLUSIVE|EXECUTE|EXISTS|EXIT|EXTERNAL|FETCH|FINAL|FIRST|FIXED|FLOAT|FOR|FORALL|FORCE|FROM|FUNCTION|GENERAL|GOTO|GRANT|GROUP|HASH|HAVING|HEAP|HIDDEN|HOUR|IDENTIFIED|IF|IMMEDIATE|IMMUTABLE|IN|INCLUDING|INDEX|INDEXES|INDICATOR|INDICES|INFINITE|INSERT|INSTANTIABLE|INT|INTERFACE|INTERSECT|INTERVAL|INTO|INVALIDATE|IS|ISOLATION|JAVA|LANGUAGE|LARGE|LEADING|LENGTH|LEVEL|LIBRARY|LIKE|LIKE2|LIKE4|LIKEC|LIMIT|LIMITED|LOCAL|LOCK|LONG|LOOP|MAP|MAX|MAXLEN|MEMBER|MERGE|MIN|MINUS|MINUTE|MOD|MODE|MODIFY|MONTH|MULTISET|MUTABLE|NAME|NAN|NATIONAL|NATIVE|NCHAR|NEW|NOCOMPRESS|NOCOPY|NOT|NOWAIT|NULL|NUMBER_BASE|OBJECT|OCICOLL|OCIDATE|OCIDATETIME|OCIDURATION|OCIINTERVAL|OCILOBLOCATOR|OCINUMBER|OCIRAW|OCIREF|OCIREFCURSOR|OCIROWID|OCISTRING|OCITYPE|OF|OLD|ON|ONLY|OPAQUE|OPEN|OPERATOR|OPTION|OR|ORACLE|ORADATA|ORDER|ORGANIZATION|ORLANY|ORLVARY|OTHERS|OUT|OVERLAPS|OVERRIDING|PACKAGE|PARALLEL_ENABLE|PARAMETER|PARAMETERS|PARENT|PARTITION|PASCAL|PERSISTABLE|PIPE|PIPELINED|PLUGGABLE|POLYMORPHIC|PRAGMA|PRECISION|PRIOR|PRIVATE|PROCEDURE|PUBLIC|RAISE|RANGE|RAW|READ|RECORD|REF|REFERENCE|RELIES_ON|REM|REMAINDER|RENAME|RESOURCE|RESULT|RESULT_CACHE|RETURN|RETURNING|REVERSE|REVOKE|ROLLBACK|ROW|SAMPLE|SAVE|SAVEPOINT|SB1|SB2|SB4|SECOND|SEGMENT|SELECT|SELF|SEPARATE|SEQUENCE|SERIALIZABLE|SET|SHARE|SHORT|SIZE|SIZE_T|SOME|SPARSE|SQL|SQLCODE|SQLDATA|SQLNAME|SQLSTATE|STANDARD|START|STATIC|STDDEV|STORED|STRING|STRUCT|STYLE|SUBMULTISET|SUBPARTITION|SUBSTITUTABLE|SUBTYPE|SUM|SYNONYM|TABAUTH|TABLE|TDO|THE|THEN|TIME|TIMESTAMP|TIMEZONE_ABBR|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_REGION|TO|TRAILING|TRANSACTION|TRANSACTIONAL|TRUSTED|TYPE|UB1|UB2|UB4|UNDER|UNION|UNIQUE|UNPLUG|UNSIGNED|UNTRUSTED|UPDATE|USE|USING|VALIST|VALUE|VALUES|VARIABLE|VARIANCE|VARRAY|VARYING|VIEW|VIEWS|VOID|WHEN|WHERE|WHILE|WITH|WORK|WRAPPED|WRITE|YEAR|ZONE)\b/i,
        // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-language-fundamentals.html#GUID-96A42F7C-7A71-4B90-8255-CA9C8BD9722E
        operator: /:=?|=>|[<>^~!]=|\.\.|\|\||\*\*|[-+*/%<>=@]/
    });
    Prism.languages.insertBefore("plsql", "operator", {
        label: {
            pattern: /<<\s*\w+\s*>>/,
            alias: "symbol"
        }
    });
}

});

parcelRequire.register("i3e0j", function(module, exports) {
"use strict";
module.exports = $d2435ebacecf3724$var$powerquery;
$d2435ebacecf3724$var$powerquery.displayName = "powerquery";
$d2435ebacecf3724$var$powerquery.aliases = [];
function $d2435ebacecf3724$var$powerquery(Prism) {
    // https://docs.microsoft.com/en-us/powerquery-m/power-query-m-language-specification
    Prism.languages.powerquery = {
        comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
            lookbehind: true,
            greedy: true
        },
        "quoted-identifier": {
            pattern: /#"(?:[^"\r\n]|"")*"(?!")/,
            greedy: true
        },
        string: {
            pattern: /(?:#!)?"(?:[^"\r\n]|"")*"(?!")/,
            greedy: true
        },
        constant: [
            /\bDay\.(?:Friday|Monday|Saturday|Sunday|Thursday|Tuesday|Wednesday)\b/,
            /\bTraceLevel\.(?:Critical|Error|Information|Verbose|Warning)\b/,
            /\bOccurrence\.(?:All|First|Last)\b/,
            /\bOrder\.(?:Ascending|Descending)\b/,
            /\bRoundingMode\.(?:AwayFromZero|Down|ToEven|TowardZero|Up)\b/,
            /\bMissingField\.(?:Error|Ignore|UseNull)\b/,
            /\bQuoteStyle\.(?:Csv|None)\b/,
            /\bJoinKind\.(?:FullOuter|Inner|LeftAnti|LeftOuter|RightAnti|RightOuter)\b/,
            /\bGroupKind\.(?:Global|Local)\b/,
            /\bExtraValues\.(?:Error|Ignore|List)\b/,
            /\bJoinAlgorithm\.(?:Dynamic|LeftHash|LeftIndex|PairwiseHash|RightHash|RightIndex|SortMerge)\b/,
            /\bJoinSide\.(?:Left|Right)\b/,
            /\bPrecision\.(?:Decimal|Double)\b/,
            /\bRelativePosition\.From(?:End|Start)\b/,
            /\bTextEncoding\.(?:Ascii|BigEndianUnicode|Unicode|Utf16|Utf8|Windows)\b/,
            /\b(?:Any|Binary|Date|DateTime|DateTimeZone|Duration|Function|Int16|Int32|Int64|Int8|List|Logical|None|Number|Record|Table|Text|Time)\.Type\b/,
            /\bnull\b/
        ],
        boolean: /\b(?:false|true)\b/,
        keyword: /\b(?:and|as|each|else|error|if|in|is|let|meta|not|nullable|optional|or|otherwise|section|shared|then|try|type)\b|#(?:binary|date|datetime|datetimezone|duration|infinity|nan|sections|shared|table|time)\b/,
        function: {
            pattern: /(^|[^#\w.])[a-z_][\w.]*(?=\s*\()/i,
            lookbehind: true
        },
        "data-type": {
            pattern: /\b(?:any|anynonnull|binary|date|datetime|datetimezone|duration|function|list|logical|none|number|record|table|text|time)\b/,
            alias: "class-name"
        },
        number: {
            pattern: /\b0x[\da-f]+\b|(?:[+-]?(?:\b\d+\.)?\b\d+|[+-]\.\d+|(^|[^.])\B\.\d+)(?:e[+-]?\d+)?\b/i,
            lookbehind: true
        },
        operator: /[-+*\/&?@^]|<(?:=>?|>)?|>=?|=>?|\.\.\.?/,
        punctuation: /[,;\[\](){}]/
    };
    Prism.languages.pq = Prism.languages["powerquery"];
    Prism.languages.mscript = Prism.languages["powerquery"];
}

});

parcelRequire.register("gd1jl", function(module, exports) {
"use strict";
module.exports = $bccee0982ca30207$var$powershell;
$bccee0982ca30207$var$powershell.displayName = "powershell";
$bccee0982ca30207$var$powershell.aliases = [];
function $bccee0982ca30207$var$powershell(Prism1) {
    (function(Prism) {
        var powershell1 = Prism.languages.powershell = {
            comment: [
                {
                    pattern: /(^|[^`])<#[\s\S]*?#>/,
                    lookbehind: true
                },
                {
                    pattern: /(^|[^`])#.*/,
                    lookbehind: true
                }
            ],
            string: [
                {
                    pattern: /"(?:`[\s\S]|[^`"])*"/,
                    greedy: true,
                    inside: null // see below
                },
                {
                    pattern: /'(?:[^']|'')*'/,
                    greedy: true
                }
            ],
            // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
            // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
            namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
            boolean: /\$(?:false|true)\b/i,
            variable: /\$\w+\b/,
            // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
            // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
            // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
            function: [
                /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
                /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
            ],
            // per http://technet.microsoft.com/en-us/library/hh847744.aspx
            keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
            operator: {
                pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
                lookbehind: true
            },
            punctuation: /[|{}[\];(),.]/
        } // Variable interpolation inside strings, and nested expressions
        ;
        powershell1.string[0].inside = {
            function: {
                // Allow for one level of nesting
                pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
                lookbehind: true,
                inside: powershell1
            },
            boolean: powershell1.boolean,
            variable: powershell1.variable
        };
    })(Prism1);
}

});

parcelRequire.register("15Hsz", function(module, exports) {
"use strict";
module.exports = $0cb7f8493d7a91de$var$processing;
$0cb7f8493d7a91de$var$processing.displayName = "processing";
$0cb7f8493d7a91de$var$processing.aliases = [];
function $0cb7f8493d7a91de$var$processing(Prism) {
    Prism.languages.processing = Prism.languages.extend("clike", {
        keyword: /\b(?:break|case|catch|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
        // Spaces are allowed between function name and parenthesis
        function: /\b\w+(?=\s*\()/,
        operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
    });
    Prism.languages.insertBefore("processing", "number", {
        // Special case: XML is a type
        constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
        type: {
            pattern: /\b(?:boolean|byte|char|color|double|float|int|[A-Z]\w*)\b/,
            alias: "class-name"
        }
    });
}

});

parcelRequire.register("itl0F", function(module, exports) {
"use strict";
module.exports = $d72b3b8bbe3c3344$var$prolog;
$d72b3b8bbe3c3344$var$prolog.displayName = "prolog";
$d72b3b8bbe3c3344$var$prolog.aliases = [];
function $d72b3b8bbe3c3344$var$prolog(Prism) {
    Prism.languages.prolog = {
        // Syntax depends on the implementation
        comment: {
            pattern: /\/\*[\s\S]*?\*\/|%.*/,
            greedy: true
        },
        // Depending on the implementation, strings may allow escaped newlines and quote-escape
        string: {
            pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1(?!\1)/,
            greedy: true
        },
        builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
        // FIXME: Should we list all null-ary predicates (not followed by a parenthesis) like halt, trace, etc.?
        function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
        number: /\b\d+(?:\.\d*)?/,
        // Custom operators are allowed
        operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
        punctuation: /[(){}\[\],]/
    };
}

});

parcelRequire.register("1L4gm", function(module, exports) {
"use strict";
module.exports = $147d7cc347503528$var$promql;
$147d7cc347503528$var$promql.displayName = "promql";
$147d7cc347503528$var$promql.aliases = [];
function $147d7cc347503528$var$promql(Prism1) {
    (function(Prism) {
        // PromQL Aggregation Operators
        // (https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators)
        var aggregations = [
            "sum",
            "min",
            "max",
            "avg",
            "group",
            "stddev",
            "stdvar",
            "count",
            "count_values",
            "bottomk",
            "topk",
            "quantile"
        ] // PromQL vector matching + the by and without clauses
        ;
        // (https://prometheus.io/docs/prometheus/latest/querying/operators/#vector-matching)
        var vectorMatching = [
            "on",
            "ignoring",
            "group_right",
            "group_left",
            "by",
            "without"
        ] // PromQL offset modifier
        ;
        // (https://prometheus.io/docs/prometheus/latest/querying/basics/#offset-modifier)
        var offsetModifier = [
            "offset"
        ];
        var keywords = aggregations.concat(vectorMatching, offsetModifier);
        Prism.languages.promql = {
            comment: {
                pattern: /(^[ \t]*)#.*/m,
                lookbehind: true
            },
            "vector-match": {
                // Match the comma-separated label lists inside vector matching:
                pattern: new RegExp("((?:" + vectorMatching.join("|") + ")\\s*)\\([^)]*\\)"),
                lookbehind: true,
                inside: {
                    "label-key": {
                        pattern: /\b[^,]+\b/,
                        alias: "attr-name"
                    },
                    punctuation: /[(),]/
                }
            },
            "context-labels": {
                pattern: /\{[^{}]*\}/,
                inside: {
                    "label-key": {
                        pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
                        alias: "attr-name"
                    },
                    "label-value": {
                        pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
                        greedy: true,
                        alias: "attr-value"
                    },
                    punctuation: /\{|\}|=~?|![=~]|,/
                }
            },
            "context-range": [
                {
                    pattern: /\[[\w\s:]+\]/,
                    // [1m]
                    inside: {
                        punctuation: /\[|\]|:/,
                        "range-duration": {
                            pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
                            alias: "number"
                        }
                    }
                },
                {
                    pattern: /(\boffset\s+)\w+/,
                    // offset 1m
                    lookbehind: true,
                    inside: {
                        "range-duration": {
                            pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
                            alias: "number"
                        }
                    }
                }
            ],
            keyword: new RegExp("\\b(?:" + keywords.join("|") + ")\\b", "i"),
            function: /\b[a-z_]\w*(?=\s*\()/i,
            number: /[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
            operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|or|unless)\b/i,
            punctuation: /[{};()`,.[\]]/
        };
    })(Prism1);
}

});

parcelRequire.register("kdUpF", function(module, exports) {
"use strict";
module.exports = $eb90c7fb80e17ae9$var$properties;
$eb90c7fb80e17ae9$var$properties.displayName = "properties";
$eb90c7fb80e17ae9$var$properties.aliases = [];
function $eb90c7fb80e17ae9$var$properties(Prism) {
    Prism.languages.properties = {
        comment: /^[ \t]*[#!].*$/m,
        "attr-value": {
            pattern: /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
            lookbehind: true
        },
        "attr-name": /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
        punctuation: /[=:]/
    };
}

});

parcelRequire.register("60NY8", function(module, exports) {
"use strict";
module.exports = $460980f89908d898$var$protobuf;
$460980f89908d898$var$protobuf.displayName = "protobuf";
$460980f89908d898$var$protobuf.aliases = [];
function $460980f89908d898$var$protobuf(Prism1) {
    (function(Prism) {
        var builtinTypes = /\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
        Prism.languages.protobuf = Prism.languages.extend("clike", {
            "class-name": [
                {
                    pattern: /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
                    lookbehind: true
                },
                {
                    pattern: /(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
                    lookbehind: true
                }
            ],
            keyword: /\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
            function: /\b[a-z_]\w*(?=\s*\()/i
        });
        Prism.languages.insertBefore("protobuf", "operator", {
            map: {
                pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
                alias: "class-name",
                inside: {
                    punctuation: /[<>.,]/,
                    builtin: builtinTypes
                }
            },
            builtin: builtinTypes,
            "positional-class-name": {
                pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
                alias: "class-name",
                inside: {
                    punctuation: /\./
                }
            },
            annotation: {
                pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i,
                lookbehind: true
            }
        });
    })(Prism1);
}

});

parcelRequire.register("eqStk", function(module, exports) {
"use strict";
module.exports = $a81dbf69944c6fc7$var$psl;
$a81dbf69944c6fc7$var$psl.displayName = "psl";
$a81dbf69944c6fc7$var$psl.aliases = [];
function $a81dbf69944c6fc7$var$psl(Prism) {
    Prism.languages.psl = {
        comment: {
            pattern: /#.*/,
            greedy: true
        },
        string: {
            pattern: /"(?:\\.|[^\\"])*"/,
            greedy: true,
            inside: {
                symbol: /\\[ntrbA-Z"\\]/
            }
        },
        "heredoc-string": {
            pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
            alias: "string",
            greedy: true
        },
        keyword: /\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
        constant: /\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SEP_HORIZ|R_SEP_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|VOID|WARN)\b/,
        boolean: /\b(?:FALSE|False|NO|No|TRUE|True|YES|Yes|false|no|true|yes)\b/,
        variable: /\b(?:PslDebug|errno|exit_status)\b/,
        builtin: {
            pattern: /\b(?:PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|_snmp_debug|acos|add_diary|annotate|annotate_get|ascii_to_ebcdic|asctime|asin|atan|atexit|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|date|dcget_text|destroy|destroy_lock|dget_text|difference|dump_hist|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|file|floor|fmod|fopen|fseek|ftell|full_discovery|get|get_chan_info|get_ranges|get_text|get_vars|getenv|gethostinfo|getpid|getpname|grep|history|history_get_retention|in_transition|index|int|internal|intersection|is_var|isnumber|join|kill|length|lines|lock|lock_info|log|log10|loge|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|nthargf|nthline|nthlinef|num_bytes|num_consoles|pconfig|popen|poplines|pow|print|printf|proc_exists|process|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|snmp_agent_config|snmp_agent_start|snmp_agent_stop|snmp_close|snmp_config|snmp_get|snmp_get_next|snmp_h_get|snmp_h_get_next|snmp_h_set|snmp_open|snmp_set|snmp_trap_ignore|snmp_trap_listen|snmp_trap_raise_std_trap|snmp_trap_receive|snmp_trap_register_im|snmp_trap_send|snmp_walk|sopen|sort|splitline|sprintf|sqrt|srandom|str_repeat|strcasecmp|subset|substr|system|tail|tan|tanh|text_domain|time|tmpnam|tolower|toupper|trace_psl_process|trim|union|unique|unlock|unset|va_arg|va_start|write)\b/,
            alias: "builtin-function"
        },
        "foreach-variable": {
            pattern: /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
            lookbehind: true,
            greedy: true
        },
        function: /\b[_a-z]\w*\b(?=\s*\()/i,
        number: /\b(?:0x[0-9a-f]+|\d+(?:\.\d+)?)\b/i,
        operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
        punctuation: /[(){}\[\];,]/
    };
}

});

parcelRequire.register("eqlwD", function(module, exports) {
"use strict";
module.exports = $a80430e552e51424$var$pug;
$a80430e552e51424$var$pug.displayName = "pug";
$a80430e552e51424$var$pug.aliases = [];
function $a80430e552e51424$var$pug(Prism1) {
    (function(Prism) {
        // TODO:
        // - Add CSS highlighting inside <style> tags
        // - Add support for multi-line code blocks
        // - Add support for interpolation #{} and !{}
        // - Add support for tag interpolation #[]
        // - Add explicit support for plain text using |
        // - Add support for markup embedded in plain text
        Prism.languages.pug = {
            // Multiline stuff should appear before the rest
            // This handles both single-line and multi-line comments
            comment: {
                pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ].+)*/m,
                lookbehind: true
            },
            // All the tag-related part is in lookbehind
            // so that it can be highlighted by the "tag" pattern
            "multiline-script": {
                pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            // See at the end of the file for known filters
            filter: {
                pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
                lookbehind: true,
                inside: {
                    "filter-name": {
                        pattern: /^:[\w-]+/,
                        alias: "variable"
                    },
                    text: /\S[\s\S]*/
                }
            },
            "multiline-plain-text": {
                pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
                lookbehind: true
            },
            markup: {
                pattern: /(^[\t ]*)<.+/m,
                lookbehind: true,
                inside: Prism.languages.markup
            },
            doctype: {
                pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
                lookbehind: true
            },
            // This handle all conditional and loop keywords
            "flow-control": {
                pattern: /(^[\t ]*)(?:case|default|each|else|if|unless|when|while)\b(?: .+)?/m,
                lookbehind: true,
                inside: {
                    each: {
                        pattern: /^each .+? in\b/,
                        inside: {
                            keyword: /\b(?:each|in)\b/,
                            punctuation: /,/
                        }
                    },
                    branch: {
                        pattern: /^(?:case|default|else|if|unless|when|while)\b/,
                        alias: "keyword"
                    },
                    rest: Prism.languages.javascript
                }
            },
            keyword: {
                pattern: /(^[\t ]*)(?:append|block|extends|include|prepend)\b.+/m,
                lookbehind: true
            },
            mixin: [
                // Declaration
                {
                    pattern: /(^[\t ]*)mixin .+/m,
                    lookbehind: true,
                    inside: {
                        keyword: /^mixin/,
                        function: /\w+(?=\s*\(|\s*$)/,
                        punctuation: /[(),.]/
                    }
                },
                {
                    pattern: /(^[\t ]*)\+.+/m,
                    lookbehind: true,
                    inside: {
                        name: {
                            pattern: /^\+\w+/,
                            alias: "function"
                        },
                        rest: Prism.languages.javascript
                    }
                }
            ],
            script: {
                pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
                lookbehind: true,
                inside: Prism.languages.javascript
            },
            "plain-text": {
                pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]).+/m,
                lookbehind: true
            },
            tag: {
                pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
                lookbehind: true,
                inside: {
                    attributes: [
                        {
                            pattern: /&[^(]+\([^)]+\)/,
                            inside: Prism.languages.javascript
                        },
                        {
                            pattern: /\([^)]+\)/,
                            inside: {
                                "attr-value": {
                                    pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
                                    lookbehind: true,
                                    inside: Prism.languages.javascript
                                },
                                "attr-name": /[\w-]+(?=\s*!?=|\s*[,)])/,
                                punctuation: /[!=(),]+/
                            }
                        }
                    ],
                    punctuation: /:/,
                    "attr-id": /#[\w\-]+/,
                    "attr-class": /\.[\w\-]+/
                }
            },
            code: [
                {
                    pattern: /(^[\t ]*(?:-|!?=)).+/m,
                    lookbehind: true,
                    inside: Prism.languages.javascript
                }
            ],
            punctuation: /[.\-!=|]+/
        };
        var filter_pattern = /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source // Non exhaustive list of available filters and associated languages
        ;
        var filters = [
            {
                filter: "atpl",
                language: "twig"
            },
            {
                filter: "coffee",
                language: "coffeescript"
            },
            "ejs",
            "handlebars",
            "less",
            "livescript",
            "markdown",
            {
                filter: "sass",
                language: "scss"
            },
            "stylus"
        ];
        var all_filters = {};
        for(var i = 0, l = filters.length; i < l; i++){
            var filter = filters[i];
            filter = typeof filter === "string" ? {
                filter: filter,
                language: filter
            } : filter;
            if (Prism.languages[filter.language]) all_filters["filter-" + filter.filter] = {
                pattern: RegExp(filter_pattern.replace("<filter_name>", function() {
                    return filter.filter;
                }), "m"),
                lookbehind: true,
                inside: {
                    "filter-name": {
                        pattern: /^:[\w-]+/,
                        alias: "variable"
                    },
                    text: {
                        pattern: /\S[\s\S]*/,
                        alias: [
                            filter.language,
                            "language-" + filter.language
                        ],
                        inside: Prism.languages[filter.language]
                    }
                }
            };
        }
        Prism.languages.insertBefore("pug", "filter", all_filters);
    })(Prism1);
}

});

parcelRequire.register("2wbKO", function(module, exports) {
"use strict";
module.exports = $1d57b005e5bc3d29$var$puppet;
$1d57b005e5bc3d29$var$puppet.displayName = "puppet";
$1d57b005e5bc3d29$var$puppet.aliases = [];
function $1d57b005e5bc3d29$var$puppet(Prism1) {
    (function(Prism) {
        Prism.languages.puppet = {
            heredoc: [
                // Matches the content of a quoted heredoc string (subject to interpolation)
                {
                    pattern: /(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
                    lookbehind: true,
                    alias: "string",
                    inside: {
                        // Matches the end tag
                        punctuation: /(?=\S).*\S(?= *$)/ // See interpolation below
                    }
                },
                {
                    pattern: /(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
                    lookbehind: true,
                    greedy: true,
                    alias: "string",
                    inside: {
                        // Matches the end tag
                        punctuation: /(?=\S).*\S(?= *$)/
                    }
                },
                {
                    pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
                    alias: "string",
                    inside: {
                        punctuation: {
                            pattern: /(\().+?(?=\))/,
                            lookbehind: true
                        }
                    }
                }
            ],
            "multiline-comment": {
                pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
                lookbehind: true,
                greedy: true,
                alias: "comment"
            },
            regex: {
                // Must be prefixed with the keyword "node" or a non-word char
                pattern: /((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
                lookbehind: true,
                greedy: true,
                inside: {
                    // Extended regexes must have the x flag. They can contain single-line comments.
                    "extended-regex": {
                        pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
                        inside: {
                            comment: /#.*/
                        }
                    }
                }
            },
            comment: {
                pattern: /(^|[^\\])#.*/,
                lookbehind: true,
                greedy: true
            },
            string: {
                // Allow for one nested level of double quotes inside interpolation
                pattern: /(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|\$(?!\{)|(?!\1)[^\\$]|\\[\s\S])*\1/,
                greedy: true,
                inside: {
                    "double-quoted": {
                        pattern: /^"[\s\S]*"$/,
                        inside: {
                        }
                    }
                }
            },
            variable: {
                pattern: /\$(?:::)?\w+(?:::\w+)*/,
                inside: {
                    punctuation: /::/
                }
            },
            "attr-name": /(?:\b\w+|\*)(?=\s*=>)/,
            function: [
                {
                    pattern: /(\.)(?!\d)\w+/,
                    lookbehind: true
                },
                /\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/
            ],
            number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
            boolean: /\b(?:false|true)\b/,
            // Includes words reserved for future use
            keyword: /\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
            datatype: {
                pattern: /\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
                alias: "symbol"
            },
            operator: /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
            punctuation: /[\[\]{}().,;]|:+/
        };
        var interpolation = [
            {
                // Allow for one nested level of braces inside interpolation
                pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
                lookbehind: true,
                inside: {
                    "short-variable": {
                        // Negative look-ahead prevent wrong highlighting of functions
                        pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
                        lookbehind: true,
                        alias: "variable",
                        inside: {
                            punctuation: /::/
                        }
                    },
                    delimiter: {
                        pattern: /^\$/,
                        alias: "variable"
                    },
                    rest: Prism.languages.puppet
                }
            },
            {
                pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
                lookbehind: true,
                alias: "variable",
                inside: {
                    punctuation: /::/
                }
            }
        ];
        Prism.languages.puppet["heredoc"][0].inside.interpolation = interpolation;
        Prism.languages.puppet["string"].inside["double-quoted"].inside.interpolation = interpolation;
    })(Prism1);
}

});

parcelRequire.register("4mMja", function(module, exports) {
"use strict";
module.exports = $32deb07a841e8e47$var$pure;
$32deb07a841e8e47$var$pure.displayName = "pure";
$32deb07a841e8e47$var$pure.aliases = [];
function $32deb07a841e8e47$var$pure(Prism1) {
    (function(Prism) {
        // https://agraef.github.io/pure-docs/pure.html#lexical-matters
        Prism.languages.pure = {
            comment: [
                {
                    pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
                    lookbehind: true
                },
                {
                    pattern: /(^|[^\\:])\/\/.*/,
                    lookbehind: true
                },
                /#!.+/
            ],
            "inline-lang": {
                pattern: /%<[\s\S]+?%>/,
                greedy: true,
                inside: {
                    lang: {
                        pattern: /(^%< *)-\*-.+?-\*-/,
                        lookbehind: true,
                        alias: "comment"
                    },
                    delimiter: {
                        pattern: /^%<.*|%>$/,
                        alias: "punctuation"
                    }
                }
            },
            string: {
                pattern: /"(?:\\.|[^"\\\r\n])*"/,
                greedy: true
            },
            number: {
                // The look-behind prevents wrong highlighting of the .. operator
                pattern: /((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?L?)/i,
                lookbehind: true
            },
            keyword: /\b(?:NULL|ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
            function: /\b(?:abs|add_(?:addr|constdef|(?:fundef|interface|macdef|typedef)(?:_at)?|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_c?string(?:_pointer)?|byte_(?:matrix|pointer)|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|sentry|short|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
            special: {
                pattern: /\b__[a-z]+__\b/i,
                alias: "builtin"
            },
            // Any combination of operator chars can be an operator
            // eslint-disable-next-line no-misleading-character-class
            operator: /(?:[!"#$%&'*+,\-.\/:<=>?@\\^`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]|\b_+\b)+|\b(?:and|div|mod|not|or)\b/,
            // FIXME: How can we prevent | and , to be highlighted as operator when they are used alone?
            punctuation: /[(){}\[\];,|]/
        };
        var inlineLanguages = [
            "c",
            {
                lang: "c++",
                alias: "cpp"
            },
            "fortran"
        ];
        var inlineLanguageRe = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
        inlineLanguages.forEach(function(lang) {
            var alias = lang;
            if (typeof lang !== "string") {
                alias = lang.alias;
                lang = lang.lang;
            }
            if (Prism.languages[alias]) {
                var o = {};
                o["inline-lang-" + alias] = {
                    pattern: RegExp(inlineLanguageRe.replace("<lang>", lang.replace(/([.+*?\/\\(){}\[\]])/g, "\\$1")), "i"),
                    inside: Prism.util.clone(Prism.languages.pure["inline-lang"].inside)
                };
                o["inline-lang-" + alias].inside.rest = Prism.util.clone(Prism.languages[alias]);
                Prism.languages.insertBefore("pure", "inline-lang", o);
            }
        }) // C is the default inline language
        ;
        if (Prism.languages.c) Prism.languages.pure["inline-lang"].inside.rest = Prism.util.clone(Prism.languages.c);
    })(Prism1);
}

});

parcelRequire.register("dZvrI", function(module, exports) {
"use strict";
module.exports = $a2f95d5fb8481c24$var$purebasic;
$a2f95d5fb8481c24$var$purebasic.displayName = "purebasic";
$a2f95d5fb8481c24$var$purebasic.aliases = [];
function $a2f95d5fb8481c24$var$purebasic(Prism) {
    /*
Original Code by Bas Groothedde
!!MANY THANKS!! I never would have made this, regex and me will never be best friends ;)
==> https://codepen.io/ImagineProgramming/details/JYydBy/
slightly changed to pass all tests
*/ // PureBasic support, steal stuff from ansi-c
    Prism.languages.purebasic = Prism.languages.extend("clike", {
        comment: /;.*/,
        keyword: /\b(?:align|and|as|break|calldebugger|case|compilercase|compilerdefault|compilerelse|compilerelseif|compilerendif|compilerendselect|compilererror|compilerif|compilerselect|continue|data|datasection|debug|debuglevel|declare|declarec|declarecdll|declaredll|declaremodule|default|define|dim|disableasm|disabledebugger|disableexplicit|else|elseif|enableasm|enabledebugger|enableexplicit|end|enddatasection|enddeclaremodule|endenumeration|endif|endimport|endinterface|endmacro|endmodule|endprocedure|endselect|endstructure|endstructureunion|endwith|enumeration|extends|fakereturn|for|foreach|forever|global|gosub|goto|if|import|importc|includebinary|includefile|includepath|interface|macro|module|newlist|newmap|next|not|or|procedure|procedurec|procedurecdll|proceduredll|procedurereturn|protected|prototype|prototypec|read|redim|repeat|restore|return|runtime|select|shared|static|step|structure|structureunion|swap|threaded|to|until|wend|while|with|xincludefile|xor)\b/i,
        function: /\b\w+(?:\.\w+)?\s*(?=\()/,
        number: /(?:\$[\da-f]+|\b-?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\b/i,
        operator: /(?:@\*?|\?|\*)\w+|-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*/@]/
    });
    Prism.languages.insertBefore("purebasic", "keyword", {
        tag: /#\w+\$?/,
        asm: {
            pattern: /(^[\t ]*)!.*/m,
            lookbehind: true,
            alias: "tag",
            inside: {
                comment: /;.*/,
                string: {
                    pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
                    greedy: true
                },
                // Anonymous label references, i.e.: jmp @b
                "label-reference-anonymous": {
                    pattern: /(!\s*j[a-z]+\s+)@[fb]/i,
                    lookbehind: true,
                    alias: "fasm-label"
                },
                // Named label reference, i.e.: jne label1
                "label-reference-addressed": {
                    pattern: /(!\s*j[a-z]+\s+)[A-Z._?$@][\w.?$@~#]*/i,
                    lookbehind: true,
                    alias: "fasm-label"
                },
                keyword: [
                    /\b(?:extern|global)\b[^;\r\n]*/i,
                    /\b(?:CPU|DEFAULT|FLOAT)\b.*/
                ],
                function: {
                    pattern: /^([\t ]*!\s*)[\da-z]+(?=\s|$)/im,
                    lookbehind: true
                },
                "function-inline": {
                    pattern: /(:\s*)[\da-z]+(?=\s)/i,
                    lookbehind: true,
                    alias: "function"
                },
                label: {
                    pattern: /^([\t ]*!\s*)[A-Za-z._?$@][\w.?$@~#]*(?=:)/m,
                    lookbehind: true,
                    alias: "fasm-label"
                },
                register: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s|mm\d+)\b/i,
                number: /(?:\b|-|(?=\$))(?:0[hx](?:[\da-f]*\.)?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
                operator: /[\[\]*+\-/%<>=&|$!,.:]/
            }
        }
    });
    delete Prism.languages.purebasic["class-name"];
    delete Prism.languages.purebasic["boolean"];
    Prism.languages.pbfasm = Prism.languages["purebasic"];
}

});

parcelRequire.register("gjCLb", function(module, exports) {
"use strict";

var $2X73H = parcelRequire("2X73H");
module.exports = $be0c7ca29edcc68d$var$purescript;
$be0c7ca29edcc68d$var$purescript.displayName = "purescript";
$be0c7ca29edcc68d$var$purescript.aliases = [
    "purs"
];
function $be0c7ca29edcc68d$var$purescript(Prism) {
    Prism.register($2X73H);
    Prism.languages.purescript = Prism.languages.extend("haskell", {
        keyword: /\b(?:ado|case|class|data|derive|do|else|forall|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b|∀/,
        "import-statement": {
            // The imported or hidden names are not included in this import
            // statement. This is because we want to highlight those exactly like
            // we do for the names in the program.
            pattern: /(^[\t ]*)import\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*(?:\s+as\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
            lookbehind: true,
            inside: {
                keyword: /\b(?:as|hiding|import)\b/,
                punctuation: /\./
            }
        },
        // These are builtin functions only. Constructors are highlighted later as a constant.
        builtin: /\b(?:absurd|add|ap|append|apply|between|bind|bottom|clamp|compare|comparing|compose|conj|const|degree|discard|disj|div|eq|flap|flip|gcd|identity|ifM|join|lcm|liftA1|liftM1|map|max|mempty|min|mod|mul|negate|not|notEq|one|otherwise|recip|show|sub|top|unit|unless|unlessM|void|when|whenM|zero)\b/,
        operator: [
            // Infix operators
            Prism.languages.haskell.operator[0],
            Prism.languages.haskell.operator[2],
            // This regex is equivalent to /(?=[\x80-\uFFFF])[\p{gc=Math_Symbol}\p{gc=Currency_Symbol}\p{Modifier_Symbol}\p{Other_Symbol}]/u
            // See https://github.com/PrismJS/prism/issues/3006 for more details.
            /[\xa2-\xa6\xa8\xa9\xac\xae-\xb1\xb4\xb8\xd7\xf7\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384\u0385\u03f6\u0482\u058d-\u058f\u0606-\u0608\u060b\u060e\u060f\u06de\u06e9\u06fd\u06fe\u07f6\u07fe\u07ff\u09f2\u09f3\u09fa\u09fb\u0af1\u0b70\u0bf3-\u0bfa\u0c7f\u0d4f\u0d79\u0e3f\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u0fd5-\u0fd8\u109e\u109f\u1390-\u1399\u166d\u17db\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u2052\u207a-\u207c\u208a-\u208c\u20a0-\u20bf\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u2140-\u2144\u214a-\u214d\u214f\u218a\u218b\u2190-\u2307\u230c-\u2328\u232b-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2767\u2794-\u27c4\u27c7-\u27e5\u27f0-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2b73\u2b76-\u2b95\u2b97-\u2bff\u2ce5-\u2cea\u2e50\u2e51\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua700-\ua716\ua720\ua721\ua789\ua78a\ua828-\ua82b\ua836-\ua839\uaa77-\uaa79\uab5b\uab6a\uab6b\ufb29\ufbb2-\ufbc1\ufdfc\ufdfd\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]/
        ]
    });
    Prism.languages.purs = Prism.languages.purescript;
}

});

parcelRequire.register("gXzeq", function(module, exports) {
"use strict";
module.exports = $c58d7c50dc4e683d$var$python;
$c58d7c50dc4e683d$var$python.displayName = "python";
$c58d7c50dc4e683d$var$python.aliases = [
    "py"
];
function $c58d7c50dc4e683d$var$python(Prism) {
    Prism.languages.python = {
        comment: {
            pattern: /(^|[^\\])#.*/,
            lookbehind: true,
            greedy: true
        },
        "string-interpolation": {
            pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
            greedy: true,
            inside: {
                interpolation: {
                    // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
                    pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
                    lookbehind: true,
                    inside: {
                        "format-spec": {
                            pattern: /(:)[^:(){}]+(?=\}$)/,
                            lookbehind: true
                        },
                        "conversion-option": {
                            pattern: /![sra](?=[:}]$)/,
                            alias: "punctuation"
                        },
                        rest: null
                    }
                },
                string: /[\s\S]+/
            }
        },
        "triple-quoted-string": {
            pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
            greedy: true,
            alias: "string"
        },
        string: {
            pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
            greedy: true
        },
        function: {
            pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
            lookbehind: true
        },
        "class-name": {
            pattern: /(\bclass\s+)\w+/i,
            lookbehind: true
        },
        decorator: {
            pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
            lookbehind: true,
            alias: [
                "annotation",
                "punctuation"
            ],
            inside: {
                punctuation: /\./
            }
        },
        keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
        builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
        boolean: /\b(?:False|None|True)\b/,
        number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
        operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
        punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
    Prism.languages.py = Prism.languages.python;
}

});

parcelRequire.register("7tonk", function(module, exports) {
"use strict";
module.exports = $570e26468d812186$var$q;
$570e26468d812186$var$q.displayName = "q";
$570e26468d812186$var$q.aliases = [];
function $570e26468d812186$var$q(Prism) {
    Prism.languages.q = {
        string: /"(?:\\.|[^"\\\r\n])*"/,
        comment: [
            // From http://code.kx.com/wiki/Reference/Slash:
            // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
            {
                pattern: /([\t )\]}])\/.*/,
                lookbehind: true,
                greedy: true
            },
            // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
            // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
            // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
            // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
            {
                pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
                lookbehind: true,
                greedy: true
            },
            // A \ on a line by itself with no preceding matching / will comment to end of file.
            {
                pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
                greedy: true
            },
            {
                pattern: /^#!.+/m,
                greedy: true
            }
        ],
        symbol: /`(?::\S+|[\w.]*)/,
        datetime: {
            pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
            alias: "number"
        },
        // The negative look-ahead prevents bad highlighting
        // of verbs 0: and 1:
        number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
        keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
        adverb: {
            pattern: /['\/\\]:?|\beach\b/,
            alias: "function"
        },
        verb: {
            pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
            alias: "operator"
        },
        punctuation: /[(){}\[\];.]/
    };
}

});

parcelRequire.register("gEhMo", function(module, exports) {
"use strict";
module.exports = $c1ee2c685718d502$var$qml;
$c1ee2c685718d502$var$qml.displayName = "qml";
$c1ee2c685718d502$var$qml.aliases = [];
function $c1ee2c685718d502$var$qml(Prism1) {
    (function(Prism) {
        var jsString = /"(?:\\.|[^\\"\r\n])*"|'(?:\\.|[^\\'\r\n])*'/.source;
        var jsComment = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source;
        var jsExpr = /(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/.source.replace(/<string>/g, function() {
            return jsString;
        }).replace(/<comment>/g, function() {
            return jsComment;
        }) // the pattern will blow up, so only a few iterations
        ;
        for(var i = 0; i < 2; i++)jsExpr = jsExpr.replace(/<expr>/g, function() {
            return jsExpr;
        });
        jsExpr = jsExpr.replace(/<expr>/g, "[^\\s\\S]");
        Prism.languages.qml = {
            comment: {
                pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
                greedy: true
            },
            "javascript-function": {
                pattern: RegExp(/((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(/<js>/g, function() {
                    return jsExpr;
                }), "m"),
                lookbehind: true,
                greedy: true,
                alias: "language-javascript",
                inside: Prism.languages.javascript
            },
            "class-name": {
                pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
                lookbehind: true
            },
            property: [
                {
                    pattern: /((?:^|[;{])[ \t]*)(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
                    lookbehind: true
                },
                {
                    pattern: /((?:^|[;{])[ \t]*)property[ \t]+(?!\d)\w+(?:\.\w+)*[ \t]+(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
                    lookbehind: true,
                    inside: {
                        keyword: /^property/,
                        property: /\w+(?:\.\w+)*/
                    }
                }
            ],
            "javascript-expression": {
                pattern: RegExp(/(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(/<js>/g, function() {
                    return jsExpr;
                }), "m"),
                lookbehind: true,
                greedy: true,
                alias: "language-javascript",
                inside: Prism.languages.javascript
            },
            string: {
                pattern: /"(?:\\.|[^\\"\r\n])*"/,
                greedy: true
            },
            keyword: /\b(?:as|import|on)\b/,
            punctuation: /[{}[\]:;,]/
        };
    })(Prism1);
}

});

parcelRequire.register("jNUof", function(module, exports) {
"use strict";
module.exports = $e6ae55d7fa3afa80$var$qore;
$e6ae55d7fa3afa80$var$qore.displayName = "qore";
$e6ae55d7fa3afa80$var$qore.aliases = [];
function $e6ae55d7fa3afa80$var$qore(Prism) {
    Prism.languages.qore = Prism.languages.extend("clike", {
        comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
            lookbehind: true
        },
        // Overridden to allow unescaped multi-line strings
        string: {
            pattern: /("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
            greedy: true
        },
        keyword: /\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
        boolean: /\b(?:false|true)\b/i,
        function: /\$?\b(?!\d)\w+(?=\()/,
        number: /\b(?:0b[01]+|0x(?:[\da-f]*\.)?[\da-fp\-]+|(?:\d+(?:\.\d+)?|\.\d+)(?:e\d+)?[df]|(?:\d+(?:\.\d+)?|\.\d+))\b/i,
        operator: {
            pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
            lookbehind: true
        },
        variable: /\$(?!\d)\w+\b/
    });
}

});

parcelRequire.register("01CQo", function(module, exports) {
"use strict";
module.exports = $004e39b68ced23dc$var$qsharp;
$004e39b68ced23dc$var$qsharp.displayName = "qsharp";
$004e39b68ced23dc$var$qsharp.aliases = [
    "qs"
];
function $004e39b68ced23dc$var$qsharp(Prism1) {
    (function(Prism) {
        /**
     * Replaces all placeholders "<<n>>" of given pattern with the n-th replacement (zero based).
     *
     * Note: This is a simple text based replacement. Be careful when using backreferences!
     *
     * @param {string} pattern the given pattern.
     * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.
     * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.
     * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source
     */ function replace(pattern, replacements) {
            return pattern.replace(/<<(\d+)>>/g, function(m, index) {
                return "(?:" + replacements[+index] + ")";
            });
        }
        /**
     * @param {string} pattern
     * @param {string[]} replacements
     * @param {string} [flags]
     * @returns {RegExp}
     */ function re(pattern, replacements, flags) {
            return RegExp(replace(pattern, replacements), flags || "");
        }
        /**
     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.
     *
     * @param {string} pattern
     * @param {number} depthLog2
     * @returns {string}
     */ function nested(pattern, depthLog2) {
            for(var i = 0; i < depthLog2; i++)pattern = pattern.replace(/<<self>>/g, function() {
                return "(?:" + pattern + ")";
            });
            return pattern.replace(/<<self>>/g, "[^\\s\\S]");
        } // https://docs.microsoft.com/en-us/azure/quantum/user-guide/language/typesystem/
        // https://github.com/microsoft/qsharp-language/tree/main/Specifications/Language/5_Grammar
        var keywordKinds = {
            // keywords which represent a return or variable type
            type: "Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero",
            // all other keywords
            other: "Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within"
        } // keywords
        ;
        function keywordsToPattern(words) {
            return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
        }
        var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.other)) // types
        ;
        var identifier = /\b[A-Za-z_]\w*\b/.source;
        var qualifiedName = replace(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [
            identifier
        ]);
        var typeInside = {
            keyword: keywords,
            punctuation: /[<>()?,.:[\]]/
        } // strings
        ;
        var regularString = /"(?:\\.|[^\\"])*"/.source;
        Prism.languages.qsharp = Prism.languages.extend("clike", {
            comment: /\/\/.*/,
            string: [
                {
                    pattern: re(/(^|[^$\\])<<0>>/.source, [
                        regularString
                    ]),
                    lookbehind: true,
                    greedy: true
                }
            ],
            "class-name": [
                {
                    // open Microsoft.Quantum.Canon;
                    // open Microsoft.Quantum.Canon as CN;
                    pattern: re(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [
                        qualifiedName
                    ]),
                    lookbehind: true,
                    inside: typeInside
                },
                {
                    // namespace Quantum.App1;
                    pattern: re(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [
                        qualifiedName
                    ]),
                    lookbehind: true,
                    inside: typeInside
                }
            ],
            keyword: keywords,
            number: /(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
            operator: /\band=|\bor=|\band\b|\bnot\b|\bor\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
            punctuation: /::|[{}[\];(),.:]/
        });
        Prism.languages.insertBefore("qsharp", "number", {
            range: {
                pattern: /\.\./,
                alias: "operator"
            }
        }) // single line
        ;
        var interpolationExpr = nested(replace(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [
            regularString
        ]), 2);
        Prism.languages.insertBefore("qsharp", "string", {
            "interpolation-string": {
                pattern: re(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [
                    interpolationExpr
                ]),
                greedy: true,
                inside: {
                    interpolation: {
                        pattern: re(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [
                            interpolationExpr
                        ]),
                        lookbehind: true,
                        inside: {
                            punctuation: /^\{|\}$/,
                            expression: {
                                pattern: /[\s\S]+/,
                                alias: "language-qsharp",
                                inside: Prism.languages.qsharp
                            }
                        }
                    },
                    string: /[\s\S]+/
                }
            }
        });
    })(Prism1);
    Prism1.languages.qs = Prism1.languages.qsharp;
}

});

parcelRequire.register("6FtrL", function(module, exports) {
"use strict";
module.exports = $4dad69ea8aafc227$var$r;
$4dad69ea8aafc227$var$r.displayName = "r";
$4dad69ea8aafc227$var$r.aliases = [];
function $4dad69ea8aafc227$var$r(Prism) {
    Prism.languages.r = {
        comment: /#.*/,
        string: {
            pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        "percent-operator": {
            // Includes user-defined operators
            // and %%, %*%, %/%, %in%, %o%, %x%
            pattern: /%[^%\s]*%/,
            alias: "operator"
        },
        boolean: /\b(?:FALSE|TRUE)\b/,
        ellipsis: /\.\.(?:\.|\d+)/,
        number: [
            /\b(?:Inf|NaN)\b/,
            /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
        ],
        keyword: /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
        operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
        punctuation: /[(){}\[\],;]/
    };
}

});

parcelRequire.register("35zeA", function(module, exports) {
"use strict";

var $7AD6t = parcelRequire("7AD6t");
module.exports = $23fd2b7e686f7c11$var$racket;
$23fd2b7e686f7c11$var$racket.displayName = "racket";
$23fd2b7e686f7c11$var$racket.aliases = [
    "rkt"
];
function $23fd2b7e686f7c11$var$racket(Prism) {
    Prism.register($7AD6t);
    Prism.languages.racket = Prism.languages.extend("scheme", {
        "lambda-parameter": {
            // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.
            // this will just prevent false positives of the `function` pattern
            pattern: /([(\[]lambda\s+[(\[])[^()\[\]'\s]+/,
            lookbehind: true
        }
    });
    Prism.languages.insertBefore("racket", "string", {
        lang: {
            pattern: /^#lang.+/m,
            greedy: true,
            alias: "keyword"
        }
    });
    Prism.languages.rkt = Prism.languages.racket;
}

});

parcelRequire.register("28LIl", function(module, exports) {
"use strict";
module.exports = $18f15729acab12a4$var$reason;
$18f15729acab12a4$var$reason.displayName = "reason";
$18f15729acab12a4$var$reason.aliases = [];
function $18f15729acab12a4$var$reason(Prism) {
    Prism.languages.reason = Prism.languages.extend("clike", {
        string: {
            pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
            greedy: true
        },
        // 'class-name' must be matched *after* 'constructor' defined below
        "class-name": /\b[A-Z]\w*/,
        keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
        operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
    });
    Prism.languages.insertBefore("reason", "class-name", {
        char: {
            pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
            greedy: true
        },
        // Negative look-ahead prevents from matching things like String.capitalize
        constructor: /\b[A-Z]\w*\b(?!\s*\.)/,
        label: {
            pattern: /\b[a-z]\w*(?=::)/,
            alias: "symbol"
        }
    }) // We can't match functions property, so let's not even try.
    ;
    delete Prism.languages.reason.function;
}

});

parcelRequire.register("5FbEK", function(module, exports) {
"use strict";
module.exports = $41f9d2c421392351$var$regex;
$41f9d2c421392351$var$regex.displayName = "regex";
$41f9d2c421392351$var$regex.aliases = [];
function $41f9d2c421392351$var$regex(Prism1) {
    (function(Prism) {
        var specialEscape = {
            pattern: /\\[\\(){}[\]^$+*?|.]/,
            alias: "escape"
        };
        var escape = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
        var charSet = {
            pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
            alias: "class-name"
        };
        var charSetWithoutDot = {
            pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
            alias: "class-name"
        };
        var rangeChar = "(?:[^\\\\-]|" + escape.source + ")";
        var range = RegExp(rangeChar + "-" + rangeChar) // the name of a capturing group
        ;
        var groupName = {
            pattern: /(<|')[^<>']+(?=[>']$)/,
            lookbehind: true,
            alias: "variable"
        };
        Prism.languages.regex = {
            "char-class": {
                pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
                lookbehind: true,
                inside: {
                    "char-class-negation": {
                        pattern: /(^\[)\^/,
                        lookbehind: true,
                        alias: "operator"
                    },
                    "char-class-punctuation": {
                        pattern: /^\[|\]$/,
                        alias: "punctuation"
                    },
                    range: {
                        pattern: range,
                        inside: {
                            escape: escape,
                            "range-punctuation": {
                                pattern: /-/,
                                alias: "operator"
                            }
                        }
                    },
                    "special-escape": specialEscape,
                    "char-set": charSetWithoutDot,
                    escape: escape
                }
            },
            "special-escape": specialEscape,
            "char-set": charSet,
            backreference: [
                {
                    // a backreference which is not an octal escape
                    pattern: /\\(?![123][0-7]{2})[1-9]/,
                    alias: "keyword"
                },
                {
                    pattern: /\\k<[^<>']+>/,
                    alias: "keyword",
                    inside: {
                        "group-name": groupName
                    }
                }
            ],
            anchor: {
                pattern: /[$^]|\\[ABbGZz]/,
                alias: "function"
            },
            escape: escape,
            group: [
                {
                    // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
                    // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
                    // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
                    pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
                    alias: "punctuation",
                    inside: {
                        "group-name": groupName
                    }
                },
                {
                    pattern: /\)/,
                    alias: "punctuation"
                }
            ],
            quantifier: {
                pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
                alias: "number"
            },
            alternation: {
                pattern: /\|/,
                alias: "keyword"
            }
        };
    })(Prism1);
}

});

parcelRequire.register("gCBjT", function(module, exports) {
"use strict";
module.exports = $c19d24e9a85eab79$var$rego;
$c19d24e9a85eab79$var$rego.displayName = "rego";
$c19d24e9a85eab79$var$rego.aliases = [];
function $c19d24e9a85eab79$var$rego(Prism) {
    // https://www.openpolicyagent.org/docs/latest/policy-reference/
    Prism.languages.rego = {
        comment: /#.*/,
        property: {
            pattern: /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
            lookbehind: true,
            greedy: true
        },
        string: {
            pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
            lookbehind: true,
            greedy: true
        },
        keyword: /\b(?:as|default|else|import|not|null|package|set(?=\s*\()|some|with)\b/,
        boolean: /\b(?:false|true)\b/,
        function: {
            pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
            inside: {
                namespace: /\b\w+\b(?=\s*\.)/,
                punctuation: /\./
            }
        },
        number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
        punctuation: /[,;.\[\]{}()]/
    };
}

});

parcelRequire.register("dmaYA", function(module, exports) {
"use strict";
module.exports = $9b95d81217c06361$var$renpy;
$9b95d81217c06361$var$renpy.displayName = "renpy";
$9b95d81217c06361$var$renpy.aliases = [
    "rpy"
];
function $9b95d81217c06361$var$renpy(Prism) {
    Prism.languages.renpy = {
        comment: {
            pattern: /(^|[^\\])#.+/,
            lookbehind: true
        },
        string: {
            pattern: /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\])*\2|(?:^#?(?:(?:[0-9a-fA-F]){3}|[0-9a-fA-F]{6})$)/m,
            greedy: true
        },
        function: /\b[a-z_]\w*(?=\()/i,
        property: /\b(?:Update|UpdateVersion|action|activate_sound|adv_nvl_transition|after_load_transition|align|alpha|alt|anchor|antialias|area|auto|background|bar_invert|bar_resizing|bar_vertical|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_reverse|box_wrap|can_update|caret|child|color|crop|default_afm_enable|default_afm_time|default_fullscreen|default_text_cps|developer|directory_name|drag_handle|drag_joined|drag_name|drag_raise|draggable|dragged|drop_shadow|drop_shadow_color|droppable|dropped|easein|easeout|edgescroll|end_game_transition|end_splash_transition|enter_replay_transition|enter_sound|enter_transition|enter_yesno_transition|executable_name|exit_replay_transition|exit_sound|exit_transition|exit_yesno_transition|fadein|fadeout|first_indent|first_spacing|fit_first|focus|focus_mask|font|foreground|game_main_transition|get_installed_packages|google_play_key|google_play_salt|ground|has_music|has_sound|has_voice|height|help|hinting|hover|hover_background|hover_color|hover_sound|hovered|hyperlink_functions|idle|idle_color|image_style|include_update|insensitive|insensitive_background|insensitive_color|inside|intra_transition|italic|justify|kerning|keyboard_focus|language|layer_clipping|layers|layout|left_bar|left_gutter|left_margin|left_padding|length|line_leading|line_overlap_split|line_spacing|linear|main_game_transition|main_menu_music|maximum|min_width|minimum|minwidth|modal|mouse|mousewheel|name|narrator_menu|newline_indent|nvl_adv_transition|offset|order_reverse|outlines|overlay_functions|pos|position|prefix|radius|range|rest_indent|right_bar|right_gutter|right_margin|right_padding|rotate|rotate_pad|ruby_style|sample_sound|save_directory|say_attribute_transition|screen_height|screen_width|scrollbars|selected_hover|selected_hover_color|selected_idle|selected_idle_color|selected_insensitive|show_side_image|show_two_window|side_spacing|side_xpos|side_ypos|size|size_group|slow_cps|slow_cps_multiplier|spacing|strikethrough|subpixel|text_align|text_style|text_xpos|text_y_fudge|text_ypos|thumb|thumb_offset|thumb_shadow|thumbnail_height|thumbnail_width|time|top_bar|top_gutter|top_margin|top_padding|translations|underline|unscrollable|update|value|version|version_name|version_tuple|vertical|width|window_hide_transition|window_icon|window_left_padding|window_show_transition|window_title|windows_icon|xadjustment|xalign|xanchor|xanchoraround|xaround|xcenter|xfill|xinitial|xmargin|xmaximum|xminimum|xoffset|xofsset|xpadding|xpos|xsize|xzoom|yadjustment|yalign|yanchor|yanchoraround|yaround|ycenter|yfill|yinitial|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|ysizexysize|yzoom|zoom|zorder)\b/,
        tag: /\b(?:bar|block|button|buttoscreenn|drag|draggroup|fixed|frame|grid|[hv]box|hotbar|hotspot|image|imagebutton|imagemap|input|key|label|menu|mm_menu_frame|mousearea|nvl|parallel|screen|self|side|tag|text|textbutton|timer|vbar|viewport|window)\b|\$/,
        keyword: /\b(?:None|add|adjustment|alignaround|allow|angle|animation|around|as|assert|behind|box_layout|break|build|cache|call|center|changed|child_size|choice|circles|class|clear|clicked|clipping|clockwise|config|contains|continue|corner1|corner2|counterclockwise|def|default|define|del|delay|disabled|disabled_text|dissolve|elif|else|event|except|exclude|exec|expression|fade|finally|for|from|function|global|gm_root|has|hide|id|if|import|in|init|is|jump|knot|lambda|left|less_rounded|mm_root|movie|music|null|on|onlayer|pass|pause|persistent|play|print|python|queue|raise|random|renpy|repeat|return|right|rounded_window|scene|scope|set|show|slow|slow_abortable|slow_done|sound|stop|store|style|style_group|substitute|suffix|theme|transform|transform_anchor|transpose|try|ui|unhovered|updater|use|voice|while|widget|widget_hover|widget_selected|widget_text|yield)\b/,
        boolean: /\b(?:[Ff]alse|[Tt]rue)\b/,
        number: /(?:\b(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?)|\B\.\d+)(?:e[+-]?\d+)?j?/i,
        operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:and|at|not|or|with)\b/,
        punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.rpy = Prism.languages.renpy;
}

});

parcelRequire.register("hIJZK", function(module, exports) {
"use strict";
module.exports = $ce6a3962cdbe0d1c$var$rest;
$ce6a3962cdbe0d1c$var$rest.displayName = "rest";
$ce6a3962cdbe0d1c$var$rest.aliases = [];
function $ce6a3962cdbe0d1c$var$rest(Prism) {
    Prism.languages.rest = {
        table: [
            {
                pattern: /(^[\t ]*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1[+|].+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/m,
                lookbehind: true,
                inside: {
                    punctuation: /\||(?:\+[=-]+)+\+/
                }
            },
            {
                pattern: /(^[\t ]*)=+ [ =]*=(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1=+ [ =]*=(?=(?:\r?\n|\r){2}|\s*$)/m,
                lookbehind: true,
                inside: {
                    punctuation: /[=-]+/
                }
            }
        ],
        // Directive-like patterns
        "substitution-def": {
            pattern: /(^[\t ]*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
            lookbehind: true,
            inside: {
                substitution: {
                    pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
                    alias: "attr-value",
                    inside: {
                        punctuation: /^\||\|$/
                    }
                },
                directive: {
                    pattern: /( )(?! )[^:]+::/,
                    lookbehind: true,
                    alias: "function",
                    inside: {
                        punctuation: /::$/
                    }
                }
            }
        },
        "link-target": [
            {
                pattern: /(^[\t ]*\.\. )\[[^\]]+\]/m,
                lookbehind: true,
                alias: "string",
                inside: {
                    punctuation: /^\[|\]$/
                }
            },
            {
                pattern: /(^[\t ]*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
                lookbehind: true,
                alias: "string",
                inside: {
                    punctuation: /^_|:$/
                }
            }
        ],
        directive: {
            pattern: /(^[\t ]*\.\. )[^:]+::/m,
            lookbehind: true,
            alias: "function",
            inside: {
                punctuation: /::$/
            }
        },
        comment: {
            // The two alternatives try to prevent highlighting of blank comments
            pattern: /(^[\t ]*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
            lookbehind: true
        },
        title: [
            // Overlined and underlined
            {
                pattern: /^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
                inside: {
                    punctuation: /^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
                    important: /.+/
                }
            },
            {
                pattern: /(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
                lookbehind: true,
                inside: {
                    punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
                    important: /.+/
                }
            }
        ],
        hr: {
            pattern: /((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
            lookbehind: true,
            alias: "punctuation"
        },
        field: {
            pattern: /(^[\t ]*):[^:\r\n]+:(?= )/m,
            lookbehind: true,
            alias: "attr-name"
        },
        "command-line-option": {
            pattern: /(^[\t ]*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
            lookbehind: true,
            alias: "symbol"
        },
        "literal-block": {
            pattern: /::(?:\r?\n|\r){2}([ \t]+)(?![ \t]).+(?:(?:\r?\n|\r)\1.+)*/,
            inside: {
                "literal-block-punctuation": {
                    pattern: /^::/,
                    alias: "punctuation"
                }
            }
        },
        "quoted-literal-block": {
            pattern: /::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
            inside: {
                "literal-block-punctuation": {
                    pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
                    alias: "punctuation"
                }
            }
        },
        "list-bullet": {
            pattern: /(^[\t ]*)(?:[*+\-•‣⁃]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
            lookbehind: true,
            alias: "punctuation"
        },
        "doctest-block": {
            pattern: /(^[\t ]*)>>> .+(?:(?:\r?\n|\r).+)*/m,
            lookbehind: true,
            inside: {
                punctuation: /^>>>/
            }
        },
        inline: [
            {
                pattern: /(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s)(?:(?!\2).)*\S\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
                lookbehind: true,
                inside: {
                    bold: {
                        pattern: /(^\*\*).+(?=\*\*$)/,
                        lookbehind: true
                    },
                    italic: {
                        pattern: /(^\*).+(?=\*$)/,
                        lookbehind: true
                    },
                    "inline-literal": {
                        pattern: /(^``).+(?=``$)/,
                        lookbehind: true,
                        alias: "symbol"
                    },
                    role: {
                        pattern: /^:[^:]+:|:[^:]+:$/,
                        alias: "function",
                        inside: {
                            punctuation: /^:|:$/
                        }
                    },
                    "interpreted-text": {
                        pattern: /(^`).+(?=`$)/,
                        lookbehind: true,
                        alias: "attr-value"
                    },
                    substitution: {
                        pattern: /(^\|).+(?=\|$)/,
                        lookbehind: true,
                        alias: "attr-value"
                    },
                    punctuation: /\*\*?|``?|\|/
                }
            }
        ],
        link: [
            {
                pattern: /\[[^\[\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
                alias: "string",
                inside: {
                    punctuation: /^\[|\]_$/
                }
            },
            {
                pattern: /(?:\b[a-z\d]+(?:[_.:+][a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
                alias: "string",
                inside: {
                    punctuation: /^_?`|`$|`?_?_$/
                }
            }
        ],
        // Line block start,
        // quote attribution,
        // explicit markup start,
        // and anonymous hyperlink target shortcut (__)
        punctuation: {
            pattern: /(^[\t ]*)(?:\|(?= |$)|(?:---?|—|\.\.|__)(?= )|\.\.$)/m,
            lookbehind: true
        }
    };
}

});

parcelRequire.register("c6Moq", function(module, exports) {
"use strict";
module.exports = $8d0b95672a813c0d$var$rip;
$8d0b95672a813c0d$var$rip.displayName = "rip";
$8d0b95672a813c0d$var$rip.aliases = [];
function $8d0b95672a813c0d$var$rip(Prism) {
    Prism.languages.rip = {
        comment: {
            pattern: /#.*/,
            greedy: true
        },
        char: {
            pattern: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,
            greedy: true
        },
        string: {
            pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        regex: {
            pattern: /(^|[^/])\/(?!\/)(?:\[[^\n\r\]]*\]|\\.|[^/\\\r\n\[])+\/(?=\s*(?:$|[\r\n,.;})]))/,
            lookbehind: true,
            greedy: true
        },
        keyword: /(?:=>|->)|\b(?:case|catch|class|else|exit|finally|if|raise|return|switch|try)\b/,
        builtin: /@|\bSystem\b/,
        boolean: /\b(?:false|true)\b/,
        date: /\b\d{4}-\d{2}-\d{2}\b/,
        time: /\b\d{2}:\d{2}:\d{2}\b/,
        datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
        symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
        number: /[+-]?\b(?:\d+\.\d+|\d+)\b/,
        punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
        reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
    };
}

});

parcelRequire.register("3G0XG", function(module, exports) {
"use strict";
module.exports = $2ad60a535242248c$var$roboconf;
$2ad60a535242248c$var$roboconf.displayName = "roboconf";
$2ad60a535242248c$var$roboconf.aliases = [];
function $2ad60a535242248c$var$roboconf(Prism) {
    Prism.languages.roboconf = {
        comment: /#.*/,
        keyword: {
            pattern: /(^|\s)(?:(?:external|import)\b|(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{))/,
            lookbehind: true
        },
        component: {
            pattern: /[\w-]+(?=[ \t]*\{)/,
            alias: "variable"
        },
        property: /[\w.-]+(?=[ \t]*:)/,
        value: {
            pattern: /(=[ \t]*(?![ \t]))[^,;]+/,
            lookbehind: true,
            alias: "attr-value"
        },
        optional: {
            pattern: /\(optional\)/,
            alias: "builtin"
        },
        wildcard: {
            pattern: /(\.)\*/,
            lookbehind: true,
            alias: "operator"
        },
        punctuation: /[{},.;:=]/
    };
}

});

parcelRequire.register("2x7Z1", function(module, exports) {
"use strict";
module.exports = $1d84db1ebdcb37c2$var$robotframework;
$1d84db1ebdcb37c2$var$robotframework.displayName = "robotframework";
$1d84db1ebdcb37c2$var$robotframework.aliases = [];
function $1d84db1ebdcb37c2$var$robotframework(Prism1) {
    (function(Prism) {
        var comment = {
            pattern: /(^[ \t]*| {2}|\t)#.*/m,
            lookbehind: true,
            greedy: true
        };
        var variable = {
            pattern: /((?:^|[^\\])(?:\\{2})*)[$@&%]\{(?:[^{}\r\n]|\{[^{}\r\n]*\})*\}/,
            lookbehind: true,
            inside: {
                punctuation: /^[$@&%]\{|\}$/
            }
        };
        function createSection(name, inside) {
            var extendecInside = {};
            extendecInside["section-header"] = {
                pattern: /^ ?\*{3}.+?\*{3}/,
                alias: "keyword"
            } // copy inside tokens
            ;
            for(var token in inside)extendecInside[token] = inside[token];
            extendecInside["tag"] = {
                pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
                lookbehind: true,
                inside: {
                    punctuation: /\[|\]/
                }
            };
            extendecInside["variable"] = variable;
            extendecInside["comment"] = comment;
            return {
                pattern: RegExp(/^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(/<name>/g, function() {
                    return name;
                }), "im"),
                alias: "section",
                inside: extendecInside
            };
        }
        var docTag = {
            pattern: /(\[Documentation\](?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
            lookbehind: true,
            alias: "string"
        };
        var testNameLike = {
            pattern: /([\r\n] ?)(?!#)(?:\S(?:[ \t]\S)*)+/,
            lookbehind: true,
            alias: "function",
            inside: {
                variable: variable
            }
        };
        var testPropertyLike = {
            pattern: /([\r\n](?: {2}|\t)[ \t]*)(?!\[|\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
            lookbehind: true,
            inside: {
                variable: variable
            }
        };
        Prism.languages["robotframework"] = {
            settings: createSection("Settings", {
                documentation: {
                    pattern: /([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
                    lookbehind: true,
                    alias: "string"
                },
                property: {
                    pattern: /([\r\n] ?)(?!\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
                    lookbehind: true
                }
            }),
            variables: createSection("Variables"),
            "test-cases": createSection("Test Cases", {
                "test-name": testNameLike,
                documentation: docTag,
                property: testPropertyLike
            }),
            keywords: createSection("Keywords", {
                "keyword-name": testNameLike,
                documentation: docTag,
                property: testPropertyLike
            }),
            tasks: createSection("Tasks", {
                "task-name": testNameLike,
                documentation: docTag,
                property: testPropertyLike
            }),
            comment: comment
        };
        Prism.languages.robot = Prism.languages["robotframework"];
    })(Prism1);
}

});

parcelRequire.register("8DI2y", function(module, exports) {
"use strict";
module.exports = $64a420b8303b2da1$var$rust;
$64a420b8303b2da1$var$rust.displayName = "rust";
$64a420b8303b2da1$var$rust.aliases = [];
function $64a420b8303b2da1$var$rust(Prism1) {
    (function(Prism) {
        var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
        for(var i = 0; i < 2; i++)// support 4 levels of nested comments
        multilineComment = multilineComment.replace(/<self>/g, function() {
            return multilineComment;
        });
        multilineComment = multilineComment.replace(/<self>/g, function() {
            return /[^\s\S]/.source;
        });
        Prism.languages.rust = {
            comment: [
                {
                    pattern: RegExp(/(^|[^\\])/.source + multilineComment),
                    lookbehind: true,
                    greedy: true
                },
                {
                    pattern: /(^|[^\\:])\/\/.*/,
                    lookbehind: true,
                    greedy: true
                }
            ],
            string: {
                pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
                greedy: true
            },
            char: {
                pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
                greedy: true
            },
            attribute: {
                pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
                greedy: true,
                alias: "attr-name",
                inside: {
                    string: null // see below
                }
            },
            // Closure params should not be confused with bitwise OR |
            "closure-params": {
                pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
                lookbehind: true,
                greedy: true,
                inside: {
                    "closure-punctuation": {
                        pattern: /^\||\|$/,
                        alias: "punctuation"
                    },
                    rest: null // see below
                }
            },
            "lifetime-annotation": {
                pattern: /'\w+/,
                alias: "symbol"
            },
            "fragment-specifier": {
                pattern: /(\$\w+:)[a-z]+/,
                lookbehind: true,
                alias: "punctuation"
            },
            variable: /\$\w+/,
            "function-definition": {
                pattern: /(\bfn\s+)\w+/,
                lookbehind: true,
                alias: "function"
            },
            "type-definition": {
                pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
                lookbehind: true,
                alias: "class-name"
            },
            "module-declaration": [
                {
                    pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
                    lookbehind: true,
                    alias: "namespace"
                },
                {
                    pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
                    lookbehind: true,
                    alias: "namespace",
                    inside: {
                        punctuation: /::/
                    }
                }
            ],
            keyword: [
                // https://github.com/rust-lang/reference/blob/master/src/keywords.md
                /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
                // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
                /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
            ],
            // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
            // and Rust's naming conventions recommend snake_case anyway.
            // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
            function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
            macro: {
                pattern: /\b\w+!/,
                alias: "property"
            },
            constant: /\b[A-Z_][A-Z_\d]+\b/,
            "class-name": /\b[A-Z]\w*\b/,
            namespace: {
                pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
                inside: {
                    punctuation: /::/
                }
            },
            // Hex, oct, bin, dec numbers with visual separators and type suffix
            number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
            boolean: /\b(?:false|true)\b/,
            punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
            operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
        };
        Prism.languages.rust["closure-params"].inside.rest = Prism.languages.rust;
        Prism.languages.rust["attribute"].inside["string"] = Prism.languages.rust["string"];
    })(Prism1);
}

});

parcelRequire.register("2H4A6", function(module, exports) {
"use strict";
module.exports = $1f6326a73ef3a7de$var$sas;
$1f6326a73ef3a7de$var$sas.displayName = "sas";
$1f6326a73ef3a7de$var$sas.aliases = [];
function $1f6326a73ef3a7de$var$sas(Prism1) {
    (function(Prism) {
        var stringPattern = /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))/.source;
        var number = /\b(?:\d[\da-f]*x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i;
        var numericConstant = {
            pattern: RegExp(stringPattern + "[bx]"),
            alias: "number"
        };
        var macroVariable = {
            pattern: /&[a-z_]\w*/i
        };
        var macroKeyword = {
            pattern: /((?:^|\s|=|\())%(?:ABORT|BY|CMS|COPY|DISPLAY|DO|ELSE|END|EVAL|GLOBAL|GO|GOTO|IF|INC|INCLUDE|INDEX|INPUT|KTRIM|LENGTH|LET|LIST|LOCAL|PUT|QKTRIM|QSCAN|QSUBSTR|QSYSFUNC|QUPCASE|RETURN|RUN|SCAN|SUBSTR|SUPERQ|SYMDEL|SYMEXIST|SYMGLOBL|SYMLOCAL|SYSCALL|SYSEVALF|SYSEXEC|SYSFUNC|SYSGET|SYSRPUT|THEN|TO|TSO|UNQUOTE|UNTIL|UPCASE|WHILE|WINDOW)\b/i,
            lookbehind: true,
            alias: "keyword"
        };
        var step = {
            pattern: /(^|\s)(?:proc\s+\w+|data(?!=)|quit|run)\b/i,
            alias: "keyword",
            lookbehind: true
        };
        var comment = [
            /\/\*[\s\S]*?\*\//,
            {
                pattern: /(^[ \t]*|;\s*)\*[^;]*;/m,
                lookbehind: true
            }
        ];
        var string = {
            pattern: RegExp(stringPattern),
            greedy: true
        };
        var punctuation = /[$%@.(){}\[\];,\\]/;
        var func = {
            pattern: /%?\b\w+(?=\()/,
            alias: "keyword"
        };
        var args = {
            function: func,
            "arg-value": {
                pattern: /(=\s*)[A-Z\.]+/i,
                lookbehind: true
            },
            operator: /=/,
            "macro-variable": macroVariable,
            arg: {
                pattern: /[A-Z]+/i,
                alias: "keyword"
            },
            number: number,
            "numeric-constant": numericConstant,
            punctuation: punctuation,
            string: string
        };
        var format = {
            pattern: /\b(?:format|put)\b=?[\w'$.]+/i,
            inside: {
                keyword: /^(?:format|put)(?==)/i,
                equals: /=/,
                format: {
                    pattern: /(?:\w|\$\d)+\.\d?/,
                    alias: "number"
                }
            }
        };
        var altformat = {
            pattern: /\b(?:format|put)\s+[\w']+(?:\s+[$.\w]+)+(?=;)/i,
            inside: {
                keyword: /^(?:format|put)/i,
                format: {
                    pattern: /[\w$]+\.\d?/,
                    alias: "number"
                }
            }
        };
        var globalStatements = {
            pattern: /((?:^|\s)=?)(?:catname|checkpoint execute_always|dm|endsas|filename|footnote|%include|libname|%list|lock|missing|options|page|resetline|%run|sasfile|skip|sysecho|title\d?)\b/i,
            lookbehind: true,
            alias: "keyword"
        };
        var submitStatement = {
            pattern: /(^|\s)(?:submit(?:\s+(?:load|norun|parseonly))?|endsubmit)\b/i,
            lookbehind: true,
            alias: "keyword"
        };
        var actionSets = /aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/.source;
        var casActions = {
            pattern: RegExp(/(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(/<act>/g, function() {
                return actionSets;
            }), "i"),
            lookbehind: true,
            inside: {
                keyword: RegExp(/(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function() {
                    return actionSets;
                }), "i"),
                action: {
                    pattern: /(?:action)/i,
                    alias: "keyword"
                },
                comment: comment,
                function: func,
                "arg-value": args["arg-value"],
                operator: args.operator,
                argument: args.arg,
                number: number,
                "numeric-constant": numericConstant,
                punctuation: punctuation,
                string: string
            }
        };
        var keywords = {
            pattern: /((?:^|\s)=?)(?:after|analysis|and|array|barchart|barwidth|begingraph|by|call|cas|cbarline|cfill|class(?:lev)?|close|column|computed?|contains|continue|data(?==)|define|delete|describe|document|do\s+over|do|dol|drop|dul|else|end(?:comp|source)?|entryTitle|eval(?:uate)?|exec(?:ute)?|exit|file(?:name)?|fill(?:attrs)?|flist|fnc|function(?:list)?|global|goto|group(?:by)?|headline|headskip|histogram|if|infile|keep|keylabel|keyword|label|layout|leave|legendlabel|length|libname|loadactionset|merge|midpoints|_?null_|name|noobs|nowd|ods|options|or|otherwise|out(?:put)?|over(?:lay)?|plot|print|put|raise|ranexp|rannor|rbreak|retain|return|select|session|sessref|set|source|statgraph|sum|summarize|table|temp|terminate|then\s+do|then|title\d?|to|var|when|where|xaxisopts|y2axisopts|yaxisopts)\b/i,
            lookbehind: true
        };
        Prism.languages.sas = {
            datalines: {
                pattern: /^([ \t]*)(?:cards|(?:data)?lines);[\s\S]+?^[ \t]*;/im,
                lookbehind: true,
                alias: "string",
                inside: {
                    keyword: {
                        pattern: /^(?:cards|(?:data)?lines)/i
                    },
                    punctuation: /;/
                }
            },
            "proc-sql": {
                pattern: /(^proc\s+(?:fed)?sql(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
                lookbehind: true,
                inside: {
                    sql: {
                        pattern: RegExp(/^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(/<str>/g, function() {
                            return stringPattern;
                        }), "im"),
                        alias: "language-sql",
                        inside: Prism.languages.sql
                    },
                    "global-statements": globalStatements,
                    "sql-statements": {
                        pattern: /(^|\s)(?:disconnect\s+from|begin|commit|exec(?:ute)?|reset|rollback|validate)\b/i,
                        lookbehind: true,
                        alias: "keyword"
                    },
                    number: number,
                    "numeric-constant": numericConstant,
                    punctuation: punctuation,
                    string: string
                }
            },
            "proc-groovy": {
                pattern: /(^proc\s+groovy(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
                lookbehind: true,
                inside: {
                    comment: comment,
                    groovy: {
                        pattern: RegExp(/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(/<str>/g, function() {
                            return stringPattern;
                        }), "im"),
                        lookbehind: true,
                        alias: "language-groovy",
                        inside: Prism.languages.groovy
                    },
                    keyword: keywords,
                    "submit-statement": submitStatement,
                    "global-statements": globalStatements,
                    number: number,
                    "numeric-constant": numericConstant,
                    punctuation: punctuation,
                    string: string
                }
            },
            "proc-lua": {
                pattern: /(^proc\s+lua(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
                lookbehind: true,
                inside: {
                    comment: comment,
                    lua: {
                        pattern: RegExp(/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(/<str>/g, function() {
                            return stringPattern;
                        }), "im"),
                        lookbehind: true,
                        alias: "language-lua",
                        inside: Prism.languages.lua
                    },
                    keyword: keywords,
                    "submit-statement": submitStatement,
                    "global-statements": globalStatements,
                    number: number,
                    "numeric-constant": numericConstant,
                    punctuation: punctuation,
                    string: string
                }
            },
            "proc-cas": {
                pattern: /(^proc\s+cas(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|quit|data);|(?![\s\S]))/im,
                lookbehind: true,
                inside: {
                    comment: comment,
                    "statement-var": {
                        pattern: /((?:^|\s)=?)saveresult\s[^;]+/im,
                        lookbehind: true,
                        inside: {
                            statement: {
                                pattern: /^saveresult\s+\S+/i,
                                inside: {
                                    keyword: /^(?:saveresult)/i
                                }
                            },
                            rest: args
                        }
                    },
                    "cas-actions": casActions,
                    statement: {
                        pattern: /((?:^|\s)=?)(?:default|(?:un)?set|on|output|upload)[^;]+/im,
                        lookbehind: true,
                        inside: args
                    },
                    step: step,
                    keyword: keywords,
                    function: func,
                    format: format,
                    altformat: altformat,
                    "global-statements": globalStatements,
                    number: number,
                    "numeric-constant": numericConstant,
                    punctuation: punctuation,
                    string: string
                }
            },
            "proc-args": {
                pattern: RegExp(/(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(/<str>/g, function() {
                    return stringPattern;
                }), "im"),
                lookbehind: true,
                inside: args
            },
            /*Special keywords within macros*/ "macro-keyword": macroKeyword,
            "macro-variable": macroVariable,
            "macro-string-functions": {
                pattern: /((?:^|\s|=))%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)\(.*?(?:[^%]\))/i,
                lookbehind: true,
                inside: {
                    function: {
                        pattern: /%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)/i,
                        alias: "keyword"
                    },
                    "macro-keyword": macroKeyword,
                    "macro-variable": macroVariable,
                    "escaped-char": {
                        pattern: /%['"()<>=¬^~;,#]/
                    },
                    punctuation: punctuation
                }
            },
            "macro-declaration": {
                pattern: /^%macro[^;]+(?=;)/im,
                inside: {
                    keyword: /%macro/i
                }
            },
            "macro-end": {
                pattern: /^%mend[^;]+(?=;)/im,
                inside: {
                    keyword: /%mend/i
                }
            },
            /*%_zscore(headcir, _lhc, _mhc, _shc, headcz, headcpct, _Fheadcz); */ macro: {
                pattern: /%_\w+(?=\()/,
                alias: "keyword"
            },
            input: {
                pattern: /\binput\s[-\w\s/*.$&]+;/i,
                inside: {
                    input: {
                        alias: "keyword",
                        pattern: /^input/i
                    },
                    comment: comment,
                    number: number,
                    "numeric-constant": numericConstant
                }
            },
            "options-args": {
                pattern: /(^options)[-'"|/\\<>*+=:()\w\s]*(?=;)/im,
                lookbehind: true,
                inside: args
            },
            "cas-actions": casActions,
            comment: comment,
            function: func,
            format: format,
            altformat: altformat,
            "numeric-constant": numericConstant,
            datetime: {
                // '1jan2013'd, '9:25:19pm't, '18jan2003:9:27:05am'dt
                pattern: RegExp(stringPattern + "(?:dt?|t)"),
                alias: "number"
            },
            string: string,
            step: step,
            keyword: keywords,
            // In SAS Studio syntax highlighting, these operators are styled like keywords
            "operator-keyword": {
                pattern: /\b(?:eq|ge|gt|in|le|lt|ne|not)\b/i,
                alias: "operator"
            },
            // Decimal (1.2e23), hexadecimal (0c1x)
            number: number,
            operator: /\*\*?|\|\|?|!!?|¦¦?|<[>=]?|>[<=]?|[-+\/=&]|[~¬^]=?/,
            punctuation: punctuation
        };
    })(Prism1);
}

});

parcelRequire.register("9kpWi", function(module, exports) {
"use strict";
module.exports = $6caa1a4bd9b6ebe9$var$sass;
$6caa1a4bd9b6ebe9$var$sass.displayName = "sass";
$6caa1a4bd9b6ebe9$var$sass.aliases = [];
function $6caa1a4bd9b6ebe9$var$sass(Prism1) {
    (function(Prism) {
        Prism.languages.sass = Prism.languages.extend("css", {
            // Sass comments don't need to be closed, only indented
            comment: {
                pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
                lookbehind: true,
                greedy: true
            }
        });
        Prism.languages.insertBefore("sass", "atrule", {
            // We want to consume the whole line
            "atrule-line": {
                // Includes support for = and + shortcuts
                pattern: /^(?:[ \t]*)[@+=].+/m,
                greedy: true,
                inside: {
                    atrule: /(?:@[\w-]+|[+=])/
                }
            }
        });
        delete Prism.languages.sass.atrule;
        var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
        var operator = [
            /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
            {
                pattern: /(\s)-(?=\s)/,
                lookbehind: true
            }
        ];
        Prism.languages.insertBefore("sass", "property", {
            // We want to consume the whole line
            "variable-line": {
                pattern: /^[ \t]*\$.+/m,
                greedy: true,
                inside: {
                    punctuation: /:/,
                    variable: variable,
                    operator: operator
                }
            },
            // We want to consume the whole line
            "property-line": {
                pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
                greedy: true,
                inside: {
                    property: [
                        /[^:\s]+(?=\s*:)/,
                        {
                            pattern: /(:)[^:\s]+/,
                            lookbehind: true
                        }
                    ],
                    punctuation: /:/,
                    variable: variable,
                    operator: operator,
                    important: Prism.languages.sass.important
                }
            }
        });
        delete Prism.languages.sass.property;
        delete Prism.languages.sass.important // Now that whole lines for other patterns are consumed,
        ;
        // what's left should be selectors
        Prism.languages.insertBefore("sass", "punctuation", {
            selector: {
                pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
                lookbehind: true,
                greedy: true
            }
        });
    })(Prism1);
}

});

parcelRequire.register("lbKMZ", function(module, exports) {
"use strict";

var $4co4r = parcelRequire("4co4r");
module.exports = $03fb1450342ad83f$var$scala;
$03fb1450342ad83f$var$scala.displayName = "scala";
$03fb1450342ad83f$var$scala.aliases = [];
function $03fb1450342ad83f$var$scala(Prism) {
    Prism.register($4co4r);
    Prism.languages.scala = Prism.languages.extend("java", {
        "triple-quoted-string": {
            pattern: /"""[\s\S]*?"""/,
            greedy: true,
            alias: "string"
        },
        string: {
            pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        keyword: /<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,
        number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
        builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
        symbol: /'[^\d\s\\]\w*/
    });
    Prism.languages.insertBefore("scala", "triple-quoted-string", {
        "string-interpolation": {
            pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
            greedy: true,
            inside: {
                id: {
                    pattern: /^\w+/,
                    greedy: true,
                    alias: "function"
                },
                escape: {
                    pattern: /\\\$"|\$[$"]/,
                    greedy: true,
                    alias: "symbol"
                },
                interpolation: {
                    pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
                    greedy: true,
                    inside: {
                        punctuation: /^\$\{?|\}$/,
                        expression: {
                            pattern: /[\s\S]+/,
                            inside: Prism.languages.scala
                        }
                    }
                },
                string: /[\s\S]+/
            }
        }
    });
    delete Prism.languages.scala["class-name"];
    delete Prism.languages.scala["function"];
}

});

parcelRequire.register("bsvoe", function(module, exports) {
"use strict";
module.exports = $857aa89870231019$var$scss;
$857aa89870231019$var$scss.displayName = "scss";
$857aa89870231019$var$scss.aliases = [];
function $857aa89870231019$var$scss(Prism) {
    Prism.languages.scss = Prism.languages.extend("css", {
        comment: {
            pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
            lookbehind: true
        },
        atrule: {
            pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
            inside: {
                rule: /@[\w-]+/ // See rest below
            }
        },
        // url, compassified
        url: /(?:[-a-z]+-)?url(?=\()/i,
        // CSS selector regex is not appropriate for Sass
        // since there can be lot more things (var, @ directive, nesting..)
        // a selector must start at the end of a property or after a brace (end of other rules or nesting)
        // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
        // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
        // can "pass" as a selector- e.g: proper#{$erty})
        // this one was hard to do, so please be careful if you edit this one :)
        selector: {
            // Initial look-ahead is used to prevent matching of blank selectors
            pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
            inside: {
                parent: {
                    pattern: /&/,
                    alias: "important"
                },
                placeholder: /%[-\w]+/,
                variable: /\$[-\w]+|#\{\$[-\w]+\}/
            }
        },
        property: {
            pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
            inside: {
                variable: /\$[-\w]+|#\{\$[-\w]+\}/
            }
        }
    });
    Prism.languages.insertBefore("scss", "atrule", {
        keyword: [
            /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
            {
                pattern: /( )(?:from|through)(?= )/,
                lookbehind: true
            }
        ]
    });
    Prism.languages.insertBefore("scss", "important", {
        // var and interpolated vars
        variable: /\$[-\w]+|#\{\$[-\w]+\}/
    });
    Prism.languages.insertBefore("scss", "function", {
        "module-modifier": {
            pattern: /\b(?:as|hide|show|with)\b/i,
            alias: "keyword"
        },
        placeholder: {
            pattern: /%[-\w]+/,
            alias: "selector"
        },
        statement: {
            pattern: /\B!(?:default|optional)\b/i,
            alias: "keyword"
        },
        boolean: /\b(?:false|true)\b/,
        null: {
            pattern: /\bnull\b/,
            alias: "keyword"
        },
        operator: {
            pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
            lookbehind: true
        }
    });
    Prism.languages.scss["atrule"].inside.rest = Prism.languages.scss;
}

});

parcelRequire.register("haSCJ", function(module, exports) {
"use strict";

var $adjC6 = parcelRequire("adjC6");
module.exports = $c80dbdfe357178a2$var$shellSession;
$c80dbdfe357178a2$var$shellSession.displayName = "shellSession";
$c80dbdfe357178a2$var$shellSession.aliases = [];
function $c80dbdfe357178a2$var$shellSession(Prism1) {
    Prism1.register($adjC6);
    (function(Prism) {
        // CAREFUL!
        // The following patterns are concatenated, so the group referenced by a back reference is non-obvious!
        var strings = [
            // normal string
            /"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
            /'[^']*'/.source,
            /\$'(?:[^'\\]|\\[\s\S])*'/.source,
            // 2 capturing groups
            /<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
        ].join("|");
        Prism.languages["shell-session"] = {
            command: {
                pattern: RegExp(// user info
                /^/.source + "(?:" + (/[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/.source + "|" + // Since the path pattern is quite general, we will require it to start with a special character to
                // prevent false positives.
                /[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source) + ")?" + /[$#%](?=\s)/.source + /(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(/<<str>>/g, function() {
                    return strings;
                }), "m"),
                greedy: true,
                inside: {
                    info: {
                        // foo@bar:~/files$ exit
                        // foo@bar$ exit
                        // ~/files$ exit
                        pattern: /^[^#$%]+/,
                        alias: "punctuation",
                        inside: {
                            user: /^[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+/,
                            punctuation: /:/,
                            path: /[\s\S]+/
                        }
                    },
                    bash: {
                        pattern: /(^[$#%]\s*)\S[\s\S]*/,
                        lookbehind: true,
                        alias: "language-bash",
                        inside: Prism.languages.bash
                    },
                    "shell-symbol": {
                        pattern: /^[$#%]/,
                        alias: "important"
                    }
                }
            },
            output: /.(?:.*(?:[\r\n]|.$))*/
        };
        Prism.languages["sh-session"] = Prism.languages["shellsession"] = Prism.languages["shell-session"];
    })(Prism1);
}

});

parcelRequire.register("dx9Q9", function(module, exports) {
"use strict";
module.exports = $028aef715b622587$var$smali;
$028aef715b622587$var$smali.displayName = "smali";
$028aef715b622587$var$smali.aliases = [];
function $028aef715b622587$var$smali(Prism) {
    // Test files for the parser itself:
    // https://github.com/JesusFreke/smali/tree/master/smali/src/test/resources/LexerTest
    Prism.languages.smali = {
        comment: /#.*/,
        string: {
            pattern: /"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\(?:.|u[\da-fA-F]{4}))'/,
            greedy: true
        },
        "class-name": {
            pattern: /(^|[^L])L(?:(?:\w+|`[^`\r\n]*`)\/)*(?:[\w$]+|`[^`\r\n]*`)(?=\s*;)/,
            lookbehind: true,
            inside: {
                "class-name": {
                    pattern: /(^L|\/)(?:[\w$]+|`[^`\r\n]*`)$/,
                    lookbehind: true
                },
                namespace: {
                    pattern: /^(L)(?:(?:\w+|`[^`\r\n]*`)\/)+/,
                    lookbehind: true,
                    inside: {
                        punctuation: /\//
                    }
                },
                builtin: /^L/
            }
        },
        builtin: [
            {
                // Reference: https://github.com/JesusFreke/smali/wiki/TypesMethodsAndFields#types
                pattern: /([();\[])[BCDFIJSVZ]+/,
                lookbehind: true
            },
            {
                // e.g. .field mWifiOnUid:I
                pattern: /([\w$>]:)[BCDFIJSVZ]/,
                lookbehind: true
            }
        ],
        keyword: [
            {
                pattern: /(\.end\s+)[\w-]+/,
                lookbehind: true
            },
            {
                pattern: /(^|[^\w.-])\.(?!\d)[\w-]+/,
                lookbehind: true
            },
            {
                pattern: /(^|[^\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\w.-])/,
                lookbehind: true
            }
        ],
        function: {
            pattern: /(^|[^\w.-])(?:\w+|<[\w$-]+>)(?=\()/,
            lookbehind: true
        },
        field: {
            pattern: /[\w$]+(?=:)/,
            alias: "variable"
        },
        register: {
            pattern: /(^|[^\w.-])[vp]\d(?![\w.-])/,
            lookbehind: true,
            alias: "variable"
        },
        boolean: {
            pattern: /(^|[^\w.-])(?:false|true)(?![\w.-])/,
            lookbehind: true
        },
        number: {
            pattern: /(^|[^/\w.-])-?(?:NAN|INFINITY|0x(?:[\dA-F]+(?:\.[\dA-F]*)?|\.[\dA-F]+)(?:p[+-]?[\dA-F]+)?|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)[dflst]?(?![\w.-])/i,
            lookbehind: true
        },
        label: {
            pattern: /(:)\w+/,
            lookbehind: true,
            alias: "property"
        },
        operator: /->|\.\.|[\[=]/,
        punctuation: /[{}(),;:]/
    };
}

});

parcelRequire.register("87mWg", function(module, exports) {
"use strict";
module.exports = $5e90c550980c9cab$var$smalltalk;
$5e90c550980c9cab$var$smalltalk.displayName = "smalltalk";
$5e90c550980c9cab$var$smalltalk.aliases = [];
function $5e90c550980c9cab$var$smalltalk(Prism) {
    Prism.languages.smalltalk = {
        comment: {
            pattern: /"(?:""|[^"])*"/,
            greedy: true
        },
        char: {
            pattern: /\$./,
            greedy: true
        },
        string: {
            pattern: /'(?:''|[^'])*'/,
            greedy: true
        },
        symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
        "block-arguments": {
            pattern: /(\[\s*):[^\[|]*\|/,
            lookbehind: true,
            inside: {
                variable: /:[\da-z]+/i,
                punctuation: /\|/
            }
        },
        "temporary-variables": {
            pattern: /\|[^|]+\|/,
            inside: {
                variable: /[\da-z]+/i,
                punctuation: /\|/
            }
        },
        keyword: /\b(?:new|nil|self|super)\b/,
        boolean: /\b(?:false|true)\b/,
        number: [
            /\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/,
            /\b\d+(?:\.\d+)?(?:e-?\d+)?/
        ],
        operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
        punctuation: /[.;:?\[\](){}]/
    };
}

});

parcelRequire.register("jaOa5", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");
module.exports = $df55dc8d51d60a07$var$smarty;
$df55dc8d51d60a07$var$smarty.displayName = "smarty";
$df55dc8d51d60a07$var$smarty.aliases = [];
function $df55dc8d51d60a07$var$smarty(Prism1) {
    Prism1.register($cekeD);
    (function(Prism) {
        Prism.languages.smarty = {
            comment: {
                pattern: /^\{\*[\s\S]*?\*\}/,
                greedy: true
            },
            "embedded-php": {
                pattern: /^\{php\}[\s\S]*?\{\/php\}/,
                greedy: true,
                inside: {
                    smarty: {
                        pattern: /^\{php\}|\{\/php\}$/,
                        inside: null // see below
                    },
                    php: {
                        pattern: /[\s\S]+/,
                        alias: "language-php",
                        inside: Prism.languages.php
                    }
                }
            },
            string: [
                {
                    pattern: /"(?:\\.|[^"\\\r\n])*"/,
                    greedy: true,
                    inside: {
                        interpolation: {
                            pattern: /\{[^{}]*\}|`[^`]*`/,
                            inside: {
                                "interpolation-punctuation": {
                                    pattern: /^[{`]|[`}]$/,
                                    alias: "punctuation"
                                },
                                expression: {
                                    pattern: /[\s\S]+/,
                                    inside: null // see below
                                }
                            }
                        },
                        variable: /\$\w+/
                    }
                },
                {
                    pattern: /'(?:\\.|[^'\\\r\n])*'/,
                    greedy: true
                }
            ],
            keyword: {
                pattern: /(^\{\/?)[a-z_]\w*\b(?!\()/i,
                lookbehind: true,
                greedy: true
            },
            delimiter: {
                pattern: /^\{\/?|\}$/,
                greedy: true,
                alias: "punctuation"
            },
            number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
            variable: [
                /\$(?!\d)\w+/,
                /#(?!\d)\w+#/,
                {
                    pattern: /(\.|->|\w\s*=)(?!\d)\w+\b(?!\()/,
                    lookbehind: true
                },
                {
                    pattern: /(\[)(?!\d)\w+(?=\])/,
                    lookbehind: true
                }
            ],
            function: {
                pattern: /(\|\s*)@?[a-z_]\w*|\b[a-z_]\w*(?=\()/i,
                lookbehind: true
            },
            "attr-name": /\b[a-z_]\w*(?=\s*=)/i,
            boolean: /\b(?:false|no|off|on|true|yes)\b/,
            punctuation: /[\[\](){}.,:`]|->/,
            operator: [
                /[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
                /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
                /\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/
            ]
        };
        Prism.languages.smarty["embedded-php"].inside.smarty.inside = Prism.languages.smarty;
        Prism.languages.smarty.string[0].inside.interpolation.inside.expression.inside = Prism.languages.smarty;
        var string = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/;
        var smartyPattern = RegExp(// comments
        /\{\*[\s\S]*?\*\}/.source + "|" + /\{php\}[\s\S]*?\{\/php\}/.source + "|" + /\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source.replace(/<str>/g, function() {
            return string.source;
        }), "g") // Tokenize all inline Smarty expressions
        ;
        Prism.hooks.add("before-tokenize", function(env) {
            var smartyLiteralStart = "{literal}";
            var smartyLiteralEnd = "{/literal}";
            var smartyLiteralMode = false;
            Prism.languages["markup-templating"].buildPlaceholders(env, "smarty", smartyPattern, function(match) {
                // Smarty tags inside {literal} block are ignored
                if (match === smartyLiteralEnd) smartyLiteralMode = false;
                if (!smartyLiteralMode) {
                    if (match === smartyLiteralStart) smartyLiteralMode = true;
                    return true;
                }
                return false;
            });
        }) // Re-insert the tokens after tokenizing
        ;
        Prism.hooks.add("after-tokenize", function(env) {
            Prism.languages["markup-templating"].tokenizePlaceholders(env, "smarty");
        });
    })(Prism1);
}

});

parcelRequire.register("3NOQn", function(module, exports) {
"use strict";
module.exports = $2c4d633cc6e33c0c$var$sml;
$2c4d633cc6e33c0c$var$sml.displayName = "sml";
$2c4d633cc6e33c0c$var$sml.aliases = [
    "smlnj"
];
function $2c4d633cc6e33c0c$var$sml(Prism1) {
    (function(Prism) {
        var keywords = /\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
        Prism.languages.sml = {
            // allow one level of nesting
            comment: /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
            string: {
                pattern: /#?"(?:[^"\\]|\\.)*"/,
                greedy: true
            },
            "class-name": [
                {
                    // This is only an approximation since the real grammar is context-free
                    //
                    // Why the main loop so complex?
                    // The main loop is approximately the same as /(?:\s*(?:[*,]|->)\s*<TERMINAL>)*/ which is, obviously, a lot
                    // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be
                    // followed by a long identifier.
                    pattern: RegExp(/((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function() {
                        return /\s*(?:[*,]|->)/.source;
                    }).replace(/<TERMINAL>/g, function() {
                        return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/.source;
                    }).replace(/<LONG-ID>/g, function() {
                        return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source;
                    }).replace(/<KEYWORD>/g, function() {
                        return keywords.source;
                    }), "i"),
                    lookbehind: true,
                    greedy: true,
                    inside: null // see below
                },
                {
                    pattern: /((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
                    lookbehind: true
                }
            ],
            function: {
                pattern: /((?:^|[^\w'])fun\s+)[a-z_][\w'.]*/i,
                lookbehind: true
            },
            keyword: keywords,
            variable: {
                pattern: /(^|[^\w'])'[\w']*/,
                lookbehind: true
            },
            number: /~?\b(?:\d+(?:\.\d+)?(?:e~?\d+)?|0x[\da-f]+)\b/i,
            word: {
                pattern: /\b0w(?:\d+|x[\da-f]+)\b/i,
                alias: "constant"
            },
            boolean: /\b(?:false|true)\b/i,
            operator: /\.\.\.|:[>=:]|=>?|->|[<>]=?|[!+\-*/^#|@~]/,
            punctuation: /[(){}\[\].:,;]/
        };
        Prism.languages.sml["class-name"][0].inside = Prism.languages.sml;
        Prism.languages.smlnj = Prism.languages.sml;
    })(Prism1);
}

});

parcelRequire.register("k7UGg", function(module, exports) {
"use strict";
module.exports = $ea706db617b3107b$var$solidity;
$ea706db617b3107b$var$solidity.displayName = "solidity";
$ea706db617b3107b$var$solidity.aliases = [
    "sol"
];
function $ea706db617b3107b$var$solidity(Prism) {
    Prism.languages.solidity = Prism.languages.extend("clike", {
        "class-name": {
            pattern: /(\b(?:contract|enum|interface|library|new|struct|using)\s+)(?!\d)[\w$]+/,
            lookbehind: true
        },
        keyword: /\b(?:_|anonymous|as|assembly|assert|break|calldata|case|constant|constructor|continue|contract|default|delete|do|else|emit|enum|event|external|for|from|function|if|import|indexed|inherited|interface|internal|is|let|library|mapping|memory|modifier|new|payable|pragma|private|public|pure|require|returns?|revert|selfdestruct|solidity|storage|struct|suicide|switch|this|throw|using|var|view|while)\b/,
        operator: /=>|->|:=|=:|\*\*|\+\+|--|\|\||&&|<<=?|>>=?|[-+*/%^&|<>!=]=?|[~?]/
    });
    Prism.languages.insertBefore("solidity", "keyword", {
        builtin: /\b(?:address|bool|byte|u?int(?:8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?|string|bytes(?:[1-9]|[12]\d|3[0-2])?)\b/
    });
    Prism.languages.insertBefore("solidity", "number", {
        version: {
            pattern: /([<>]=?|\^)\d+\.\d+\.\d+\b/,
            lookbehind: true,
            alias: "number"
        }
    });
    Prism.languages.sol = Prism.languages.solidity;
}

});

parcelRequire.register("lTlZu", function(module, exports) {
"use strict";
module.exports = $feffcaea479dd9f4$var$solutionFile;
$feffcaea479dd9f4$var$solutionFile.displayName = "solutionFile";
$feffcaea479dd9f4$var$solutionFile.aliases = [];
function $feffcaea479dd9f4$var$solutionFile(Prism1) {
    (function(Prism) {
        var guid = {
            // https://en.wikipedia.org/wiki/Universally_unique_identifier#Format
            pattern: /\{[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}\}/i,
            alias: "constant",
            inside: {
                punctuation: /[{}]/
            }
        };
        Prism.languages["solution-file"] = {
            comment: {
                pattern: /#.*/,
                greedy: true
            },
            string: {
                pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
                greedy: true,
                inside: {
                    guid: guid
                }
            },
            object: {
                // Foo
                //   Bar("abs") = 9
                //   EndBar
                //   Prop = TRUE
                // EndFoo
                pattern: /^([ \t]*)(?:([A-Z]\w*)\b(?=.*(?:\r\n?|\n)(?:\1[ \t].*(?:\r\n?|\n))*\1End\2(?=[ \t]*$))|End[A-Z]\w*(?=[ \t]*$))/m,
                lookbehind: true,
                greedy: true,
                alias: "keyword"
            },
            property: {
                pattern: /^([ \t]*)(?!\s)[^\r\n"#=()]*[^\s"#=()](?=\s*=)/m,
                lookbehind: true,
                inside: {
                    guid: guid
                }
            },
            guid: guid,
            number: /\b\d+(?:\.\d+)*\b/,
            boolean: /\b(?:FALSE|TRUE)\b/,
            operator: /=/,
            punctuation: /[(),]/
        };
        Prism.languages["sln"] = Prism.languages["solution-file"];
    })(Prism1);
}

});

parcelRequire.register("mjKIY", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");
module.exports = $043160a5cce498ff$var$soy;
$043160a5cce498ff$var$soy.displayName = "soy";
$043160a5cce498ff$var$soy.aliases = [];
function $043160a5cce498ff$var$soy(Prism1) {
    Prism1.register($cekeD);
    (function(Prism) {
        var stringPattern = /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
        var numberPattern = /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-F]+\b/;
        Prism.languages.soy = {
            comment: [
                /\/\*[\s\S]*?\*\//,
                {
                    pattern: /(\s)\/\/.*/,
                    lookbehind: true,
                    greedy: true
                }
            ],
            "command-arg": {
                pattern: /(\{+\/?\s*(?:alias|call|delcall|delpackage|deltemplate|namespace|template)\s+)\.?[\w.]+/,
                lookbehind: true,
                alias: "string",
                inside: {
                    punctuation: /\./
                }
            },
            parameter: {
                pattern: /(\{+\/?\s*@?param\??\s+)\.?[\w.]+/,
                lookbehind: true,
                alias: "variable"
            },
            keyword: [
                {
                    pattern: /(\{+\/?[^\S\r\n]*)(?:\\[nrt]|alias|call|case|css|default|delcall|delpackage|deltemplate|else(?:if)?|fallbackmsg|for(?:each)?|if(?:empty)?|lb|let|literal|msg|namespace|nil|@?param\??|rb|sp|switch|template|xid)/,
                    lookbehind: true
                },
                /\b(?:any|as|attributes|bool|css|float|html|in|int|js|list|map|null|number|string|uri)\b/
            ],
            delimiter: {
                pattern: /^\{+\/?|\/?\}+$/,
                alias: "punctuation"
            },
            property: /\w+(?==)/,
            variable: {
                pattern: /\$[^\W\d]\w*(?:\??(?:\.\w+|\[[^\]]+\]))*/,
                inside: {
                    string: {
                        pattern: stringPattern,
                        greedy: true
                    },
                    number: numberPattern,
                    punctuation: /[\[\].?]/
                }
            },
            string: {
                pattern: stringPattern,
                greedy: true
            },
            function: [
                /\w+(?=\()/,
                {
                    pattern: /(\|[^\S\r\n]*)\w+/,
                    lookbehind: true
                }
            ],
            boolean: /\b(?:false|true)\b/,
            number: numberPattern,
            operator: /\?:?|<=?|>=?|==?|!=|[+*/%-]|\b(?:and|not|or)\b/,
            punctuation: /[{}()\[\]|.,:]/
        } // Tokenize all inline Soy expressions
        ;
        Prism.hooks.add("before-tokenize", function(env) {
            var soyPattern = /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g;
            var soyLitteralStart = "{literal}";
            var soyLitteralEnd = "{/literal}";
            var soyLitteralMode = false;
            Prism.languages["markup-templating"].buildPlaceholders(env, "soy", soyPattern, function(match) {
                // Soy tags inside {literal} block are ignored
                if (match === soyLitteralEnd) soyLitteralMode = false;
                if (!soyLitteralMode) {
                    if (match === soyLitteralStart) soyLitteralMode = true;
                    return true;
                }
                return false;
            });
        }) // Re-insert the tokens after tokenizing
        ;
        Prism.hooks.add("after-tokenize", function(env) {
            Prism.languages["markup-templating"].tokenizePlaceholders(env, "soy");
        });
    })(Prism1);
}

});

parcelRequire.register("fpQ6N", function(module, exports) {
"use strict";

var $aFTf2 = parcelRequire("aFTf2");
module.exports = $b3919c836edb8179$var$sparql;
$b3919c836edb8179$var$sparql.displayName = "sparql";
$b3919c836edb8179$var$sparql.aliases = [
    "rq"
];
function $b3919c836edb8179$var$sparql(Prism) {
    Prism.register($aFTf2);
    Prism.languages.sparql = Prism.languages.extend("turtle", {
        boolean: /\b(?:false|true)\b/i,
        variable: {
            pattern: /[?$]\w+/,
            greedy: true
        }
    });
    Prism.languages.insertBefore("sparql", "punctuation", {
        keyword: [
            /\b(?:A|ADD|ALL|AS|ASC|ASK|BNODE|BY|CLEAR|CONSTRUCT|COPY|CREATE|DATA|DEFAULT|DELETE|DESC|DESCRIBE|DISTINCT|DROP|EXISTS|FILTER|FROM|GROUP|HAVING|INSERT|INTO|LIMIT|LOAD|MINUS|MOVE|NAMED|NOT|NOW|OFFSET|OPTIONAL|ORDER|RAND|REDUCED|SELECT|SEPARATOR|SERVICE|SILENT|STRUUID|UNION|USING|UUID|VALUES|WHERE)\b/i,
            /\b(?:ABS|AVG|BIND|BOUND|CEIL|COALESCE|CONCAT|CONTAINS|COUNT|DATATYPE|DAY|ENCODE_FOR_URI|FLOOR|GROUP_CONCAT|HOURS|IF|IRI|isBLANK|isIRI|isLITERAL|isNUMERIC|isURI|LANG|LANGMATCHES|LCASE|MAX|MD5|MIN|MINUTES|MONTH|REGEX|REPLACE|ROUND|sameTerm|SAMPLE|SECONDS|SHA1|SHA256|SHA384|SHA512|STR|STRAFTER|STRBEFORE|STRDT|STRENDS|STRLANG|STRLEN|STRSTARTS|SUBSTR|SUM|TIMEZONE|TZ|UCASE|URI|YEAR)\b(?=\s*\()/i,
            /\b(?:BASE|GRAPH|PREFIX)\b/i
        ]
    });
    Prism.languages.rq = Prism.languages.sparql;
}

});
parcelRequire.register("aFTf2", function(module, exports) {
"use strict";
module.exports = $7c589590392f7f7d$var$turtle;
$7c589590392f7f7d$var$turtle.displayName = "turtle";
$7c589590392f7f7d$var$turtle.aliases = [];
function $7c589590392f7f7d$var$turtle(Prism) {
    Prism.languages.turtle = {
        comment: {
            pattern: /#.*/,
            greedy: true
        },
        "multiline-string": {
            pattern: /"""(?:(?:""?)?(?:[^"\\]|\\.))*"""|'''(?:(?:''?)?(?:[^'\\]|\\.))*'''/,
            greedy: true,
            alias: "string",
            inside: {
                comment: /#.*/
            }
        },
        string: {
            pattern: /"(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*'/,
            greedy: true
        },
        url: {
            pattern: /<(?:[^\x00-\x20<>"{}|^`\\]|\\(?:u[\da-fA-F]{4}|U[\da-fA-F]{8}))*>/,
            greedy: true,
            inside: {
                punctuation: /[<>]/
            }
        },
        function: {
            pattern: /(?:(?![-.\d\xB7])[-.\w\xB7\xC0-\uFFFD]+)?:(?:(?![-.])(?:[-.:\w\xC0-\uFFFD]|%[\da-f]{2}|\\.)+)?/i,
            inside: {
                "local-name": {
                    pattern: /([^:]*:)[\s\S]+/,
                    lookbehind: true
                },
                prefix: {
                    pattern: /[\s\S]+/,
                    inside: {
                        punctuation: /:/
                    }
                }
            }
        },
        number: /[+-]?\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
        punctuation: /[{}.,;()[\]]|\^\^/,
        boolean: /\b(?:false|true)\b/,
        keyword: [
            /(?:\ba|@prefix|@base)\b|=/,
            /\b(?:base|graph|prefix)\b/i
        ],
        tag: {
            pattern: /@[a-z]+(?:-[a-z\d]+)*/i,
            inside: {
                punctuation: /@/
            }
        }
    };
    Prism.languages.trig = Prism.languages["turtle"];
}

});


parcelRequire.register("78veX", function(module, exports) {
"use strict";
module.exports = $5321836ec70c7d53$var$splunkSpl;
$5321836ec70c7d53$var$splunkSpl.displayName = "splunkSpl";
$5321836ec70c7d53$var$splunkSpl.aliases = [];
function $5321836ec70c7d53$var$splunkSpl(Prism) {
    Prism.languages["splunk-spl"] = {
        comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
        string: {
            pattern: /"(?:\\.|[^\\"])*"/,
            greedy: true
        },
        // https://docs.splunk.com/Documentation/Splunk/7.3.0/SearchReference/ListOfSearchCommands
        keyword: /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
        "operator-word": {
            pattern: /\b(?:and|as|by|not|or|xor)\b/i,
            alias: "operator"
        },
        function: /\b\w+(?=\s*\()/,
        property: /\b\w+(?=\s*=(?!=))/,
        date: {
            // MM/DD/YYYY(:HH:MM:SS)?
            pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
            alias: "number"
        },
        number: /\b\d+(?:\.\d+)?\b/,
        boolean: /\b(?:f|false|t|true)\b/i,
        operator: /[<>=]=?|[-+*/%|]/,
        punctuation: /[()[\],]/
    };
}

});

parcelRequire.register("4sJYz", function(module, exports) {
"use strict";
module.exports = $33fd70cb40b5c208$var$sqf;
$33fd70cb40b5c208$var$sqf.displayName = "sqf";
$33fd70cb40b5c208$var$sqf.aliases = [];
function $33fd70cb40b5c208$var$sqf(Prism) {
    Prism.languages.sqf = Prism.languages.extend("clike", {
        string: {
            pattern: /"(?:(?:"")?[^"])*"(?!")|'(?:[^'])*'/,
            greedy: true
        },
        keyword: /\b(?:breakOut|breakTo|call|case|catch|default|do|echo|else|execFSM|execVM|exitWith|for|forEach|forEachMember|forEachMemberAgent|forEachMemberTeam|from|goto|if|nil|preprocessFile|preprocessFileLineNumbers|private|scopeName|spawn|step|switch|then|throw|to|try|while|with)\b/i,
        boolean: /\b(?:false|true)\b/i,
        function: /\b(?:abs|accTime|acos|action|actionIDs|actionKeys|actionKeysImages|actionKeysNames|actionKeysNamesArray|actionName|actionParams|activateAddons|activatedAddons|activateKey|add3DENConnection|add3DENEventHandler|add3DENLayer|addAction|addBackpack|addBackpackCargo|addBackpackCargoGlobal|addBackpackGlobal|addCamShake|addCuratorAddons|addCuratorCameraArea|addCuratorEditableObjects|addCuratorEditingArea|addCuratorPoints|addEditorObject|addEventHandler|addForce|addForceGeneratorRTD|addGoggles|addGroupIcon|addHandgunItem|addHeadgear|addItem|addItemCargo|addItemCargoGlobal|addItemPool|addItemToBackpack|addItemToUniform|addItemToVest|addLiveStats|addMagazine|addMagazineAmmoCargo|addMagazineCargo|addMagazineCargoGlobal|addMagazineGlobal|addMagazinePool|addMagazines|addMagazineTurret|addMenu|addMenuItem|addMissionEventHandler|addMPEventHandler|addMusicEventHandler|addOwnedMine|addPlayerScores|addPrimaryWeaponItem|addPublicVariableEventHandler|addRating|addResources|addScore|addScoreSide|addSecondaryWeaponItem|addSwitchableUnit|addTeamMember|addToRemainsCollector|addTorque|addUniform|addVehicle|addVest|addWaypoint|addWeapon|addWeaponCargo|addWeaponCargoGlobal|addWeaponGlobal|addWeaponItem|addWeaponPool|addWeaponTurret|admin|agent|agents|AGLToASL|aimedAtTarget|aimPos|airDensityCurveRTD|airDensityRTD|airplaneThrottle|airportSide|AISFinishHeal|alive|all3DENEntities|allAirports|allControls|allCurators|allCutLayers|allDead|allDeadMen|allDisplays|allGroups|allMapMarkers|allMines|allMissionObjects|allow3DMode|allowCrewInImmobile|allowCuratorLogicIgnoreAreas|allowDamage|allowDammage|allowFileOperations|allowFleeing|allowGetIn|allowSprint|allPlayers|allSimpleObjects|allSites|allTurrets|allUnits|allUnitsUAV|allVariables|ammo|ammoOnPylon|animate|animateBay|animateDoor|animatePylon|animateSource|animationNames|animationPhase|animationSourcePhase|animationState|append|apply|armoryPoints|arrayIntersect|asin|ASLToAGL|ASLToATL|assert|assignAsCargo|assignAsCargoIndex|assignAsCommander|assignAsDriver|assignAsGunner|assignAsTurret|assignCurator|assignedCargo|assignedCommander|assignedDriver|assignedGunner|assignedItems|assignedTarget|assignedTeam|assignedVehicle|assignedVehicleRole|assignItem|assignTeam|assignToAirport|atan|atan2|atg|ATLToASL|attachedObject|attachedObjects|attachedTo|attachObject|attachTo|attackEnabled|backpack|backpackCargo|backpackContainer|backpackItems|backpackMagazines|backpackSpaceFor|behaviour|benchmark|binocular|blufor|boundingBox|boundingBoxReal|boundingCenter|briefingName|buildingExit|buildingPos|buldozer_EnableRoadDiag|buldozer_IsEnabledRoadDiag|buldozer_LoadNewRoads|buldozer_reloadOperMap|buttonAction|buttonSetAction|cadetMode|callExtension|camCommand|camCommit|camCommitPrepared|camCommitted|camConstuctionSetParams|camCreate|camDestroy|cameraEffect|cameraEffectEnableHUD|cameraInterest|cameraOn|cameraView|campaignConfigFile|camPreload|camPreloaded|camPrepareBank|camPrepareDir|camPrepareDive|camPrepareFocus|camPrepareFov|camPrepareFovRange|camPreparePos|camPrepareRelPos|camPrepareTarget|camSetBank|camSetDir|camSetDive|camSetFocus|camSetFov|camSetFovRange|camSetPos|camSetRelPos|camSetTarget|camTarget|camUseNVG|canAdd|canAddItemToBackpack|canAddItemToUniform|canAddItemToVest|cancelSimpleTaskDestination|canFire|canMove|canSlingLoad|canStand|canSuspend|canTriggerDynamicSimulation|canUnloadInCombat|canVehicleCargo|captive|captiveNum|cbChecked|cbSetChecked|ceil|channelEnabled|cheatsEnabled|checkAIFeature|checkVisibility|civilian|className|clear3DENAttribute|clear3DENInventory|clearAllItemsFromBackpack|clearBackpackCargo|clearBackpackCargoGlobal|clearForcesRTD|clearGroupIcons|clearItemCargo|clearItemCargoGlobal|clearItemPool|clearMagazineCargo|clearMagazineCargoGlobal|clearMagazinePool|clearOverlay|clearRadio|clearVehicleInit|clearWeaponCargo|clearWeaponCargoGlobal|clearWeaponPool|clientOwner|closeDialog|closeDisplay|closeOverlay|collapseObjectTree|collect3DENHistory|collectiveRTD|combatMode|commandArtilleryFire|commandChat|commander|commandFire|commandFollow|commandFSM|commandGetOut|commandingMenu|commandMove|commandRadio|commandStop|commandSuppressiveFire|commandTarget|commandWatch|comment|commitOverlay|compile|compileFinal|completedFSM|composeText|configClasses|configFile|configHierarchy|configName|configNull|configProperties|configSourceAddonList|configSourceMod|configSourceModList|confirmSensorTarget|connectTerminalToUAV|controlNull|controlsGroupCtrl|copyFromClipboard|copyToClipboard|copyWaypoints|cos|count|countEnemy|countFriendly|countSide|countType|countUnknown|create3DENComposition|create3DENEntity|createAgent|createCenter|createDialog|createDiaryLink|createDiaryRecord|createDiarySubject|createDisplay|createGearDialog|createGroup|createGuardedPoint|createLocation|createMarker|createMarkerLocal|createMenu|createMine|createMissionDisplay|createMPCampaignDisplay|createSimpleObject|createSimpleTask|createSite|createSoundSource|createTask|createTeam|createTrigger|createUnit|createVehicle|createVehicleCrew|createVehicleLocal|crew|ctAddHeader|ctAddRow|ctClear|ctCurSel|ctData|ctFindHeaderRows|ctFindRowHeader|ctHeaderControls|ctHeaderCount|ctRemoveHeaders|ctRemoveRows|ctrlActivate|ctrlAddEventHandler|ctrlAngle|ctrlAutoScrollDelay|ctrlAutoScrollRewind|ctrlAutoScrollSpeed|ctrlChecked|ctrlClassName|ctrlCommit|ctrlCommitted|ctrlCreate|ctrlDelete|ctrlEnable|ctrlEnabled|ctrlFade|ctrlHTMLLoaded|ctrlIDC|ctrlIDD|ctrlMapAnimAdd|ctrlMapAnimClear|ctrlMapAnimCommit|ctrlMapAnimDone|ctrlMapCursor|ctrlMapMouseOver|ctrlMapScale|ctrlMapScreenToWorld|ctrlMapWorldToScreen|ctrlModel|ctrlModelDirAndUp|ctrlModelScale|ctrlParent|ctrlParentControlsGroup|ctrlPosition|ctrlRemoveAllEventHandlers|ctrlRemoveEventHandler|ctrlScale|ctrlSetActiveColor|ctrlSetAngle|ctrlSetAutoScrollDelay|ctrlSetAutoScrollRewind|ctrlSetAutoScrollSpeed|ctrlSetBackgroundColor|ctrlSetChecked|ctrlSetDisabledColor|ctrlSetEventHandler|ctrlSetFade|ctrlSetFocus|ctrlSetFont|ctrlSetFontH1|ctrlSetFontH1B|ctrlSetFontH2|ctrlSetFontH2B|ctrlSetFontH3|ctrlSetFontH3B|ctrlSetFontH4|ctrlSetFontH4B|ctrlSetFontH5|ctrlSetFontH5B|ctrlSetFontH6|ctrlSetFontH6B|ctrlSetFontHeight|ctrlSetFontHeightH1|ctrlSetFontHeightH2|ctrlSetFontHeightH3|ctrlSetFontHeightH4|ctrlSetFontHeightH5|ctrlSetFontHeightH6|ctrlSetFontHeightSecondary|ctrlSetFontP|ctrlSetFontPB|ctrlSetFontSecondary|ctrlSetForegroundColor|ctrlSetModel|ctrlSetModelDirAndUp|ctrlSetModelScale|ctrlSetPixelPrecision|ctrlSetPosition|ctrlSetScale|ctrlSetStructuredText|ctrlSetText|ctrlSetTextColor|ctrlSetTextColorSecondary|ctrlSetTextSecondary|ctrlSetTooltip|ctrlSetTooltipColorBox|ctrlSetTooltipColorShade|ctrlSetTooltipColorText|ctrlShow|ctrlShown|ctrlText|ctrlTextHeight|ctrlTextSecondary|ctrlTextWidth|ctrlType|ctrlVisible|ctRowControls|ctRowCount|ctSetCurSel|ctSetData|ctSetHeaderTemplate|ctSetRowTemplate|ctSetValue|ctValue|curatorAddons|curatorCamera|curatorCameraArea|curatorCameraAreaCeiling|curatorCoef|curatorEditableObjects|curatorEditingArea|curatorEditingAreaType|curatorMouseOver|curatorPoints|curatorRegisteredObjects|curatorSelected|curatorWaypointCost|current3DENOperation|currentChannel|currentCommand|currentMagazine|currentMagazineDetail|currentMagazineDetailTurret|currentMagazineTurret|currentMuzzle|currentNamespace|currentTask|currentTasks|currentThrowable|currentVisionMode|currentWaypoint|currentWeapon|currentWeaponMode|currentWeaponTurret|currentZeroing|cursorObject|cursorTarget|customChat|customRadio|cutFadeOut|cutObj|cutRsc|cutText|damage|date|dateToNumber|daytime|deActivateKey|debriefingText|debugFSM|debugLog|deg|delete3DENEntities|deleteAt|deleteCenter|deleteCollection|deleteEditorObject|deleteGroup|deleteGroupWhenEmpty|deleteIdentity|deleteLocation|deleteMarker|deleteMarkerLocal|deleteRange|deleteResources|deleteSite|deleteStatus|deleteTeam|deleteVehicle|deleteVehicleCrew|deleteWaypoint|detach|detectedMines|diag_activeMissionFSMs|diag_activeScripts|diag_activeSQFScripts|diag_activeSQSScripts|diag_captureFrame|diag_captureFrameToFile|diag_captureSlowFrame|diag_codePerformance|diag_drawMode|diag_dynamicSimulationEnd|diag_enable|diag_enabled|diag_fps|diag_fpsMin|diag_frameNo|diag_lightNewLoad|diag_list|diag_log|diag_logSlowFrame|diag_mergeConfigFile|diag_recordTurretLimits|diag_setLightNew|diag_tickTime|diag_toggle|dialog|diarySubjectExists|didJIP|didJIPOwner|difficulty|difficultyEnabled|difficultyEnabledRTD|difficultyOption|direction|directSay|disableAI|disableCollisionWith|disableConversation|disableDebriefingStats|disableMapIndicators|disableNVGEquipment|disableRemoteSensors|disableSerialization|disableTIEquipment|disableUAVConnectability|disableUserInput|displayAddEventHandler|displayCtrl|displayNull|displayParent|displayRemoveAllEventHandlers|displayRemoveEventHandler|displaySetEventHandler|dissolveTeam|distance|distance2D|distanceSqr|distributionRegion|do3DENAction|doArtilleryFire|doFire|doFollow|doFSM|doGetOut|doMove|doorPhase|doStop|doSuppressiveFire|doTarget|doWatch|drawArrow|drawEllipse|drawIcon|drawIcon3D|drawLine|drawLine3D|drawLink|drawLocation|drawPolygon|drawRectangle|drawTriangle|driver|drop|dynamicSimulationDistance|dynamicSimulationDistanceCoef|dynamicSimulationEnabled|dynamicSimulationSystemEnabled|east|edit3DENMissionAttributes|editObject|editorSetEventHandler|effectiveCommander|emptyPositions|enableAI|enableAIFeature|enableAimPrecision|enableAttack|enableAudioFeature|enableAutoStartUpRTD|enableAutoTrimRTD|enableCamShake|enableCaustics|enableChannel|enableCollisionWith|enableCopilot|enableDebriefingStats|enableDiagLegend|enableDynamicSimulation|enableDynamicSimulationSystem|enableEndDialog|enableEngineArtillery|enableEnvironment|enableFatigue|enableGunLights|enableInfoPanelComponent|enableIRLasers|enableMimics|enablePersonTurret|enableRadio|enableReload|enableRopeAttach|enableSatNormalOnDetail|enableSaving|enableSentences|enableSimulation|enableSimulationGlobal|enableStamina|enableStressDamage|enableTeamSwitch|enableTraffic|enableUAVConnectability|enableUAVWaypoints|enableVehicleCargo|enableVehicleSensor|enableWeaponDisassembly|endl|endLoadingScreen|endMission|engineOn|enginesIsOnRTD|enginesPowerRTD|enginesRpmRTD|enginesTorqueRTD|entities|environmentEnabled|estimatedEndServerTime|estimatedTimeLeft|evalObjectArgument|everyBackpack|everyContainer|exec|execEditorScript|exp|expectedDestination|exportJIPMessages|eyeDirection|eyePos|face|faction|fadeMusic|fadeRadio|fadeSound|fadeSpeech|failMission|fillWeaponsFromPool|find|findCover|findDisplay|findEditorObject|findEmptyPosition|findEmptyPositionReady|findIf|findNearestEnemy|finishMissionInit|finite|fire|fireAtTarget|firstBackpack|flag|flagAnimationPhase|flagOwner|flagSide|flagTexture|fleeing|floor|flyInHeight|flyInHeightASL|fog|fogForecast|fogParams|forceAddUniform|forceAtPositionRTD|forcedMap|forceEnd|forceFlagTexture|forceFollowRoad|forceGeneratorRTD|forceMap|forceRespawn|forceSpeed|forceWalk|forceWeaponFire|forceWeatherChange|forgetTarget|format|formation|formationDirection|formationLeader|formationMembers|formationPosition|formationTask|formatText|formLeader|freeLook|fromEditor|fuel|fullCrew|gearIDCAmmoCount|gearSlotAmmoCount|gearSlotData|get3DENActionState|get3DENAttribute|get3DENCamera|get3DENConnections|get3DENEntity|get3DENEntityID|get3DENGrid|get3DENIconsVisible|get3DENLayerEntities|get3DENLinesVisible|get3DENMissionAttribute|get3DENMouseOver|get3DENSelected|getAimingCoef|getAllEnvSoundControllers|getAllHitPointsDamage|getAllOwnedMines|getAllSoundControllers|getAmmoCargo|getAnimAimPrecision|getAnimSpeedCoef|getArray|getArtilleryAmmo|getArtilleryComputerSettings|getArtilleryETA|getAssignedCuratorLogic|getAssignedCuratorUnit|getBackpackCargo|getBleedingRemaining|getBurningValue|getCameraViewDirection|getCargoIndex|getCenterOfMass|getClientState|getClientStateNumber|getCompatiblePylonMagazines|getConnectedUAV|getContainerMaxLoad|getCursorObjectParams|getCustomAimCoef|getDammage|getDescription|getDir|getDirVisual|getDLCAssetsUsage|getDLCAssetsUsageByName|getDLCs|getDLCUsageTime|getEditorCamera|getEditorMode|getEditorObjectScope|getElevationOffset|getEngineTargetRpmRTD|getEnvSoundController|getFatigue|getFieldManualStartPage|getForcedFlagTexture|getFriend|getFSMVariable|getFuelCargo|getGroupIcon|getGroupIconParams|getGroupIcons|getHideFrom|getHit|getHitIndex|getHitPointDamage|getItemCargo|getMagazineCargo|getMarkerColor|getMarkerPos|getMarkerSize|getMarkerType|getMass|getMissionConfig|getMissionConfigValue|getMissionDLCs|getMissionLayerEntities|getMissionLayers|getModelInfo|getMousePosition|getMusicPlayedTime|getNumber|getObjectArgument|getObjectChildren|getObjectDLC|getObjectMaterials|getObjectProxy|getObjectTextures|getObjectType|getObjectViewDistance|getOxygenRemaining|getPersonUsedDLCs|getPilotCameraDirection|getPilotCameraPosition|getPilotCameraRotation|getPilotCameraTarget|getPlateNumber|getPlayerChannel|getPlayerScores|getPlayerUID|getPlayerUIDOld|getPos|getPosASL|getPosASLVisual|getPosASLW|getPosATL|getPosATLVisual|getPosVisual|getPosWorld|getPylonMagazines|getRelDir|getRelPos|getRemoteSensorsDisabled|getRepairCargo|getResolution|getRotorBrakeRTD|getShadowDistance|getShotParents|getSlingLoad|getSoundController|getSoundControllerResult|getSpeed|getStamina|getStatValue|getSuppression|getTerrainGrid|getTerrainHeightASL|getText|getTotalDLCUsageTime|getTrimOffsetRTD|getUnitLoadout|getUnitTrait|getUserMFDText|getUserMFDValue|getVariable|getVehicleCargo|getWeaponCargo|getWeaponSway|getWingsOrientationRTD|getWingsPositionRTD|getWPPos|glanceAt|globalChat|globalRadio|goggles|group|groupChat|groupFromNetId|groupIconSelectable|groupIconsVisible|groupId|groupOwner|groupRadio|groupSelectedUnits|groupSelectUnit|grpNull|gunner|gusts|halt|handgunItems|handgunMagazine|handgunWeapon|handsHit|hasInterface|hasPilotCamera|hasWeapon|hcAllGroups|hcGroupParams|hcLeader|hcRemoveAllGroups|hcRemoveGroup|hcSelected|hcSelectGroup|hcSetGroup|hcShowBar|hcShownBar|headgear|hideBody|hideObject|hideObjectGlobal|hideSelection|hint|hintC|hintCadet|hintSilent|hmd|hostMission|htmlLoad|HUDMovementLevels|humidity|image|importAllGroups|importance|in|inArea|inAreaArray|incapacitatedState|independent|inflame|inflamed|infoPanel|infoPanelComponentEnabled|infoPanelComponents|infoPanels|inGameUISetEventHandler|inheritsFrom|initAmbientLife|inPolygon|inputAction|inRangeOfArtillery|insertEditorObject|intersect|is3DEN|is3DENMultiplayer|isAbleToBreathe|isAgent|isAimPrecisionEnabled|isArray|isAutoHoverOn|isAutonomous|isAutoStartUpEnabledRTD|isAutotest|isAutoTrimOnRTD|isBleeding|isBurning|isClass|isCollisionLightOn|isCopilotEnabled|isDamageAllowed|isDedicated|isDLCAvailable|isEngineOn|isEqualTo|isEqualType|isEqualTypeAll|isEqualTypeAny|isEqualTypeArray|isEqualTypeParams|isFilePatchingEnabled|isFlashlightOn|isFlatEmpty|isForcedWalk|isFormationLeader|isGroupDeletedWhenEmpty|isHidden|isInRemainsCollector|isInstructorFigureEnabled|isIRLaserOn|isKeyActive|isKindOf|isLaserOn|isLightOn|isLocalized|isManualFire|isMarkedForCollection|isMultiplayer|isMultiplayerSolo|isNil|isNull|isNumber|isObjectHidden|isObjectRTD|isOnRoad|isPipEnabled|isPlayer|isRealTime|isRemoteExecuted|isRemoteExecutedJIP|isServer|isShowing3DIcons|isSimpleObject|isSprintAllowed|isStaminaEnabled|isSteamMission|isStreamFriendlyUIEnabled|isStressDamageEnabled|isText|isTouchingGround|isTurnedOut|isTutHintsEnabled|isUAVConnectable|isUAVConnected|isUIContext|isUniformAllowed|isVehicleCargo|isVehicleRadarOn|isVehicleSensorEnabled|isWalking|isWeaponDeployed|isWeaponRested|itemCargo|items|itemsWithMagazines|join|joinAs|joinAsSilent|joinSilent|joinString|kbAddDatabase|kbAddDatabaseTargets|kbAddTopic|kbHasTopic|kbReact|kbRemoveTopic|kbTell|kbWasSaid|keyImage|keyName|knowsAbout|land|landAt|landResult|language|laserTarget|lbAdd|lbClear|lbColor|lbColorRight|lbCurSel|lbData|lbDelete|lbIsSelected|lbPicture|lbPictureRight|lbSelection|lbSetColor|lbSetColorRight|lbSetCurSel|lbSetData|lbSetPicture|lbSetPictureColor|lbSetPictureColorDisabled|lbSetPictureColorSelected|lbSetPictureRight|lbSetPictureRightColor|lbSetPictureRightColorDisabled|lbSetPictureRightColorSelected|lbSetSelectColor|lbSetSelectColorRight|lbSetSelected|lbSetText|lbSetTextRight|lbSetTooltip|lbSetValue|lbSize|lbSort|lbSortByValue|lbText|lbTextRight|lbValue|leader|leaderboardDeInit|leaderboardGetRows|leaderboardInit|leaderboardRequestRowsFriends|leaderboardRequestRowsGlobal|leaderboardRequestRowsGlobalAroundUser|leaderboardsRequestUploadScore|leaderboardsRequestUploadScoreKeepBest|leaderboardState|leaveVehicle|libraryCredits|libraryDisclaimers|lifeState|lightAttachObject|lightDetachObject|lightIsOn|lightnings|limitSpeed|linearConversion|lineBreak|lineIntersects|lineIntersectsObjs|lineIntersectsSurfaces|lineIntersectsWith|linkItem|list|listObjects|listRemoteTargets|listVehicleSensors|ln|lnbAddArray|lnbAddColumn|lnbAddRow|lnbClear|lnbColor|lnbColorRight|lnbCurSelRow|lnbData|lnbDeleteColumn|lnbDeleteRow|lnbGetColumnsPosition|lnbPicture|lnbPictureRight|lnbSetColor|lnbSetColorRight|lnbSetColumnsPos|lnbSetCurSelRow|lnbSetData|lnbSetPicture|lnbSetPictureColor|lnbSetPictureColorRight|lnbSetPictureColorSelected|lnbSetPictureColorSelectedRight|lnbSetPictureRight|lnbSetText|lnbSetTextRight|lnbSetValue|lnbSize|lnbSort|lnbSortByValue|lnbText|lnbTextRight|lnbValue|load|loadAbs|loadBackpack|loadFile|loadGame|loadIdentity|loadMagazine|loadOverlay|loadStatus|loadUniform|loadVest|local|localize|locationNull|locationPosition|lock|lockCameraTo|lockCargo|lockDriver|locked|lockedCargo|lockedDriver|lockedTurret|lockIdentity|lockTurret|lockWP|log|logEntities|logNetwork|logNetworkTerminate|lookAt|lookAtPos|magazineCargo|magazines|magazinesAllTurrets|magazinesAmmo|magazinesAmmoCargo|magazinesAmmoFull|magazinesDetail|magazinesDetailBackpack|magazinesDetailUniform|magazinesDetailVest|magazinesTurret|magazineTurretAmmo|mapAnimAdd|mapAnimClear|mapAnimCommit|mapAnimDone|mapCenterOnCamera|mapGridPosition|markAsFinishedOnSteam|markerAlpha|markerBrush|markerColor|markerDir|markerPos|markerShape|markerSize|markerText|markerType|max|members|menuAction|menuAdd|menuChecked|menuClear|menuCollapse|menuData|menuDelete|menuEnable|menuEnabled|menuExpand|menuHover|menuPicture|menuSetAction|menuSetCheck|menuSetData|menuSetPicture|menuSetValue|menuShortcut|menuShortcutText|menuSize|menuSort|menuText|menuURL|menuValue|min|mineActive|mineDetectedBy|missionConfigFile|missionDifficulty|missionName|missionNamespace|missionStart|missionVersion|modelToWorld|modelToWorldVisual|modelToWorldVisualWorld|modelToWorldWorld|modParams|moonIntensity|moonPhase|morale|move|move3DENCamera|moveInAny|moveInCargo|moveInCommander|moveInDriver|moveInGunner|moveInTurret|moveObjectToEnd|moveOut|moveTime|moveTo|moveToCompleted|moveToFailed|musicVolume|name|nameSound|nearEntities|nearestBuilding|nearestLocation|nearestLocations|nearestLocationWithDubbing|nearestObject|nearestObjects|nearestTerrainObjects|nearObjects|nearObjectsReady|nearRoads|nearSupplies|nearTargets|needReload|netId|netObjNull|newOverlay|nextMenuItemIndex|nextWeatherChange|nMenuItems|numberOfEnginesRTD|numberToDate|objectCurators|objectFromNetId|objectParent|objNull|objStatus|onBriefingGear|onBriefingGroup|onBriefingNotes|onBriefingPlan|onBriefingTeamSwitch|onCommandModeChanged|onDoubleClick|onEachFrame|onGroupIconClick|onGroupIconOverEnter|onGroupIconOverLeave|onHCGroupSelectionChanged|onMapSingleClick|onPlayerConnected|onPlayerDisconnected|onPreloadFinished|onPreloadStarted|onShowNewObject|onTeamSwitch|openCuratorInterface|openDLCPage|openDSInterface|openMap|openSteamApp|openYoutubeVideo|opfor|orderGetIn|overcast|overcastForecast|owner|param|params|parseNumber|parseSimpleArray|parseText|parsingNamespace|particlesQuality|pi|pickWeaponPool|pitch|pixelGrid|pixelGridBase|pixelGridNoUIScale|pixelH|pixelW|playableSlotsNumber|playableUnits|playAction|playActionNow|player|playerRespawnTime|playerSide|playersNumber|playGesture|playMission|playMove|playMoveNow|playMusic|playScriptedMission|playSound|playSound3D|position|positionCameraToWorld|posScreenToWorld|posWorldToScreen|ppEffectAdjust|ppEffectCommit|ppEffectCommitted|ppEffectCreate|ppEffectDestroy|ppEffectEnable|ppEffectEnabled|ppEffectForceInNVG|precision|preloadCamera|preloadObject|preloadSound|preloadTitleObj|preloadTitleRsc|primaryWeapon|primaryWeaponItems|primaryWeaponMagazine|priority|processDiaryLink|processInitCommands|productVersion|profileName|profileNamespace|profileNameSteam|progressLoadingScreen|progressPosition|progressSetPosition|publicVariable|publicVariableClient|publicVariableServer|pushBack|pushBackUnique|putWeaponPool|queryItemsPool|queryMagazinePool|queryWeaponPool|rad|radioChannelAdd|radioChannelCreate|radioChannelRemove|radioChannelSetCallSign|radioChannelSetLabel|radioVolume|rain|rainbow|random|rank|rankId|rating|rectangular|registeredTasks|registerTask|reload|reloadEnabled|remoteControl|remoteExec|remoteExecCall|remoteExecutedOwner|remove3DENConnection|remove3DENEventHandler|remove3DENLayer|removeAction|removeAll3DENEventHandlers|removeAllActions|removeAllAssignedItems|removeAllContainers|removeAllCuratorAddons|removeAllCuratorCameraAreas|removeAllCuratorEditingAreas|removeAllEventHandlers|removeAllHandgunItems|removeAllItems|removeAllItemsWithMagazines|removeAllMissionEventHandlers|removeAllMPEventHandlers|removeAllMusicEventHandlers|removeAllOwnedMines|removeAllPrimaryWeaponItems|removeAllWeapons|removeBackpack|removeBackpackGlobal|removeCuratorAddons|removeCuratorCameraArea|removeCuratorEditableObjects|removeCuratorEditingArea|removeDrawIcon|removeDrawLinks|removeEventHandler|removeFromRemainsCollector|removeGoggles|removeGroupIcon|removeHandgunItem|removeHeadgear|removeItem|removeItemFromBackpack|removeItemFromUniform|removeItemFromVest|removeItems|removeMagazine|removeMagazineGlobal|removeMagazines|removeMagazinesTurret|removeMagazineTurret|removeMenuItem|removeMissionEventHandler|removeMPEventHandler|removeMusicEventHandler|removeOwnedMine|removePrimaryWeaponItem|removeSecondaryWeaponItem|removeSimpleTask|removeSwitchableUnit|removeTeamMember|removeUniform|removeVest|removeWeapon|removeWeaponAttachmentCargo|removeWeaponCargo|removeWeaponGlobal|removeWeaponTurret|reportRemoteTarget|requiredVersion|resetCamShake|resetSubgroupDirection|resistance|resize|resources|respawnVehicle|restartEditorCamera|reveal|revealMine|reverse|reversedMouseY|roadAt|roadsConnectedTo|roleDescription|ropeAttachedObjects|ropeAttachedTo|ropeAttachEnabled|ropeAttachTo|ropeCreate|ropeCut|ropeDestroy|ropeDetach|ropeEndPosition|ropeLength|ropes|ropeUnwind|ropeUnwound|rotorsForcesRTD|rotorsRpmRTD|round|runInitScript|safeZoneH|safeZoneW|safeZoneWAbs|safeZoneX|safeZoneXAbs|safeZoneY|save3DENInventory|saveGame|saveIdentity|saveJoysticks|saveOverlay|saveProfileNamespace|saveStatus|saveVar|savingEnabled|say|say2D|say3D|score|scoreSide|screenshot|screenToWorld|scriptDone|scriptName|scriptNull|scudState|secondaryWeapon|secondaryWeaponItems|secondaryWeaponMagazine|select|selectBestPlaces|selectDiarySubject|selectedEditorObjects|selectEditorObject|selectionNames|selectionPosition|selectLeader|selectMax|selectMin|selectNoPlayer|selectPlayer|selectRandom|selectRandomWeighted|selectWeapon|selectWeaponTurret|sendAUMessage|sendSimpleCommand|sendTask|sendTaskResult|sendUDPMessage|serverCommand|serverCommandAvailable|serverCommandExecutable|serverName|serverTime|set|set3DENAttribute|set3DENAttributes|set3DENGrid|set3DENIconsVisible|set3DENLayer|set3DENLinesVisible|set3DENLogicType|set3DENMissionAttribute|set3DENMissionAttributes|set3DENModelsVisible|set3DENObjectType|set3DENSelected|setAccTime|setActualCollectiveRTD|setAirplaneThrottle|setAirportSide|setAmmo|setAmmoCargo|setAmmoOnPylon|setAnimSpeedCoef|setAperture|setApertureNew|setArmoryPoints|setAttributes|setAutonomous|setBehaviour|setBleedingRemaining|setBrakesRTD|setCameraInterest|setCamShakeDefParams|setCamShakeParams|setCamUseTI|setCaptive|setCenterOfMass|setCollisionLight|setCombatMode|setCompassOscillation|setConvoySeparation|setCuratorCameraAreaCeiling|setCuratorCoef|setCuratorEditingAreaType|setCuratorWaypointCost|setCurrentChannel|setCurrentTask|setCurrentWaypoint|setCustomAimCoef|setCustomWeightRTD|setDamage|setDammage|setDate|setDebriefingText|setDefaultCamera|setDestination|setDetailMapBlendPars|setDir|setDirection|setDrawIcon|setDriveOnPath|setDropInterval|setDynamicSimulationDistance|setDynamicSimulationDistanceCoef|setEditorMode|setEditorObjectScope|setEffectCondition|setEngineRpmRTD|setFace|setFaceAnimation|setFatigue|setFeatureType|setFlagAnimationPhase|setFlagOwner|setFlagSide|setFlagTexture|setFog|setForceGeneratorRTD|setFormation|setFormationTask|setFormDir|setFriend|setFromEditor|setFSMVariable|setFuel|setFuelCargo|setGroupIcon|setGroupIconParams|setGroupIconsSelectable|setGroupIconsVisible|setGroupId|setGroupIdGlobal|setGroupOwner|setGusts|setHideBehind|setHit|setHitIndex|setHitPointDamage|setHorizonParallaxCoef|setHUDMovementLevels|setIdentity|setImportance|setInfoPanel|setLeader|setLightAmbient|setLightAttenuation|setLightBrightness|setLightColor|setLightDayLight|setLightFlareMaxDistance|setLightFlareSize|setLightIntensity|setLightnings|setLightUseFlare|setLocalWindParams|setMagazineTurretAmmo|setMarkerAlpha|setMarkerAlphaLocal|setMarkerBrush|setMarkerBrushLocal|setMarkerColor|setMarkerColorLocal|setMarkerDir|setMarkerDirLocal|setMarkerPos|setMarkerPosLocal|setMarkerShape|setMarkerShapeLocal|setMarkerSize|setMarkerSizeLocal|setMarkerText|setMarkerTextLocal|setMarkerType|setMarkerTypeLocal|setMass|setMimic|setMousePosition|setMusicEffect|setMusicEventHandler|setName|setNameSound|setObjectArguments|setObjectMaterial|setObjectMaterialGlobal|setObjectProxy|setObjectTexture|setObjectTextureGlobal|setObjectViewDistance|setOvercast|setOwner|setOxygenRemaining|setParticleCircle|setParticleClass|setParticleFire|setParticleParams|setParticleRandom|setPilotCameraDirection|setPilotCameraRotation|setPilotCameraTarget|setPilotLight|setPiPEffect|setPitch|setPlateNumber|setPlayable|setPlayerRespawnTime|setPos|setPosASL|setPosASL2|setPosASLW|setPosATL|setPosition|setPosWorld|setPylonLoadOut|setPylonsPriority|setRadioMsg|setRain|setRainbow|setRandomLip|setRank|setRectangular|setRepairCargo|setRotorBrakeRTD|setShadowDistance|setShotParents|setSide|setSimpleTaskAlwaysVisible|setSimpleTaskCustomData|setSimpleTaskDescription|setSimpleTaskDestination|setSimpleTaskTarget|setSimpleTaskType|setSimulWeatherLayers|setSize|setSkill|setSlingLoad|setSoundEffect|setSpeaker|setSpeech|setSpeedMode|setStamina|setStaminaScheme|setStatValue|setSuppression|setSystemOfUnits|setTargetAge|setTaskMarkerOffset|setTaskResult|setTaskState|setTerrainGrid|setText|setTimeMultiplier|setTitleEffect|setToneMapping|setToneMappingParams|setTrafficDensity|setTrafficDistance|setTrafficGap|setTrafficSpeed|setTriggerActivation|setTriggerArea|setTriggerStatements|setTriggerText|setTriggerTimeout|setTriggerType|setType|setUnconscious|setUnitAbility|setUnitLoadout|setUnitPos|setUnitPosWeak|setUnitRank|setUnitRecoilCoefficient|setUnitTrait|setUnloadInCombat|setUserActionText|setUserMFDText|setUserMFDValue|setVariable|setVectorDir|setVectorDirAndUp|setVectorUp|setVehicleAmmo|setVehicleAmmoDef|setVehicleArmor|setVehicleCargo|setVehicleId|setVehicleInit|setVehicleLock|setVehiclePosition|setVehicleRadar|setVehicleReceiveRemoteTargets|setVehicleReportOwnPosition|setVehicleReportRemoteTargets|setVehicleTIPars|setVehicleVarName|setVelocity|setVelocityModelSpace|setVelocityTransformation|setViewDistance|setVisibleIfTreeCollapsed|setWantedRpmRTD|setWaves|setWaypointBehaviour|setWaypointCombatMode|setWaypointCompletionRadius|setWaypointDescription|setWaypointForceBehaviour|setWaypointFormation|setWaypointHousePosition|setWaypointLoiterRadius|setWaypointLoiterType|setWaypointName|setWaypointPosition|setWaypointScript|setWaypointSpeed|setWaypointStatements|setWaypointTimeout|setWaypointType|setWaypointVisible|setWeaponReloadingTime|setWind|setWindDir|setWindForce|setWindStr|setWingForceScaleRTD|setWPPos|show3DIcons|showChat|showCinemaBorder|showCommandingMenu|showCompass|showCuratorCompass|showGPS|showHUD|showLegend|showMap|shownArtilleryComputer|shownChat|shownCompass|shownCuratorCompass|showNewEditorObject|shownGPS|shownHUD|shownMap|shownPad|shownRadio|shownScoretable|shownUAVFeed|shownWarrant|shownWatch|showPad|showRadio|showScoretable|showSubtitles|showUAVFeed|showWarrant|showWatch|showWaypoint|showWaypoints|side|sideAmbientLife|sideChat|sideEmpty|sideEnemy|sideFriendly|sideLogic|sideRadio|sideUnknown|simpleTasks|simulationEnabled|simulCloudDensity|simulCloudOcclusion|simulInClouds|simulWeatherSync|sin|size|sizeOf|skill|skillFinal|skipTime|sleep|sliderPosition|sliderRange|sliderSetPosition|sliderSetRange|sliderSetSpeed|sliderSpeed|slingLoadAssistantShown|soldierMagazines|someAmmo|sort|soundVolume|speaker|speed|speedMode|splitString|sqrt|squadParams|stance|startLoadingScreen|stop|stopEngineRTD|stopped|str|sunOrMoon|supportInfo|suppressFor|surfaceIsWater|surfaceNormal|surfaceType|swimInDepth|switchableUnits|switchAction|switchCamera|switchGesture|switchLight|switchMove|synchronizedObjects|synchronizedTriggers|synchronizedWaypoints|synchronizeObjectsAdd|synchronizeObjectsRemove|synchronizeTrigger|synchronizeWaypoint|systemChat|systemOfUnits|tan|targetKnowledge|targets|targetsAggregate|targetsQuery|taskAlwaysVisible|taskChildren|taskCompleted|taskCustomData|taskDescription|taskDestination|taskHint|taskMarkerOffset|taskNull|taskParent|taskResult|taskState|taskType|teamMember|teamMemberNull|teamName|teams|teamSwitch|teamSwitchEnabled|teamType|terminate|terrainIntersect|terrainIntersectASL|terrainIntersectAtASL|text|textLog|textLogFormat|tg|time|timeMultiplier|titleCut|titleFadeOut|titleObj|titleRsc|titleText|toArray|toFixed|toLower|toString|toUpper|triggerActivated|triggerActivation|triggerArea|triggerAttachedVehicle|triggerAttachObject|triggerAttachVehicle|triggerDynamicSimulation|triggerStatements|triggerText|triggerTimeout|triggerTimeoutCurrent|triggerType|turretLocal|turretOwner|turretUnit|tvAdd|tvClear|tvCollapse|tvCollapseAll|tvCount|tvCurSel|tvData|tvDelete|tvExpand|tvExpandAll|tvPicture|tvPictureRight|tvSetColor|tvSetCurSel|tvSetData|tvSetPicture|tvSetPictureColor|tvSetPictureColorDisabled|tvSetPictureColorSelected|tvSetPictureRight|tvSetPictureRightColor|tvSetPictureRightColorDisabled|tvSetPictureRightColorSelected|tvSetSelectColor|tvSetText|tvSetTooltip|tvSetValue|tvSort|tvSortByValue|tvText|tvTooltip|tvValue|type|typeName|typeOf|UAVControl|uiNamespace|uiSleep|unassignCurator|unassignItem|unassignTeam|unassignVehicle|underwater|uniform|uniformContainer|uniformItems|uniformMagazines|unitAddons|unitAimPosition|unitAimPositionVisual|unitBackpack|unitIsUAV|unitPos|unitReady|unitRecoilCoefficient|units|unitsBelowHeight|unlinkItem|unlockAchievement|unregisterTask|updateDrawIcon|updateMenuItem|updateObjectTree|useAIOperMapObstructionTest|useAISteeringComponent|useAudioTimeForMoves|userInputDisabled|vectorAdd|vectorCos|vectorCrossProduct|vectorDiff|vectorDir|vectorDirVisual|vectorDistance|vectorDistanceSqr|vectorDotProduct|vectorFromTo|vectorMagnitude|vectorMagnitudeSqr|vectorModelToWorld|vectorModelToWorldVisual|vectorMultiply|vectorNormalized|vectorUp|vectorUpVisual|vectorWorldToModel|vectorWorldToModelVisual|vehicle|vehicleCargoEnabled|vehicleChat|vehicleRadio|vehicleReceiveRemoteTargets|vehicleReportOwnPosition|vehicleReportRemoteTargets|vehicles|vehicleVarName|velocity|velocityModelSpace|verifySignature|vest|vestContainer|vestItems|vestMagazines|viewDistance|visibleCompass|visibleGPS|visibleMap|visiblePosition|visiblePositionASL|visibleScoretable|visibleWatch|waitUntil|waves|waypointAttachedObject|waypointAttachedVehicle|waypointAttachObject|waypointAttachVehicle|waypointBehaviour|waypointCombatMode|waypointCompletionRadius|waypointDescription|waypointForceBehaviour|waypointFormation|waypointHousePosition|waypointLoiterRadius|waypointLoiterType|waypointName|waypointPosition|waypoints|waypointScript|waypointsEnabledUAV|waypointShow|waypointSpeed|waypointStatements|waypointTimeout|waypointTimeoutCurrent|waypointType|waypointVisible|weaponAccessories|weaponAccessoriesCargo|weaponCargo|weaponDirection|weaponInertia|weaponLowered|weapons|weaponsItems|weaponsItemsCargo|weaponState|weaponsTurret|weightRTD|west|WFSideText|wind|windDir|windRTD|windStr|wingsForcesRTD|worldName|worldSize|worldToModel|worldToModelVisual|worldToScreen)\b/i,
        number: /(?:\$|\b0x)[\da-f]+\b|(?:\B\.\d+|\b\d+(?:\.\d+)?)(?:e[+-]?\d+)?\b/i,
        operator: /##|>>|&&|\|\||[!=<>]=?|[-+*/%#^]|\b(?:and|mod|not|or)\b/i,
        "magic-variable": {
            pattern: /\b(?:this|thisList|thisTrigger|_exception|_fnc_scriptName|_fnc_scriptNameParent|_forEachIndex|_this|_thisEventHandler|_thisFSM|_thisScript|_x)\b/i,
            alias: "keyword"
        },
        constant: /\bDIK(?:_[a-z\d]+)+\b/i
    });
    Prism.languages.insertBefore("sqf", "string", {
        macro: {
            pattern: /(^[ \t]*)#[a-z](?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
            lookbehind: true,
            greedy: true,
            alias: "property",
            inside: {
                directive: {
                    pattern: /#[a-z]+\b/i,
                    alias: "keyword"
                },
                comment: Prism.languages.sqf.comment
            }
        }
    });
    delete Prism.languages.sqf["class-name"];
}

});

parcelRequire.register("gPT25", function(module, exports) {
"use strict";
module.exports = $c41c1919b5f84db2$var$squirrel;
$c41c1919b5f84db2$var$squirrel.displayName = "squirrel";
$c41c1919b5f84db2$var$squirrel.aliases = [];
function $c41c1919b5f84db2$var$squirrel(Prism) {
    Prism.languages.squirrel = Prism.languages.extend("clike", {
        comment: [
            Prism.languages.clike["comment"][0],
            {
                pattern: /(^|[^\\:])(?:\/\/|#).*/,
                lookbehind: true,
                greedy: true
            }
        ],
        string: {
            pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
            lookbehind: true,
            greedy: true
        },
        "class-name": {
            pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
            lookbehind: true,
            inside: {
                punctuation: /\./
            }
        },
        keyword: /\b(?:__FILE__|__LINE__|base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield)\b/,
        number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
        operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
        punctuation: /[(){}\[\],;.]/
    });
    Prism.languages.insertBefore("squirrel", "string", {
        char: {
            pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
            lookbehind: true,
            greedy: true
        }
    });
    Prism.languages.insertBefore("squirrel", "operator", {
        "attribute-punctuation": {
            pattern: /<\/|\/>/,
            alias: "important"
        },
        lambda: {
            pattern: /@(?=\()/,
            alias: "operator"
        }
    });
}

});

parcelRequire.register("9XxMv", function(module, exports) {
"use strict";
module.exports = $7403d40352192e8a$var$stan;
$7403d40352192e8a$var$stan.displayName = "stan";
$7403d40352192e8a$var$stan.aliases = [];
function $7403d40352192e8a$var$stan(Prism1) {
    (function(Prism) {
        // https://mc-stan.org/docs/2_28/reference-manual/bnf-grammars.html
        var higherOrderFunctions = /\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
        Prism.languages.stan = {
            comment: /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
            string: {
                // String literals can contain spaces and any printable ASCII characters except for " and \
                // https://mc-stan.org/docs/2_24/reference-manual/print-statements-section.html#string-literals
                pattern: /"[\x20\x21\x23-\x5B\x5D-\x7E]*"/,
                greedy: true
            },
            directive: {
                pattern: /^([ \t]*)#include\b.*/m,
                lookbehind: true,
                alias: "property"
            },
            "function-arg": {
                pattern: RegExp("(" + higherOrderFunctions.source + /\s*\(\s*/.source + ")" + /[a-zA-Z]\w*/.source),
                lookbehind: true,
                alias: "function"
            },
            constraint: {
                pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
                lookbehind: true,
                inside: {
                    expression: {
                        pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
                        lookbehind: true,
                        inside: null // see below
                    },
                    property: /\b[a-z]\w*(?=\s*=)/i,
                    operator: /=/,
                    punctuation: /^<|>$|,/
                }
            },
            keyword: [
                {
                    pattern: /\bdata(?=\s*\{)|\b(?:functions|generated|model|parameters|quantities|transformed)\b/,
                    alias: "program-block"
                },
                /\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\b/,
                higherOrderFunctions
            ],
            function: /\b[a-z]\w*(?=\s*\()/i,
            number: /(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:E[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
            boolean: /\b(?:false|true)\b/,
            operator: /<-|\.[*/]=?|\|\|?|&&|[!=<>+\-*/]=?|['^%~?:]/,
            punctuation: /[()\[\]{},;]/
        };
        Prism.languages.stan.constraint.inside.expression.inside = Prism.languages.stan;
    })(Prism1);
}

});

parcelRequire.register("6dZVI", function(module, exports) {
"use strict";
module.exports = $4883fef38dda3476$var$stylus;
$4883fef38dda3476$var$stylus.displayName = "stylus";
$4883fef38dda3476$var$stylus.aliases = [];
function $4883fef38dda3476$var$stylus(Prism1) {
    (function(Prism) {
        var unit = {
            pattern: /(\b\d+)(?:%|[a-z]+)/,
            lookbehind: true
        } // 123 -123 .123 -.123 12.3 -12.3
        ;
        var number = {
            pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
            lookbehind: true
        };
        var inside = {
            comment: {
                pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
                lookbehind: true
            },
            url: {
                pattern: /\burl\((["']?).*?\1\)/i,
                greedy: true
            },
            string: {
                pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
                greedy: true
            },
            interpolation: null,
            // See below
            func: null,
            // See below
            important: /\B!(?:important|optional)\b/i,
            keyword: {
                pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
                lookbehind: true
            },
            hexcode: /#[\da-f]{3,6}/i,
            color: [
                /\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
                {
                    pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
                    inside: {
                        unit: unit,
                        number: number,
                        function: /[\w-]+(?=\()/,
                        punctuation: /[(),]/
                    }
                }
            ],
            entity: /\\[\da-f]{1,8}/i,
            unit: unit,
            boolean: /\b(?:false|true)\b/,
            operator: [
                // We want non-word chars around "-" because it is
                // accepted in property names.
                /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
            ],
            number: number,
            punctuation: /[{}()\[\];:,]/
        };
        inside["interpolation"] = {
            pattern: /\{[^\r\n}:]+\}/,
            alias: "variable",
            inside: {
                delimiter: {
                    pattern: /^\{|\}$/,
                    alias: "punctuation"
                },
                rest: inside
            }
        };
        inside["func"] = {
            pattern: /[\w-]+\([^)]*\).*/,
            inside: {
                function: /^[^(]+/,
                rest: inside
            }
        };
        Prism.languages.stylus = {
            "atrule-declaration": {
                pattern: /(^[ \t]*)@.+/m,
                lookbehind: true,
                inside: {
                    atrule: /^@[\w-]+/,
                    rest: inside
                }
            },
            "variable-declaration": {
                pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
                lookbehind: true,
                inside: {
                    variable: /^\S+/,
                    rest: inside
                }
            },
            statement: {
                pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
                lookbehind: true,
                inside: {
                    keyword: /^\S+/,
                    rest: inside
                }
            },
            // A property/value pair cannot end with a comma or a brace
            // It cannot have indented content unless it ended with a semicolon
            "property-declaration": {
                pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
                lookbehind: true,
                inside: {
                    property: {
                        pattern: /^[^\s:]+/,
                        inside: {
                            interpolation: inside.interpolation
                        }
                    },
                    rest: inside
                }
            },
            // A selector can contain parentheses only as part of a pseudo-element
            // It can span multiple lines.
            // It must end with a comma or an accolade or have indented content.
            selector: {
                pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
                lookbehind: true,
                inside: {
                    interpolation: inside.interpolation,
                    comment: inside.comment,
                    punctuation: /[{},]/
                }
            },
            func: inside.func,
            string: inside.string,
            comment: {
                pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
                lookbehind: true,
                greedy: true
            },
            interpolation: inside.interpolation,
            punctuation: /[{}()\[\];:.]/
        };
    })(Prism1);
}

});

parcelRequire.register("cQCVq", function(module, exports) {
"use strict";
module.exports = $0269f1b205691ae5$var$swift;
$0269f1b205691ae5$var$swift.displayName = "swift";
$0269f1b205691ae5$var$swift.aliases = [];
function $0269f1b205691ae5$var$swift(Prism) {
    Prism.languages.swift = {
        comment: {
            // Nested comments are supported up to 2 levels
            pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
            lookbehind: true,
            greedy: true
        },
        "string-literal": [
            // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
            {
                pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source),
                lookbehind: true,
                greedy: true,
                inside: {
                    interpolation: {
                        pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
                        lookbehind: true,
                        inside: null // see below
                    },
                    "interpolation-punctuation": {
                        pattern: /^\)|\\\($/,
                        alias: "punctuation"
                    },
                    punctuation: /\\(?=[\r\n])/,
                    string: /[\s\S]+/
                }
            },
            {
                pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")" + "\\2"),
                lookbehind: true,
                greedy: true,
                inside: {
                    interpolation: {
                        pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
                        lookbehind: true,
                        inside: null // see below
                    },
                    "interpolation-punctuation": {
                        pattern: /^\)|\\#+\($/,
                        alias: "punctuation"
                    },
                    string: /[\s\S]+/
                }
            }
        ],
        directive: {
            // directives with conditions
            pattern: RegExp(/#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + //   (?:![ \t]*)?(?:\b\w+\b(?:[ \t]*<round>)?|<round>)(?:[ \t]*(?:&&|\|\|))?
            // where <round> is a general parentheses expression.
            /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"),
            alias: "property",
            inside: {
                "directive-name": /^#\w+/,
                boolean: /\b(?:false|true)\b/,
                number: /\b\d+(?:\.\d+)*\b/,
                operator: /!|&&|\|\||[<>]=?/,
                punctuation: /[(),]/
            }
        },
        literal: {
            pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
            alias: "constant"
        },
        "other-directive": {
            pattern: /#\w+\b/,
            alias: "property"
        },
        attribute: {
            pattern: /@\w+/,
            alias: "atrule"
        },
        "function-definition": {
            pattern: /(\bfunc\s+)\w+/,
            lookbehind: true,
            alias: "function"
        },
        label: {
            // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
            pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
            lookbehind: true,
            alias: "important"
        },
        keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
        boolean: /\b(?:false|true)\b/,
        nil: {
            pattern: /\bnil\b/,
            alias: "constant"
        },
        "short-argument": /\$\d+\b/,
        omit: {
            pattern: /\b_\b/,
            alias: "keyword"
        },
        number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
        // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
        "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
        // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
        // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
        // This regex only supports ASCII operators.
        operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
        punctuation: /[{}[\]();,.:\\]/
    };
    Prism.languages.swift["string-literal"].forEach(function(rule) {
        rule.inside["interpolation"].inside = Prism.languages.swift;
    });
}

});

parcelRequire.register("4GsZj", function(module, exports) {
"use strict";
module.exports = $36919213a4190d1d$var$systemd;
$36919213a4190d1d$var$systemd.displayName = "systemd";
$36919213a4190d1d$var$systemd.aliases = [];
function $36919213a4190d1d$var$systemd(Prism1) {
    (function(Prism) {
        var comment = {
            pattern: /^[;#].*/m,
            greedy: true
        };
        var quotesSource = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
        Prism.languages.systemd = {
            comment: comment,
            section: {
                pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
                greedy: true,
                inside: {
                    punctuation: /^\[|\]$/,
                    "section-name": {
                        pattern: /[\s\S]+/,
                        alias: "selector"
                    }
                }
            },
            key: {
                pattern: /^[^\s=]+(?=[ \t]*=)/m,
                greedy: true,
                alias: "attr-name"
            },
            value: {
                // This pattern is quite complex because of two properties:
                //  1) Quotes (strings) must be preceded by a space. Since we can't use lookbehinds, we have to "resolve"
                //     the lookbehind. You will see this in the main loop where spaces are handled separately.
                //  2) Line continuations.
                //     After line continuations, empty lines and comments are ignored so we have to consume them.
                pattern: RegExp(/(=[ \t]*(?!\s))/.source + "(?:" + quotesSource + '|(?=[^"\r\n]))' + "(?:" + (/[^\s\\]/.source + "|" + '[ 	]+(?:(?![ 	"])|' + quotesSource + ")" + "|" + /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source) + ")*"),
                lookbehind: true,
                greedy: true,
                alias: "attr-value",
                inside: {
                    comment: comment,
                    quoted: {
                        pattern: RegExp(/(^|\s)/.source + quotesSource),
                        lookbehind: true,
                        greedy: true
                    },
                    punctuation: /\\$/m,
                    boolean: {
                        pattern: /^(?:false|no|off|on|true|yes)$/,
                        greedy: true
                    }
                }
            },
            punctuation: /=/
        };
    })(Prism1);
}

});

parcelRequire.register("cXo0G", function(module, exports) {
"use strict";

var $bNRXQ = parcelRequire("bNRXQ");

var $jcO3t = parcelRequire("jcO3t");
module.exports = $96ed9ea03fc13d40$var$t4Cs;
$96ed9ea03fc13d40$var$t4Cs.displayName = "t4Cs";
$96ed9ea03fc13d40$var$t4Cs.aliases = [];
function $96ed9ea03fc13d40$var$t4Cs(Prism) {
    Prism.register($bNRXQ);
    Prism.register($jcO3t);
    Prism.languages.t4 = Prism.languages["t4-cs"] = Prism.languages["t4-templating"].createT4("csharp");
}

});
parcelRequire.register("bNRXQ", function(module, exports) {
"use strict";
module.exports = $897e217f37fbc8ec$var$t4Templating;
$897e217f37fbc8ec$var$t4Templating.displayName = "t4Templating";
$897e217f37fbc8ec$var$t4Templating.aliases = [];
function $897e217f37fbc8ec$var$t4Templating(Prism1) {
    (function(Prism) {
        function createBlock(prefix, inside, contentAlias) {
            return {
                pattern: RegExp("<#" + prefix + "[\\s\\S]*?#>"),
                alias: "block",
                inside: {
                    delimiter: {
                        pattern: RegExp("^<#" + prefix + "|#>$"),
                        alias: "important"
                    },
                    content: {
                        pattern: /[\s\S]+/,
                        inside: inside,
                        alias: contentAlias
                    }
                }
            };
        }
        function createT4(insideLang) {
            var grammar = Prism.languages[insideLang];
            var className = "language-" + insideLang;
            return {
                block: {
                    pattern: /<#[\s\S]+?#>/,
                    inside: {
                        directive: createBlock("@", {
                            "attr-value": {
                                pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
                                inside: {
                                    punctuation: /^=|^["']|["']$/
                                }
                            },
                            keyword: /\b\w+(?=\s)/,
                            "attr-name": /\b\w+/
                        }),
                        expression: createBlock("=", grammar, className),
                        "class-feature": createBlock("\\+", grammar, className),
                        standard: createBlock("", grammar, className)
                    }
                }
            };
        }
        Prism.languages["t4-templating"] = Object.defineProperty({}, "createT4", {
            value: createT4
        });
    })(Prism1);
}

});


parcelRequire.register("2E3aL", function(module, exports) {
"use strict";

var $bNRXQ = parcelRequire("bNRXQ");

var $60WOi = parcelRequire("60WOi");
module.exports = $1ed1c739766f5cdd$var$t4Vb;
$1ed1c739766f5cdd$var$t4Vb.displayName = "t4Vb";
$1ed1c739766f5cdd$var$t4Vb.aliases = [];
function $1ed1c739766f5cdd$var$t4Vb(Prism) {
    Prism.register($bNRXQ);
    Prism.register($60WOi);
    Prism.languages["t4-vb"] = Prism.languages["t4-templating"].createT4("vbnet");
}

});
parcelRequire.register("60WOi", function(module, exports) {
"use strict";

var $8M8zk = parcelRequire("8M8zk");
module.exports = $46105ca79563328d$var$vbnet;
$46105ca79563328d$var$vbnet.displayName = "vbnet";
$46105ca79563328d$var$vbnet.aliases = [];
function $46105ca79563328d$var$vbnet(Prism) {
    Prism.register($8M8zk);
    Prism.languages.vbnet = Prism.languages.extend("basic", {
        comment: [
            {
                pattern: /(?:!|REM\b).+/i,
                inside: {
                    keyword: /^REM/i
                }
            },
            {
                pattern: /(^|[^\\:])'.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        string: {
            pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
            lookbehind: true,
            greedy: true
        },
        keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
        punctuation: /[,;:(){}]/
    });
}

});


parcelRequire.register("7QNW1", function(module, exports) {
"use strict";

var $fPZa6 = parcelRequire("fPZa6");
module.exports = $5b741fbea449f7af$var$tap;
$5b741fbea449f7af$var$tap.displayName = "tap";
$5b741fbea449f7af$var$tap.aliases = [];
function $5b741fbea449f7af$var$tap(Prism) {
    Prism.register($fPZa6);
    // https://en.wikipedia.org/wiki/Test_Anything_Protocol
    Prism.languages.tap = {
        fail: /not ok[^#{\n\r]*/,
        pass: /ok[^#{\n\r]*/,
        pragma: /pragma [+-][a-z]+/,
        bailout: /bail out!.*/i,
        version: /TAP version \d+/i,
        plan: /\b\d+\.\.\d+(?: +#.*)?/,
        subtest: {
            pattern: /# Subtest(?:: .*)?/,
            greedy: true
        },
        punctuation: /[{}]/,
        directive: /#.*/,
        yamlish: {
            pattern: /(^[ \t]*)---[\s\S]*?[\r\n][ \t]*\.\.\.$/m,
            lookbehind: true,
            inside: Prism.languages.yaml,
            alias: "language-yaml"
        }
    };
}

});
parcelRequire.register("fPZa6", function(module, exports) {
"use strict";
module.exports = $b87b0fea6ff3a570$var$yaml;
$b87b0fea6ff3a570$var$yaml.displayName = "yaml";
$b87b0fea6ff3a570$var$yaml.aliases = [
    "yml"
];
function $b87b0fea6ff3a570$var$yaml(Prism1) {
    (function(Prism) {
        // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property
        // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node
        var anchorOrAlias = /[*&][^\s[\]{},]+/ // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property
        ;
        var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/ // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)
        ;
        var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)" // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)
        ;
        // This is a simplified version that doesn't support "#" and multiline keys
        // All these long scarry character classes are simplified versions of YAML's characters
        var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
            return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
        });
        var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
        /**
     *
     * @param {string} value
     * @param {string} [flags]
     * @returns {RegExp}
     */ function createValuePattern(value, flags) {
            flags = (flags || "").replace(/m/g, "") + "m" // add m flag
            ;
            var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
                return properties;
            }).replace(/<<value>>/g, function() {
                return value;
            });
            return RegExp(pattern, flags);
        }
        Prism.languages.yaml = {
            scalar: {
                pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
                    return properties;
                })),
                lookbehind: true,
                alias: "string"
            },
            comment: /#.*/,
            key: {
                pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
                    return properties;
                }).replace(/<<key>>/g, function() {
                    return "(?:" + plainKey + "|" + string + ")";
                })),
                lookbehind: true,
                greedy: true,
                alias: "atrule"
            },
            directive: {
                pattern: /(^[ \t]*)%.+/m,
                lookbehind: true,
                alias: "important"
            },
            datetime: {
                pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
                lookbehind: true,
                alias: "number"
            },
            boolean: {
                pattern: createValuePattern(/false|true/.source, "i"),
                lookbehind: true,
                alias: "important"
            },
            null: {
                pattern: createValuePattern(/null|~/.source, "i"),
                lookbehind: true,
                alias: "important"
            },
            string: {
                pattern: createValuePattern(string),
                lookbehind: true,
                greedy: true
            },
            number: {
                pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
                lookbehind: true
            },
            tag: tag,
            important: anchorOrAlias,
            punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
        };
        Prism.languages.yml = Prism.languages.yaml;
    })(Prism1);
}

});


parcelRequire.register("mCGa7", function(module, exports) {
"use strict";
module.exports = $04400f0a2ecc6375$var$tcl;
$04400f0a2ecc6375$var$tcl.displayName = "tcl";
$04400f0a2ecc6375$var$tcl.aliases = [];
function $04400f0a2ecc6375$var$tcl(Prism) {
    Prism.languages.tcl = {
        comment: {
            pattern: /(^|[^\\])#.*/,
            lookbehind: true
        },
        string: {
            pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,
            greedy: true
        },
        variable: [
            {
                pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/,
                lookbehind: true
            },
            {
                pattern: /(\$)\{[^}]+\}/,
                lookbehind: true
            },
            {
                pattern: /(^[\t ]*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
                lookbehind: true
            }
        ],
        function: {
            pattern: /(^[\t ]*proc[ \t]+)\S+/m,
            lookbehind: true
        },
        builtin: [
            {
                pattern: /(^[\t ]*)(?:break|class|continue|error|eval|exit|for|foreach|if|proc|return|switch|while)\b/m,
                lookbehind: true
            },
            /\b(?:else|elseif)\b/
        ],
        scope: {
            pattern: /(^[\t ]*)(?:global|upvar|variable)\b/m,
            lookbehind: true,
            alias: "constant"
        },
        keyword: {
            pattern: /(^[\t ]*|\[)(?:Safe_Base|Tcl|after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|scan|seek|set|socket|source|split|string|subst|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|test|vars|wordBreak(?:After|Before))|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
            lookbehind: true
        },
        operator: /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|in|ne|ni)\b/,
        punctuation: /[{}()\[\]]/
    };
}

});

parcelRequire.register("4Hhqh", function(module, exports) {
"use strict";
module.exports = $36b8b16ad3a6c43d$var$textile;
$36b8b16ad3a6c43d$var$textile.displayName = "textile";
$36b8b16ad3a6c43d$var$textile.aliases = [];
function $36b8b16ad3a6c43d$var$textile(Prism1) {
    (function(Prism) {
        // We don't allow for pipes inside parentheses
        // to not break table pattern |(. foo |). bar |
        var modifierRegex = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source // Opening and closing parentheses which are not a modifier
        ;
        // This pattern is necessary to prevent exponential backtracking
        var parenthesesRegex = /\)|\((?![^|()\n]+\))/.source;
        /**
     * @param {string} source
     * @param {string} [flags]
     */ function withModifier(source, flags) {
            return RegExp(source.replace(/<MOD>/g, function() {
                return "(?:" + modifierRegex + ")";
            }).replace(/<PAR>/g, function() {
                return "(?:" + parenthesesRegex + ")";
            }), flags || "");
        }
        var modifierTokens = {
            css: {
                pattern: /\{[^{}]+\}/,
                inside: {
                    rest: Prism.languages.css
                }
            },
            "class-id": {
                pattern: /(\()[^()]+(?=\))/,
                lookbehind: true,
                alias: "attr-value"
            },
            lang: {
                pattern: /(\[)[^\[\]]+(?=\])/,
                lookbehind: true,
                alias: "attr-value"
            },
            // Anything else is punctuation (the first pattern is for row/col spans inside tables)
            punctuation: /[\\\/]\d+|\S/
        };
        var textile1 = Prism.languages.textile = Prism.languages.extend("markup", {
            phrase: {
                pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
                lookbehind: true,
                inside: {
                    // h1. Header 1
                    "block-tag": {
                        pattern: withModifier(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
                        inside: {
                            modifier: {
                                pattern: withModifier(/(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source),
                                lookbehind: true,
                                inside: modifierTokens
                            },
                            tag: /^[a-z]\w*/,
                            punctuation: /\.$/
                        }
                    },
                    // # List item
                    // * List item
                    list: {
                        pattern: withModifier(/^[*#]+<MOD>*\s+\S.*/.source, "m"),
                        inside: {
                            modifier: {
                                pattern: withModifier(/(^[*#]+)<MOD>+/.source),
                                lookbehind: true,
                                inside: modifierTokens
                            },
                            punctuation: /^[*#]+/
                        }
                    },
                    // | cell | cell | cell |
                    table: {
                        // Modifiers can be applied to the row: {color:red}.|1|2|3|
                        // or the cell: |{color:red}.1|2|3|
                        pattern: withModifier(/^(?:(?:<MOD>|<PAR>|[<>=^~])+\.\s*)?(?:\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.))[^|]*)+\|/.source, "m"),
                        inside: {
                            modifier: {
                                // Modifiers for rows after the first one are
                                // preceded by a pipe and a line feed
                                pattern: withModifier(/(^|\|(?:\r?\n|\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+(?=\.)/.source),
                                lookbehind: true,
                                inside: modifierTokens
                            },
                            punctuation: /\||^\./
                        }
                    },
                    inline: {
                        // eslint-disable-next-line regexp/no-super-linear-backtracking
                        pattern: withModifier(/(^|[^a-zA-Z\d])(\*\*|__|\?\?|[*_%@+\-^~])<MOD>*.+?\2(?![a-zA-Z\d])/.source),
                        lookbehind: true,
                        inside: {
                            // Note: superscripts and subscripts are not handled specifically
                            // *bold*, **bold**
                            bold: {
                                // eslint-disable-next-line regexp/no-super-linear-backtracking
                                pattern: withModifier(/(^(\*\*?)<MOD>*).+?(?=\2)/.source),
                                lookbehind: true
                            },
                            // _italic_, __italic__
                            italic: {
                                // eslint-disable-next-line regexp/no-super-linear-backtracking
                                pattern: withModifier(/(^(__?)<MOD>*).+?(?=\2)/.source),
                                lookbehind: true
                            },
                            // ??cite??
                            cite: {
                                // eslint-disable-next-line regexp/no-super-linear-backtracking
                                pattern: withModifier(/(^\?\?<MOD>*).+?(?=\?\?)/.source),
                                lookbehind: true,
                                alias: "string"
                            },
                            // @code@
                            code: {
                                // eslint-disable-next-line regexp/no-super-linear-backtracking
                                pattern: withModifier(/(^@<MOD>*).+?(?=@)/.source),
                                lookbehind: true,
                                alias: "keyword"
                            },
                            // +inserted+
                            inserted: {
                                // eslint-disable-next-line regexp/no-super-linear-backtracking
                                pattern: withModifier(/(^\+<MOD>*).+?(?=\+)/.source),
                                lookbehind: true
                            },
                            // -deleted-
                            deleted: {
                                // eslint-disable-next-line regexp/no-super-linear-backtracking
                                pattern: withModifier(/(^-<MOD>*).+?(?=-)/.source),
                                lookbehind: true
                            },
                            // %span%
                            span: {
                                // eslint-disable-next-line regexp/no-super-linear-backtracking
                                pattern: withModifier(/(^%<MOD>*).+?(?=%)/.source),
                                lookbehind: true
                            },
                            modifier: {
                                pattern: withModifier(/(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source),
                                lookbehind: true,
                                inside: modifierTokens
                            },
                            punctuation: /[*_%?@+\-^~]+/
                        }
                    },
                    // [alias]http://example.com
                    "link-ref": {
                        pattern: /^\[[^\]]+\]\S+$/m,
                        inside: {
                            string: {
                                pattern: /(^\[)[^\]]+(?=\])/,
                                lookbehind: true
                            },
                            url: {
                                pattern: /(^\])\S+$/,
                                lookbehind: true
                            },
                            punctuation: /[\[\]]/
                        }
                    },
                    // "text":http://example.com
                    // "text":link-ref
                    link: {
                        // eslint-disable-next-line regexp/no-super-linear-backtracking
                        pattern: withModifier(/"<MOD>*[^"]+":.+?(?=[^\w/]?(?:\s|$))/.source),
                        inside: {
                            text: {
                                // eslint-disable-next-line regexp/no-super-linear-backtracking
                                pattern: withModifier(/(^"<MOD>*)[^"]+(?=")/.source),
                                lookbehind: true
                            },
                            modifier: {
                                pattern: withModifier(/(^")<MOD>+/.source),
                                lookbehind: true,
                                inside: modifierTokens
                            },
                            url: {
                                pattern: /(:).+/,
                                lookbehind: true
                            },
                            punctuation: /[":]/
                        }
                    },
                    // !image.jpg!
                    // !image.jpg(Title)!:http://example.com
                    image: {
                        pattern: withModifier(/!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\s()]+(?:\([^)]+\))?!(?::.+?(?=[^\w/]?(?:\s|$)))?/.source),
                        inside: {
                            source: {
                                pattern: withModifier(/(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\s()]+(?:\([^)]+\))?(?=!)/.source),
                                lookbehind: true,
                                alias: "url"
                            },
                            modifier: {
                                pattern: withModifier(/(^!)(?:<MOD>|<PAR>|[<>=])+/.source),
                                lookbehind: true,
                                inside: modifierTokens
                            },
                            url: {
                                pattern: /(:).+/,
                                lookbehind: true
                            },
                            punctuation: /[!:]/
                        }
                    },
                    // Footnote[1]
                    footnote: {
                        pattern: /\b\[\d+\]/,
                        alias: "comment",
                        inside: {
                            punctuation: /\[|\]/
                        }
                    },
                    // CSS(Cascading Style Sheet)
                    acronym: {
                        pattern: /\b[A-Z\d]+\([^)]+\)/,
                        inside: {
                            comment: {
                                pattern: /(\()[^()]+(?=\))/,
                                lookbehind: true
                            },
                            punctuation: /[()]/
                        }
                    },
                    // Prism(C)
                    mark: {
                        pattern: /\b\((?:C|R|TM)\)/,
                        alias: "comment",
                        inside: {
                            punctuation: /[()]/
                        }
                    }
                }
            }
        });
        var phraseInside = textile1["phrase"].inside;
        var nestedPatterns = {
            inline: phraseInside["inline"],
            link: phraseInside["link"],
            image: phraseInside["image"],
            footnote: phraseInside["footnote"],
            acronym: phraseInside["acronym"],
            mark: phraseInside["mark"]
        } // Only allow alpha-numeric HTML tags, not XML tags
        ;
        textile1.tag.pattern = /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i // Allow some nesting
        ;
        var phraseInlineInside = phraseInside["inline"].inside;
        phraseInlineInside["bold"].inside = nestedPatterns;
        phraseInlineInside["italic"].inside = nestedPatterns;
        phraseInlineInside["inserted"].inside = nestedPatterns;
        phraseInlineInside["deleted"].inside = nestedPatterns;
        phraseInlineInside["span"].inside = nestedPatterns // Allow some styles inside table cells
        ;
        var phraseTableInside = phraseInside["table"].inside;
        phraseTableInside["inline"] = nestedPatterns["inline"];
        phraseTableInside["link"] = nestedPatterns["link"];
        phraseTableInside["image"] = nestedPatterns["image"];
        phraseTableInside["footnote"] = nestedPatterns["footnote"];
        phraseTableInside["acronym"] = nestedPatterns["acronym"];
        phraseTableInside["mark"] = nestedPatterns["mark"];
    })(Prism1);
}

});

parcelRequire.register("2uxje", function(module, exports) {
"use strict";
module.exports = $1d0838a08aa0fdb6$var$toml;
$1d0838a08aa0fdb6$var$toml.displayName = "toml";
$1d0838a08aa0fdb6$var$toml.aliases = [];
function $1d0838a08aa0fdb6$var$toml(Prism1) {
    (function(Prism) {
        var key = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
        /**
     * @param {string} pattern
     */ function insertKey(pattern) {
            return pattern.replace(/__/g, function() {
                return key;
            });
        }
        Prism.languages.toml = {
            comment: {
                pattern: /#.*/,
                greedy: true
            },
            table: {
                pattern: RegExp(insertKey(/(^[\t ]*\[\s*(?:\[\s*)?)__(?:\s*\.\s*__)*(?=\s*\])/.source), "m"),
                lookbehind: true,
                greedy: true,
                alias: "class-name"
            },
            key: {
                pattern: RegExp(insertKey(/(^[\t ]*|[{,]\s*)__(?:\s*\.\s*__)*(?=\s*=)/.source), "m"),
                lookbehind: true,
                greedy: true,
                alias: "property"
            },
            string: {
                pattern: /"""(?:\\[\s\S]|[^\\])*?"""|'''[\s\S]*?'''|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*"/,
                greedy: true
            },
            date: [
                {
                    // Offset Date-Time, Local Date-Time, Local Date
                    pattern: /\b\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)?\b/i,
                    alias: "number"
                },
                {
                    // Local Time
                    pattern: /\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b/,
                    alias: "number"
                }
            ],
            number: /(?:\b0(?:x[\da-zA-Z]+(?:_[\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\b|[-+]?\b\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?\b|[-+]?\b(?:inf|nan)\b/,
            boolean: /\b(?:false|true)\b/,
            punctuation: /[.,=[\]{}]/
        };
    })(Prism1);
}

});

parcelRequire.register("39Nm4", function(module, exports) {
"use strict";
module.exports = $24c87f39d553e286$var$tremor;
$24c87f39d553e286$var$tremor.displayName = "tremor";
$24c87f39d553e286$var$tremor.aliases = [];
function $24c87f39d553e286$var$tremor(Prism1) {
    (function(Prism) {
        Prism.languages.tremor = {
            comment: {
                pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
                lookbehind: true
            },
            "interpolated-string": null,
            // see below
            extractor: {
                pattern: /\b[a-z_]\w*\|(?:[^\r\n\\|]|\\(?:\r\n|[\s\S]))*\|/i,
                greedy: true,
                inside: {
                    regex: {
                        pattern: /(^re)\|[\s\S]+/,
                        lookbehind: true
                    },
                    function: /^\w+/,
                    value: /\|[\s\S]+/
                }
            },
            identifier: {
                pattern: /`[^`]*`/,
                greedy: true
            },
            function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())\b/,
            keyword: /\b(?:args|as|by|case|config|connect|connector|const|copy|create|default|define|deploy|drop|each|emit|end|erase|event|flow|fn|for|from|group|having|insert|into|intrinsic|let|links|match|merge|mod|move|of|operator|patch|pipeline|recur|script|select|set|sliding|state|stream|to|tumbling|update|use|when|where|window|with)\b/,
            boolean: /\b(?:false|null|true)\b/i,
            number: /\b(?:0b[01_]*|0x[0-9a-fA-F_]*|\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee][+-]?[\d_]+)?)\b/,
            "pattern-punctuation": {
                pattern: /%(?=[({[])/,
                alias: "punctuation"
            },
            operator: /[-+*\/%~!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?>?=?|(?:absent|and|not|or|present|xor)\b/,
            punctuation: /::|[;\[\]()\{\},.:]/
        };
        var interpolationPattern = /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/.source;
        Prism.languages.tremor["interpolated-string"] = {
            pattern: RegExp(/(^|[^\\])/.source + "(?:" + '"""(?:' + /[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source + "|" + interpolationPattern + ')*"""' + "|" + '"(?:' + /[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source + "|" + interpolationPattern + ')*"' + ")"),
            lookbehind: true,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: RegExp(interpolationPattern),
                    inside: {
                        punctuation: /^#\{|\}$/,
                        expression: {
                            pattern: /[\s\S]+/,
                            inside: Prism.languages.tremor
                        }
                    }
                },
                string: /[\s\S]+/
            }
        };
        Prism.languages.troy = Prism.languages["tremor"];
        Prism.languages.trickle = Prism.languages["tremor"];
    })(Prism1);
}

});

parcelRequire.register("kuFmD", function(module, exports) {
"use strict";

var $059OA = parcelRequire("059OA");

var $aQinA = parcelRequire("aQinA");
module.exports = $eeb6b20cc6d1dc5f$var$tsx;
$eeb6b20cc6d1dc5f$var$tsx.displayName = "tsx";
$eeb6b20cc6d1dc5f$var$tsx.aliases = [];
function $eeb6b20cc6d1dc5f$var$tsx(Prism1) {
    Prism1.register($059OA);
    Prism1.register($aQinA);
    (function(Prism) {
        var typescript = Prism.util.clone(Prism.languages.typescript);
        Prism.languages.tsx = Prism.languages.extend("jsx", typescript) // doesn't work with TS because TS is too complex
        ;
        delete Prism.languages.tsx["parameter"];
        delete Prism.languages.tsx["literal-property"] // This will prevent collisions between TSX tags and TS generic types.
        ;
        // Idea by https://github.com/karlhorky
        // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928
        var tag = Prism.languages.tsx.tag;
        tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
        tag.lookbehind = true;
    })(Prism1);
}

});

parcelRequire.register("i6g85", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");
module.exports = $d2d54c7d27f04e9d$var$tt2;
$d2d54c7d27f04e9d$var$tt2.displayName = "tt2";
$d2d54c7d27f04e9d$var$tt2.aliases = [];
function $d2d54c7d27f04e9d$var$tt2(Prism1) {
    Prism1.register($cekeD);
    (function(Prism) {
        Prism.languages.tt2 = Prism.languages.extend("clike", {
            comment: /#.*|\[%#[\s\S]*?%\]/,
            keyword: /\b(?:BLOCK|CALL|CASE|CATCH|CLEAR|DEBUG|DEFAULT|ELSE|ELSIF|END|FILTER|FINAL|FOREACH|GET|IF|IN|INCLUDE|INSERT|LAST|MACRO|META|NEXT|PERL|PROCESS|RAWPERL|RETURN|SET|STOP|SWITCH|TAGS|THROW|TRY|UNLESS|USE|WHILE|WRAPPER)\b/,
            punctuation: /[[\]{},()]/
        });
        Prism.languages.insertBefore("tt2", "number", {
            operator: /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
            variable: {
                pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i
            }
        });
        Prism.languages.insertBefore("tt2", "keyword", {
            delimiter: {
                pattern: /^(?:\[%|%%)-?|-?%\]$/,
                alias: "punctuation"
            }
        });
        Prism.languages.insertBefore("tt2", "string", {
            "single-quoted-string": {
                pattern: /'[^\\']*(?:\\[\s\S][^\\']*)*'/,
                greedy: true,
                alias: "string"
            },
            "double-quoted-string": {
                pattern: /"[^\\"]*(?:\\[\s\S][^\\"]*)*"/,
                greedy: true,
                alias: "string",
                inside: {
                    variable: {
                        pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i
                    }
                }
            }
        }) // The different types of TT2 strings "replace" the C-like standard string
        ;
        delete Prism.languages.tt2.string;
        Prism.hooks.add("before-tokenize", function(env) {
            var tt2Pattern = /\[%[\s\S]+?%\]/g;
            Prism.languages["markup-templating"].buildPlaceholders(env, "tt2", tt2Pattern);
        });
        Prism.hooks.add("after-tokenize", function(env) {
            Prism.languages["markup-templating"].tokenizePlaceholders(env, "tt2");
        });
    })(Prism1);
}

});

parcelRequire.register("hWAZy", function(module, exports) {
"use strict";

var $cekeD = parcelRequire("cekeD");
module.exports = $d1048c44e094602f$var$twig;
$d1048c44e094602f$var$twig.displayName = "twig";
$d1048c44e094602f$var$twig.aliases = [];
function $d1048c44e094602f$var$twig(Prism) {
    Prism.register($cekeD);
    Prism.languages.twig = {
        comment: /^\{#[\s\S]*?#\}$/,
        "tag-name": {
            pattern: /(^\{%-?\s*)\w+/,
            lookbehind: true,
            alias: "keyword"
        },
        delimiter: {
            pattern: /^\{[{%]-?|-?[%}]\}$/,
            alias: "punctuation"
        },
        string: {
            pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            inside: {
                punctuation: /^['"]|['"]$/
            }
        },
        keyword: /\b(?:even|if|odd)\b/,
        boolean: /\b(?:false|null|true)\b/,
        number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
        operator: [
            {
                pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
                lookbehind: true
            },
            /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
        ],
        punctuation: /[()\[\]{}:.,]/
    };
    Prism.hooks.add("before-tokenize", function(env) {
        if (env.language !== "twig") return;
        var pattern = /\{(?:#[\s\S]*?#|%[\s\S]*?%|\{[\s\S]*?\})\}/g;
        Prism.languages["markup-templating"].buildPlaceholders(env, "twig", pattern);
    });
    Prism.hooks.add("after-tokenize", function(env) {
        Prism.languages["markup-templating"].tokenizePlaceholders(env, "twig");
    });
}

});

parcelRequire.register("3Oh9p", function(module, exports) {
"use strict";
module.exports = $2c6358695c21d80f$var$typoscript;
$2c6358695c21d80f$var$typoscript.displayName = "typoscript";
$2c6358695c21d80f$var$typoscript.aliases = [
    "tsconfig"
];
function $2c6358695c21d80f$var$typoscript(Prism1) {
    (function(Prism) {
        var keywords = /\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
        Prism.languages.typoscript = {
            comment: [
                {
                    // multiline comments /* */
                    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                    lookbehind: true
                },
                {
                    // double-slash comments - ignored when backslashes or colon is found in front
                    // also ignored whenever directly after an equal-sign, because it would probably be an url without protocol
                    pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
                    lookbehind: true,
                    greedy: true
                },
                {
                    // hash comments - ignored when leading quote is found for hex colors in strings
                    pattern: /(^|[^"'])#.*/,
                    lookbehind: true,
                    greedy: true
                }
            ],
            function: [
                {
                    // old include style
                    pattern: /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
                    inside: {
                        string: {
                            pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
                            inside: {
                                keyword: keywords
                            }
                        },
                        keyword: {
                            pattern: /INCLUDE_TYPOSCRIPT/
                        }
                    }
                },
                {
                    // new include style
                    pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
                    inside: {
                        string: /"[^"\r\n]*"|'[^'\r\n]*'/
                    }
                }
            ],
            string: {
                pattern: /^([^=]*=[< ]?)(?:(?!\]\n).)*/,
                lookbehind: true,
                inside: {
                    function: /\{\$.*\}/,
                    // constants include
                    keyword: keywords,
                    number: /^\d+$/,
                    punctuation: /[,|:]/
                }
            },
            keyword: keywords,
            number: {
                // special highlighting for indexes of arrays in tags
                pattern: /\b\d+\s*[.{=]/,
                inside: {
                    operator: /[.{=]/
                }
            },
            tag: {
                pattern: /\.?[-\w\\]+\.?/,
                inside: {
                    punctuation: /\./
                }
            },
            punctuation: /[{}[\];(),.:|]/,
            operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
        };
        Prism.languages.tsconfig = Prism.languages.typoscript;
    })(Prism1);
}

});

parcelRequire.register("8GCY6", function(module, exports) {
"use strict";
module.exports = $653079494f0dfd1c$var$unrealscript;
$653079494f0dfd1c$var$unrealscript.displayName = "unrealscript";
$653079494f0dfd1c$var$unrealscript.aliases = [
    "uc",
    "uscript"
];
function $653079494f0dfd1c$var$unrealscript(Prism) {
    Prism.languages.unrealscript = {
        comment: /\/\/.*|\/\*[\s\S]*?\*\//,
        string: {
            pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
            greedy: true
        },
        category: {
            pattern: /(\b(?:(?:autoexpand|hide|show)categories|var)\s*\()[^()]+(?=\))/,
            lookbehind: true,
            greedy: true,
            alias: "property"
        },
        metadata: {
            pattern: /(\w\s*)<\s*\w+\s*=[^<>|=\r\n]+(?:\|\s*\w+\s*=[^<>|=\r\n]+)*>/,
            lookbehind: true,
            greedy: true,
            inside: {
                property: /\b\w+(?=\s*=)/,
                operator: /=/,
                punctuation: /[<>|]/
            }
        },
        macro: {
            pattern: /`\w+/,
            alias: "property"
        },
        "class-name": {
            pattern: /(\b(?:class|enum|extends|interface|state(?:\(\))?|struct|within)\s+)\w+/,
            lookbehind: true
        },
        keyword: /\b(?:abstract|actor|array|auto|autoexpandcategories|bool|break|byte|case|class|classgroup|client|coerce|collapsecategories|config|const|continue|default|defaultproperties|delegate|dependson|deprecated|do|dontcollapsecategories|editconst|editinlinenew|else|enum|event|exec|export|extends|final|float|for|forcescriptorder|foreach|function|goto|guid|hidecategories|hidedropdown|if|ignores|implements|inherits|input|int|interface|iterator|latent|local|material|name|native|nativereplication|noexport|nontransient|noteditinlinenew|notplaceable|operator|optional|out|pawn|perobjectconfig|perobjectlocalized|placeable|postoperator|preoperator|private|protected|reliable|replication|return|server|showcategories|simulated|singular|state|static|string|struct|structdefault|structdefaultproperties|switch|texture|transient|travel|unreliable|until|var|vector|while|within)\b/,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        boolean: /\b(?:false|true)\b/,
        number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        // https://docs.unrealengine.com/udk/Three/UnrealScriptExpressions.html
        operator: />>|<<|--|\+\+|\*\*|[-+*/~!=<>$@]=?|&&?|\|\|?|\^\^?|[?:%]|\b(?:ClockwiseFrom|Cross|Dot)\b/,
        punctuation: /[()[\]{};,.]/
    };
    Prism.languages.uc = Prism.languages.uscript = Prism.languages.unrealscript;
}

});

parcelRequire.register("5EjtJ", function(module, exports) {
"use strict";
module.exports = $41cfcc30283f70a9$var$uorazor;
$41cfcc30283f70a9$var$uorazor.displayName = "uorazor";
$41cfcc30283f70a9$var$uorazor.aliases = [];
function $41cfcc30283f70a9$var$uorazor(Prism) {
    Prism.languages.uorazor = {
        "comment-hash": {
            pattern: /#.*/,
            alias: "comment",
            greedy: true
        },
        "comment-slash": {
            pattern: /\/\/.*/,
            alias: "comment",
            greedy: true
        },
        string: {
            pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
            inside: {
                punctuation: /^['"]|['"]$/
            },
            greedy: true
        },
        "source-layers": {
            pattern: /\b(?:arms|backpack|blue|bracelet|cancel|clear|cloak|criminal|earrings|enemy|facialhair|friend|friendly|gloves|gray|grey|ground|hair|head|innerlegs|innertorso|innocent|lefthand|middletorso|murderer|neck|nonfriendly|onehandedsecondary|outerlegs|outertorso|pants|red|righthand|ring|self|shirt|shoes|talisman|waist)\b/i,
            alias: "function"
        },
        "source-commands": {
            pattern: /\b(?:alliance|attack|cast|clearall|clearignore|clearjournal|clearlist|clearsysmsg|createlist|createtimer|dclick|dclicktype|dclickvar|dress|dressconfig|drop|droprelloc|emote|getlabel|guild|gumpclose|gumpresponse|hotkey|ignore|lasttarget|lift|lifttype|menu|menuresponse|msg|org|organize|organizer|overhead|pause|poplist|potion|promptresponse|pushlist|removelist|removetimer|rename|restock|say|scav|scavenger|script|setability|setlasttarget|setskill|settimer|setvar|sysmsg|target|targetloc|targetrelloc|targettype|undress|unignore|unsetvar|useobject|useonce|useskill|usetype|virtue|wait|waitforgump|waitformenu|waitforprompt|waitforstat|waitforsysmsg|waitfortarget|walk|wfsysmsg|wft|whisper|yell)\b/,
            alias: "function"
        },
        "tag-name": {
            pattern: /(^\{%-?\s*)\w+/,
            lookbehind: true,
            alias: "keyword"
        },
        delimiter: {
            pattern: /^\{[{%]-?|-?[%}]\}$/,
            alias: "punctuation"
        },
        function: /\b(?:atlist|close|closest|count|counter|counttype|dead|dex|diffhits|diffmana|diffstam|diffweight|find|findbuff|finddebuff|findlayer|findtype|findtypelist|followers|gumpexists|hidden|hits|hp|hue|human|humanoid|ingump|inlist|insysmessage|insysmsg|int|invul|lhandempty|list|listexists|mana|maxhits|maxhp|maxmana|maxstam|maxweight|monster|mounted|name|next|noto|paralyzed|poisoned|position|prev|previous|queued|rand|random|rhandempty|skill|stam|str|targetexists|timer|timerexists|varexist|warmode|weight)\b/,
        keyword: /\b(?:and|as|break|continue|else|elseif|endfor|endif|endwhile|for|if|loop|not|or|replay|stop|while)\b/,
        boolean: /\b(?:false|null|true)\b/,
        number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
        operator: [
            {
                pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
                lookbehind: true
            },
            /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
        ],
        punctuation: /[()\[\]{}:.,]/
    };
}

});

parcelRequire.register("e7Gip", function(module, exports) {
"use strict";
module.exports = $a482873ad676fab0$var$uri;
$a482873ad676fab0$var$uri.displayName = "uri";
$a482873ad676fab0$var$uri.aliases = [
    "url"
];
function $a482873ad676fab0$var$uri(Prism) {
    // https://tools.ietf.org/html/rfc3986#appendix-A
    Prism.languages.uri = {
        scheme: {
            pattern: /^[a-z][a-z0-9+.-]*:/im,
            greedy: true,
            inside: {
                "scheme-delimiter": /:$/
            }
        },
        fragment: {
            pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
            inside: {
                "fragment-delimiter": /^#/
            }
        },
        query: {
            pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
            inside: {
                "query-delimiter": {
                    pattern: /^\?/,
                    greedy: true
                },
                "pair-delimiter": /[&;]/,
                pair: {
                    pattern: /^[^=][\s\S]*/,
                    inside: {
                        key: /^[^=]+/,
                        value: {
                            pattern: /(^=)[\s\S]+/,
                            lookbehind: true
                        }
                    }
                }
            }
        },
        authority: {
            pattern: RegExp(/^\/\//.source + /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source + ("(?:" + /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source + "|" + /[\w\-.~!$&'()*+,;=%]*/.source + ")") + /(?::\d*)?/.source, "m"),
            inside: {
                "authority-delimiter": /^\/\//,
                "user-info-segment": {
                    pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
                    inside: {
                        "user-info-delimiter": /@$/,
                        "user-info": /^[\w\-.~!$&'()*+,;=%:]+/
                    }
                },
                "port-segment": {
                    pattern: /:\d*$/,
                    inside: {
                        "port-delimiter": /^:/,
                        port: /^\d+/
                    }
                },
                host: {
                    pattern: /[\s\S]+/,
                    inside: {
                        "ip-literal": {
                            pattern: /^\[[\s\S]+\]$/,
                            inside: {
                                "ip-literal-delimiter": /^\[|\]$/,
                                "ipv-future": /^v[\s\S]+/,
                                "ipv6-address": /^[\s\S]+/
                            }
                        },
                        "ipv4-address": /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]\d{0,2})$/
                    }
                }
            }
        },
        path: {
            pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
            inside: {
                "path-separator": /\//
            }
        }
    };
    Prism.languages.url = Prism.languages.uri;
}

});

parcelRequire.register("1T7YT", function(module, exports) {
"use strict";
module.exports = $16011e6544a85624$var$v;
$16011e6544a85624$var$v.displayName = "v";
$16011e6544a85624$var$v.aliases = [];
function $16011e6544a85624$var$v(Prism1) {
    (function(Prism) {
        var interpolationExpr = {
            pattern: /[\s\S]+/,
            inside: null
        };
        Prism.languages.v = Prism.languages.extend("clike", {
            string: {
                pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                alias: "quoted-string",
                greedy: true,
                inside: {
                    interpolation: {
                        pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
                        lookbehind: true,
                        inside: {
                            "interpolation-variable": {
                                pattern: /^\$\w[\s\S]*$/,
                                alias: "variable"
                            },
                            "interpolation-punctuation": {
                                pattern: /^\$\{|\}$/,
                                alias: "punctuation"
                            },
                            "interpolation-expression": interpolationExpr
                        }
                    }
                }
            },
            "class-name": {
                pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
                lookbehind: true
            },
            keyword: /(?:\b(?:__global|as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:else|for|if)|#(?:flag|include))\b/,
            number: /\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
            operator: /~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
            builtin: /\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
        });
        interpolationExpr.inside = Prism.languages.v;
        Prism.languages.insertBefore("v", "string", {
            char: {
                pattern: /`(?:\\`|\\?[^`]{1,2})`/,
                // using {1,2} instead of `u` flag for compatibility
                alias: "rune"
            }
        });
        Prism.languages.insertBefore("v", "operator", {
            attribute: {
                pattern: /(^[\t ]*)\[(?:deprecated|direct_array_access|flag|inline|live|ref_only|typedef|unsafe_fn|windows_stdcall)\]/m,
                lookbehind: true,
                alias: "annotation",
                inside: {
                    punctuation: /[\[\]]/,
                    keyword: /\w+/
                }
            },
            generic: {
                pattern: /<\w+>(?=\s*[\)\{])/,
                inside: {
                    punctuation: /[<>]/,
                    "class-name": /\w+/
                }
            }
        });
        Prism.languages.insertBefore("v", "function", {
            "generic-function": {
                // e.g. foo<T>( ...
                pattern: /\b\w+\s*<\w+>(?=\()/,
                inside: {
                    function: /^\w+/,
                    generic: {
                        pattern: /<\w+>/,
                        inside: Prism.languages.v.generic.inside
                    }
                }
            }
        });
    })(Prism1);
}

});

parcelRequire.register("aXVod", function(module, exports) {
"use strict";
module.exports = $7fbbee6b7dd42c61$var$vala;
$7fbbee6b7dd42c61$var$vala.displayName = "vala";
$7fbbee6b7dd42c61$var$vala.aliases = [];
function $7fbbee6b7dd42c61$var$vala(Prism) {
    Prism.languages.vala = Prism.languages.extend("clike", {
        // Classes copied from prism-csharp
        "class-name": [
            {
                // (Foo bar, Bar baz)
                pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=(?:\?\s+|\*?\s+\*?)\w)/,
                inside: {
                    punctuation: /\./
                }
            },
            {
                // [Foo]
                pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
                lookbehind: true,
                inside: {
                    punctuation: /\./
                }
            },
            {
                // class Foo : Bar
                pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
                lookbehind: true,
                inside: {
                    punctuation: /\./
                }
            },
            {
                // class Foo
                pattern: /((?:\b(?:class|enum|interface|new|struct)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
                lookbehind: true,
                inside: {
                    punctuation: /\./
                }
            }
        ],
        keyword: /\b(?:abstract|as|assert|async|base|bool|break|case|catch|char|class|const|construct|continue|default|delegate|delete|do|double|dynamic|else|ensures|enum|errordomain|extern|finally|float|for|foreach|get|if|in|inline|int|int16|int32|int64|int8|interface|internal|is|lock|long|namespace|new|null|out|override|owned|params|private|protected|public|ref|requires|return|set|short|signal|sizeof|size_t|ssize_t|static|string|struct|switch|this|throw|throws|try|typeof|uchar|uint|uint16|uint32|uint64|uint8|ulong|unichar|unowned|ushort|using|value|var|virtual|void|volatile|weak|while|yield)\b/i,
        function: /\b\w+(?=\s*\()/,
        number: /(?:\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?:f|u?l?)?/i,
        operator: /\+\+|--|&&|\|\||<<=?|>>=?|=>|->|~|[+\-*\/%&^|=!<>]=?|\?\??|\.\.\./,
        punctuation: /[{}[\];(),.:]/,
        constant: /\b[A-Z0-9_]+\b/
    });
    Prism.languages.insertBefore("vala", "string", {
        "raw-string": {
            pattern: /"""[\s\S]*?"""/,
            greedy: true,
            alias: "string"
        },
        "template-string": {
            pattern: /@"[\s\S]*?"/,
            greedy: true,
            inside: {
                interpolation: {
                    pattern: /\$(?:\([^)]*\)|[a-zA-Z]\w*)/,
                    inside: {
                        delimiter: {
                            pattern: /^\$\(?|\)$/,
                            alias: "punctuation"
                        },
                        rest: Prism.languages.vala
                    }
                },
                string: /[\s\S]+/
            }
        }
    });
    Prism.languages.insertBefore("vala", "keyword", {
        regex: {
            pattern: /\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[imsx]{0,4}(?=\s*(?:$|[\r\n,.;})\]]))/,
            greedy: true,
            inside: {
                "regex-source": {
                    pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                    lookbehind: true,
                    alias: "language-regex",
                    inside: Prism.languages.regex
                },
                "regex-delimiter": /^\//,
                "regex-flags": /^[a-z]+$/
            }
        }
    });
}

});

parcelRequire.register("3nS95", function(module, exports) {
"use strict";
module.exports = $276d85447e702f6e$var$velocity;
$276d85447e702f6e$var$velocity.displayName = "velocity";
$276d85447e702f6e$var$velocity.aliases = [];
function $276d85447e702f6e$var$velocity(Prism1) {
    (function(Prism) {
        Prism.languages.velocity = Prism.languages.extend("markup", {});
        var velocity1 = {
            variable: {
                pattern: /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
                lookbehind: true,
                inside: {} // See below
            },
            string: {
                pattern: /"[^"]*"|'[^']*'/,
                greedy: true
            },
            number: /\b\d+\b/,
            boolean: /\b(?:false|true)\b/,
            operator: /[=!<>]=?|[+*/%-]|&&|\|\||\.\.|\b(?:eq|g[et]|l[et]|n(?:e|ot))\b/,
            punctuation: /[(){}[\]:,.]/
        };
        velocity1.variable.inside = {
            string: velocity1["string"],
            function: {
                pattern: /([^\w-])[a-z][\w-]*(?=\()/,
                lookbehind: true
            },
            number: velocity1["number"],
            boolean: velocity1["boolean"],
            punctuation: velocity1["punctuation"]
        };
        Prism.languages.insertBefore("velocity", "comment", {
            unparsed: {
                pattern: /(^|[^\\])#\[\[[\s\S]*?\]\]#/,
                lookbehind: true,
                greedy: true,
                inside: {
                    punctuation: /^#\[\[|\]\]#$/
                }
            },
            "velocity-comment": [
                {
                    pattern: /(^|[^\\])#\*[\s\S]*?\*#/,
                    lookbehind: true,
                    greedy: true,
                    alias: "comment"
                },
                {
                    pattern: /(^|[^\\])##.*/,
                    lookbehind: true,
                    greedy: true,
                    alias: "comment"
                }
            ],
            directive: {
                pattern: /(^|[^\\](?:\\\\)*)#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})(?:\s*\((?:[^()]|\([^()]*\))*\))?/i,
                lookbehind: true,
                inside: {
                    keyword: {
                        pattern: /^#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})|\bin\b/,
                        inside: {
                            punctuation: /[{}]/
                        }
                    },
                    rest: velocity1
                }
            },
            variable: velocity1["variable"]
        });
        Prism.languages.velocity["tag"].inside["attr-value"].inside.rest = Prism.languages.velocity;
    })(Prism1);
}

});

parcelRequire.register("9Itlp", function(module, exports) {
"use strict";
module.exports = $712efc494f89872d$var$verilog;
$712efc494f89872d$var$verilog.displayName = "verilog";
$712efc494f89872d$var$verilog.aliases = [];
function $712efc494f89872d$var$verilog(Prism) {
    Prism.languages.verilog = {
        comment: {
            pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
            greedy: true
        },
        string: {
            pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
            greedy: true
        },
        "kernel-function": {
            // support for any kernel function (ex: $display())
            pattern: /\B\$\w+\b/,
            alias: "property"
        },
        // support for user defined constants (ex: `define)
        constant: /\B`\w+\b/,
        function: /\b\w+(?=\()/,
        // support for verilog and system verilog keywords
        keyword: /\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endsequence|endspecify|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
        // bold highlighting for all verilog and system verilog logic blocks
        important: /\b(?:always|always_comb|always_ff|always_latch)\b(?: *@)?/,
        // support for time ticks, vectors, and real numbers
        number: /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b(?:\d*[._])?\d+(?:e[-+]?\d+)?/i,
        operator: /[-+{}^~%*\/?=!<>&|]+/,
        punctuation: /[[\];(),.:]/
    };
}

});

parcelRequire.register("ehHiz", function(module, exports) {
"use strict";
module.exports = $a6643d6b3a7643b6$var$vhdl;
$a6643d6b3a7643b6$var$vhdl.displayName = "vhdl";
$a6643d6b3a7643b6$var$vhdl.aliases = [];
function $a6643d6b3a7643b6$var$vhdl(Prism) {
    Prism.languages.vhdl = {
        comment: /--.+/,
        // support for all logic vectors
        "vhdl-vectors": {
            pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
            alias: "number"
        },
        // support for operator overloading included
        "quoted-function": {
            pattern: /"\S+?"(?=\()/,
            alias: "function"
        },
        string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
        constant: /\b(?:library|use)\b/i,
        // support for predefined attributes included
        keyword: /\b(?:'active|'ascending|'base|'delayed|'driving|'driving_value|'event|'high|'image|'instance_name|'last_active|'last_event|'last_value|'left|'leftof|'length|'low|'path_name|'pos|'pred|'quiet|'range|'reverse_range|'right|'rightof|'simple_name|'stable|'succ|'transaction|'val|'value|access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with)\b/i,
        boolean: /\b(?:false|true)\b/i,
        function: /\w+(?=\()/,
        // decimal, based, physical, and exponential numbers supported
        number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
        operator: /[<>]=?|:=|[-+*/&=]|\b(?:abs|and|mod|nand|nor|not|or|rem|rol|ror|sla|sll|sra|srl|xnor|xor)\b/i,
        punctuation: /[{}[\];(),.:]/
    };
}

});

parcelRequire.register("g1P8Z", function(module, exports) {
"use strict";
module.exports = $bab4697dfa531058$var$vim;
$bab4697dfa531058$var$vim.displayName = "vim";
$bab4697dfa531058$var$vim.aliases = [];
function $bab4697dfa531058$var$vim(Prism) {
    Prism.languages.vim = {
        string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
        comment: /".*/,
        function: /\b\w+(?=\()/,
        keyword: /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
        builtin: /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
        number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
        operator: /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
        punctuation: /[{}[\](),;:]/
    };
}

});

parcelRequire.register("vtJFz", function(module, exports) {
"use strict";
module.exports = $05e9f63c8a756e23$var$visualBasic;
$05e9f63c8a756e23$var$visualBasic.displayName = "visualBasic";
$05e9f63c8a756e23$var$visualBasic.aliases = [];
function $05e9f63c8a756e23$var$visualBasic(Prism) {
    Prism.languages["visual-basic"] = {
        comment: {
            pattern: /(?:['‘’]|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
            inside: {
                keyword: /^REM/i
            }
        },
        directive: {
            pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:\b_[ \t]*(?:\r\n?|\n)|.)+/i,
            alias: "property",
            greedy: true
        },
        string: {
            pattern: /\$?["“”](?:["“”]{2}|[^"“”])*["“”]C?/i,
            greedy: true
        },
        date: {
            pattern: /#[ \t]*(?:\d+([/-])\d+\1\d+(?:[ \t]+(?:\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?))?|\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?)[ \t]*#/i,
            alias: "number"
        },
        number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:[FRD]|U?[ILS])?/i,
        boolean: /\b(?:False|Nothing|True)\b/i,
        keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Until|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Xor)\b/i,
        operator: /[+\-*/\\^<=>&#@$%!]|\b_(?=[ \t]*[\r\n])/,
        punctuation: /[{}().,:?]/
    };
    Prism.languages.vb = Prism.languages["visual-basic"];
    Prism.languages.vba = Prism.languages["visual-basic"];
}

});

parcelRequire.register("jzDEV", function(module, exports) {
"use strict";
module.exports = $e4000cae09c71730$var$warpscript;
$e4000cae09c71730$var$warpscript.displayName = "warpscript";
$e4000cae09c71730$var$warpscript.aliases = [];
function $e4000cae09c71730$var$warpscript(Prism) {
    Prism.languages.warpscript = {
        comment: /#.*|\/\/.*|\/\*[\s\S]*?\*\//,
        string: {
            pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'|<'(?:[^\\']|'(?!>)|\\.)*'>/,
            greedy: true
        },
        variable: /\$\S+/,
        macro: {
            pattern: /@\S+/,
            alias: "property"
        },
        // WarpScript doesn't have any keywords, these are all functions under the control category
        // https://www.warp10.io/tags/control
        keyword: /\b(?:BREAK|CHECKMACRO|CONTINUE|CUDF|DEFINED|DEFINEDMACRO|EVAL|FAIL|FOR|FOREACH|FORSTEP|IFT|IFTE|MSGFAIL|NRETURN|RETHROW|RETURN|SWITCH|TRY|UDF|UNTIL|WHILE)\b/,
        number: /[+-]?\b(?:NaN|Infinity|\d+(?:\.\d*)?(?:[Ee][+-]?\d+)?|0x[\da-fA-F]+|0b[01]+)\b/,
        boolean: /\b(?:F|T|false|true)\b/,
        punctuation: /<%|%>|[{}[\]()]/,
        // Some operators from the "operators" category
        // https://www.warp10.io/tags/operators
        operator: /==|&&?|\|\|?|\*\*?|>>>?|<<|[<>!~]=?|[-/%^]|\+!?|\b(?:AND|NOT|OR)\b/
    };
}

});

parcelRequire.register("hiR4N", function(module, exports) {
"use strict";
module.exports = $c98d49f55652c9bd$var$wasm;
$c98d49f55652c9bd$var$wasm.displayName = "wasm";
$c98d49f55652c9bd$var$wasm.aliases = [];
function $c98d49f55652c9bd$var$wasm(Prism) {
    Prism.languages.wasm = {
        comment: [
            /\(;[\s\S]*?;\)/,
            {
                pattern: /;;.*/,
                greedy: true
            }
        ],
        string: {
            pattern: /"(?:\\[\s\S]|[^"\\])*"/,
            greedy: true
        },
        keyword: [
            {
                pattern: /\b(?:align|offset)=/,
                inside: {
                    operator: /=/
                }
            },
            {
                pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
                inside: {
                    punctuation: /\./
                }
            },
            /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
        ],
        variable: /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
        number: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
        punctuation: /[()]/
    };
}

});

parcelRequire.register("dhnWt", function(module, exports) {
"use strict";
module.exports = $9aaf6f4fcffc30a0$var$webIdl;
$9aaf6f4fcffc30a0$var$webIdl.displayName = "webIdl";
$9aaf6f4fcffc30a0$var$webIdl.aliases = [];
function $9aaf6f4fcffc30a0$var$webIdl(Prism1) {
    (function(Prism) {
        var id = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source;
        var type = "(?:" + /\b(?:unsigned\s+)?long\s+long(?![\w-])/.source + "|" + /\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source + "|" + /(?!(?:unrestricted|unsigned)\b)/.source + id + /(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source + ")" + /(?:\s*\?)?/.source;
        var typeInside = {};
        Prism.languages["web-idl"] = {
            comment: {
                pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
                greedy: true
            },
            string: {
                pattern: /"[^"]*"/,
                greedy: true
            },
            namespace: {
                pattern: RegExp(/(\bnamespace\s+)/.source + id),
                lookbehind: true
            },
            "class-name": [
                {
                    pattern: /(^|[^\w-])(?:iterable|maplike|setlike)\s*<(?:[^<>]|<[^<>]*>)*>/,
                    lookbehind: true,
                    inside: typeInside
                },
                {
                    pattern: RegExp(/(\b(?:attribute|const|deleter|getter|optional|setter)\s+)/.source + type),
                    lookbehind: true,
                    inside: typeInside
                },
                {
                    // callback return type
                    pattern: RegExp("(" + /\bcallback\s+/.source + id + /\s*=\s*/.source + ")" + type),
                    lookbehind: true,
                    inside: typeInside
                },
                {
                    // typedef
                    pattern: RegExp(/(\btypedef\b\s*)/.source + type),
                    lookbehind: true,
                    inside: typeInside
                },
                {
                    pattern: RegExp(/(\b(?:callback|dictionary|enum|interface(?:\s+mixin)?)\s+)(?!(?:interface|mixin)\b)/.source + id),
                    lookbehind: true
                },
                {
                    // inheritance
                    pattern: RegExp(/(:\s*)/.source + id),
                    lookbehind: true
                },
                RegExp(id + /(?=\s+(?:implements|includes)\b)/.source),
                {
                    pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + id),
                    lookbehind: true
                },
                {
                    // function return type, parameter types, and dictionary members
                    pattern: RegExp(type + "(?=" + /\s*(?:\.{3}\s*)?/.source + id + /\s*[(),;=]/.source + ")"),
                    inside: typeInside
                }
            ],
            builtin: /\b(?:ArrayBuffer|BigInt64Array|BigUint64Array|ByteString|DOMString|DataView|Float32Array|Float64Array|FrozenArray|Int16Array|Int32Array|Int8Array|ObservableArray|Promise|USVString|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray)\b/,
            keyword: [
                /\b(?:async|attribute|callback|const|constructor|deleter|dictionary|enum|getter|implements|includes|inherit|interface|mixin|namespace|null|optional|or|partial|readonly|required|setter|static|stringifier|typedef|unrestricted)\b/,
                /\b(?:any|bigint|boolean|byte|double|float|iterable|long|maplike|object|octet|record|sequence|setlike|short|symbol|undefined|unsigned|void)\b/
            ],
            boolean: /\b(?:false|true)\b/,
            number: {
                pattern: /(^|[^\w-])-?(?:0x[0-9a-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|NaN|Infinity)(?![\w-])/i,
                lookbehind: true
            },
            operator: /\.{3}|[=:?<>-]/,
            punctuation: /[(){}[\].,;]/
        };
        for(var key in Prism.languages["web-idl"])if (key !== "class-name") typeInside[key] = Prism.languages["web-idl"][key];
        Prism.languages["webidl"] = Prism.languages["web-idl"];
    })(Prism1);
}

});

parcelRequire.register("khnHL", function(module, exports) {
"use strict";
module.exports = $ec37c8727dae342c$var$wiki;
$ec37c8727dae342c$var$wiki.displayName = "wiki";
$ec37c8727dae342c$var$wiki.aliases = [];
function $ec37c8727dae342c$var$wiki(Prism) {
    Prism.languages.wiki = Prism.languages.extend("markup", {
        "block-comment": {
            pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
            lookbehind: true,
            alias: "comment"
        },
        heading: {
            pattern: /^(=+)[^=\r\n].*?\1/m,
            inside: {
                punctuation: /^=+|=+$/,
                important: /.+/
            }
        },
        emphasis: {
            // TODO Multi-line
            pattern: /('{2,5}).+?\1/,
            inside: {
                "bold-italic": {
                    pattern: /(''''').+?(?=\1)/,
                    lookbehind: true,
                    alias: [
                        "bold",
                        "italic"
                    ]
                },
                bold: {
                    pattern: /(''')[^'](?:.*?[^'])?(?=\1)/,
                    lookbehind: true
                },
                italic: {
                    pattern: /('')[^'](?:.*?[^'])?(?=\1)/,
                    lookbehind: true
                },
                punctuation: /^''+|''+$/
            }
        },
        hr: {
            pattern: /^-{4,}/m,
            alias: "punctuation"
        },
        url: [
            /ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:PMID|RFC) +\d+/i,
            /\[\[.+?\]\]|\[.+?\]/
        ],
        variable: [
            /__[A-Z]+__/,
            // {{formatnum:{{#expr:{{{3}}}}}}}
            /\{{3}.+?\}{3}/,
            /\{\{.+?\}\}/
        ],
        symbol: [
            /^#redirect/im,
            /~{3,5}/
        ],
        // Handle table attrs:
        // {|
        // ! style="text-align:left;"| Item
        // |}
        "table-tag": {
            pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
            lookbehind: true,
            inside: {
                "table-bar": {
                    pattern: /\|$/,
                    alias: "punctuation"
                },
                rest: Prism.languages.markup["tag"].inside
            }
        },
        punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
    });
    Prism.languages.insertBefore("wiki", "tag", {
        // Prevent highlighting inside <nowiki>, <source> and <pre> tags
        nowiki: {
            pattern: /<(nowiki|pre|source)\b[^>]*>[\s\S]*?<\/\1>/i,
            inside: {
                tag: {
                    pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
                    inside: Prism.languages.markup["tag"].inside
                }
            }
        }
    });
}

});

parcelRequire.register("elW05", function(module, exports) {
"use strict";
module.exports = $a730048874bb22de$var$wolfram;
$a730048874bb22de$var$wolfram.displayName = "wolfram";
$a730048874bb22de$var$wolfram.aliases = [
    "mathematica",
    "wl",
    "nb"
];
function $a730048874bb22de$var$wolfram(Prism) {
    Prism.languages.wolfram = {
        // Allow one level of nesting - note: regex taken from applescipt
        comment: /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
        string: {
            pattern: /"(?:\\.|[^"\\\r\n])*"/,
            greedy: true
        },
        keyword: /\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
        context: {
            pattern: /\b\w+`+\w*/,
            alias: "class-name"
        },
        blank: {
            pattern: /\b\w+_\b/,
            alias: "regex"
        },
        "global-variable": {
            pattern: /\$\w+/,
            alias: "variable"
        },
        boolean: /\b(?:False|True)\b/,
        number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
        operator: /\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\^|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
        punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.mathematica = Prism.languages.wolfram;
    Prism.languages.wl = Prism.languages.wolfram;
    Prism.languages.nb = Prism.languages.wolfram;
}

});

parcelRequire.register("eAvOt", function(module, exports) {
"use strict";
module.exports = $a9ed1ae7cc767d96$var$wren;
$a9ed1ae7cc767d96$var$wren.displayName = "wren";
$a9ed1ae7cc767d96$var$wren.aliases = [];
function $a9ed1ae7cc767d96$var$wren(Prism) {
    // https://wren.io/
    Prism.languages.wren = {
        // Multiline comments in Wren can have nested multiline comments
        // Comments: // and /* */
        comment: [
            {
                // support 3 levels of nesting
                // regex: \/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\/
                pattern: /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
                greedy: true
            },
            {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        // Triple quoted strings are multiline but cannot have interpolation (raw strings)
        // Based on prism-python.js
        "triple-quoted-string": {
            pattern: /"""[\s\S]*?"""/,
            greedy: true,
            alias: "string"
        },
        // see below
        "string-literal": null,
        // #!/usr/bin/env wren on the first line
        hashbang: {
            pattern: /^#!\/.+/,
            greedy: true,
            alias: "comment"
        },
        // Attributes are special keywords to add meta data to classes
        attribute: {
            // #! attributes are stored in class properties
            // #!myvar = true
            // #attributes are not stored and dismissed at compilation
            pattern: /#!?[ \t\u3000]*\w+/,
            alias: "keyword"
        },
        "class-name": [
            {
                // class definition
                // class Meta {}
                pattern: /(\bclass\s+)\w+/,
                lookbehind: true
            },
            // File.read
            /\b[A-Z][a-z\d_]*\b/
        ],
        // A constant can be a variable, class, property or method. Just named in all uppercase letters
        constant: /\b[A-Z][A-Z\d_]*\b/,
        null: {
            pattern: /\bnull\b/,
            alias: "keyword"
        },
        keyword: /\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
        boolean: /\b(?:false|true)\b/,
        number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
        // Functions can be Class.method()
        function: /\b[a-z_]\w*(?=\s*[({])/i,
        operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
        punctuation: /[\[\](){}.,;]/
    };
    Prism.languages.wren["string-literal"] = {
        // A single quote string is multiline and can have interpolation (similar to JS backticks ``)
        pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
        lookbehind: true,
        greedy: true,
        inside: {
            interpolation: {
                // "%(interpolation)"
                pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
                lookbehind: true,
                inside: {
                    expression: {
                        pattern: /^(%\()[\s\S]+(?=\)$)/,
                        lookbehind: true,
                        inside: Prism.languages.wren
                    },
                    "interpolation-punctuation": {
                        pattern: /^%\(|\)$/,
                        alias: "punctuation"
                    }
                }
            },
            string: /[\s\S]+/
        }
    };
}

});

parcelRequire.register("dZzMb", function(module, exports) {
"use strict";
module.exports = $a2fcb93e258ca104$var$xeora;
$a2fcb93e258ca104$var$xeora.displayName = "xeora";
$a2fcb93e258ca104$var$xeora.aliases = [
    "xeoracube"
];
function $a2fcb93e258ca104$var$xeora(Prism1) {
    (function(Prism) {
        Prism.languages.xeora = Prism.languages.extend("markup", {
            constant: {
                pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
                inside: {
                    punctuation: {
                        pattern: /\$/
                    }
                }
            },
            variable: {
                pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
                inside: {
                    punctuation: {
                        pattern: /[$.]/
                    },
                    operator: {
                        pattern: /#+|[-+*~=^@]/
                    }
                }
            },
            "function-inline": {
                pattern: /\$F:[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\$/,
                inside: {
                    variable: {
                        pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
                        inside: {
                            punctuation: {
                                pattern: /[,.|]/
                            },
                            operator: {
                                pattern: /#+|[-+*~=^@]/
                            }
                        }
                    },
                    punctuation: {
                        pattern: /\$\w:|[$:?.,|]/
                    }
                },
                alias: "function"
            },
            "function-block": {
                pattern: /\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
                inside: {
                    punctuation: {
                        pattern: /[$:{}?.,|]/
                    }
                },
                alias: "function"
            },
            "directive-inline": {
                pattern: /\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\/\w.]+\$/,
                inside: {
                    punctuation: {
                        pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
                        inside: {
                            tag: {
                                pattern: /#\d/
                            }
                        }
                    }
                },
                alias: "function"
            },
            "directive-block-open": {
                pattern: /\$\w+:\{|\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\w.]+:\{(?:![A-Z]+)?/,
                inside: {
                    punctuation: {
                        pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
                        inside: {
                            tag: {
                                pattern: /#\d/
                            }
                        }
                    },
                    attribute: {
                        pattern: /![A-Z]+$/,
                        inside: {
                            punctuation: {
                                pattern: /!/
                            }
                        },
                        alias: "keyword"
                    }
                },
                alias: "function"
            },
            "directive-block-separator": {
                pattern: /\}:[-\w.]+:\{/,
                inside: {
                    punctuation: {
                        pattern: /[:{}]/
                    }
                },
                alias: "function"
            },
            "directive-block-close": {
                pattern: /\}:[-\w.]+\$/,
                inside: {
                    punctuation: {
                        pattern: /[:{}$]/
                    }
                },
                alias: "function"
            }
        });
        Prism.languages.insertBefore("inside", "punctuation", {
            variable: Prism.languages.xeora["function-inline"].inside["variable"]
        }, Prism.languages.xeora["function-block"]);
        Prism.languages.xeoracube = Prism.languages.xeora;
    })(Prism1);
}

});

parcelRequire.register("lmtug", function(module, exports) {
"use strict";
module.exports = $f8d2868ecdc82ee7$var$xmlDoc;
$f8d2868ecdc82ee7$var$xmlDoc.displayName = "xmlDoc";
$f8d2868ecdc82ee7$var$xmlDoc.aliases = [];
function $f8d2868ecdc82ee7$var$xmlDoc(Prism1) {
    (function(Prism) {
        /**
     * If the given language is present, it will insert the given doc comment grammar token into it.
     *
     * @param {string} lang
     * @param {any} docComment
     */ function insertDocComment(lang, docComment) {
            if (Prism.languages[lang]) Prism.languages.insertBefore(lang, "comment", {
                "doc-comment": docComment
            });
        }
        var tag = Prism.languages.markup.tag;
        var slashDocComment = {
            pattern: /\/\/\/.*/,
            greedy: true,
            alias: "comment",
            inside: {
                tag: tag
            }
        };
        var tickDocComment = {
            pattern: /'''.*/,
            greedy: true,
            alias: "comment",
            inside: {
                tag: tag
            }
        };
        insertDocComment("csharp", slashDocComment);
        insertDocComment("fsharp", slashDocComment);
        insertDocComment("vbnet", tickDocComment);
    })(Prism1);
}

});

parcelRequire.register("h2JX7", function(module, exports) {
"use strict";
module.exports = $c68644cb6b0ccb54$var$xojo;
$c68644cb6b0ccb54$var$xojo.displayName = "xojo";
$c68644cb6b0ccb54$var$xojo.aliases = [];
function $c68644cb6b0ccb54$var$xojo(Prism) {
    Prism.languages.xojo = {
        comment: {
            pattern: /(?:'|\/\/|Rem\b).+/i,
            greedy: true
        },
        string: {
            pattern: /"(?:""|[^"])*"/,
            greedy: true
        },
        number: [
            /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
            /&[bchou][a-z\d]+/i
        ],
        directive: {
            pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\b/i,
            alias: "property"
        },
        keyword: /\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\b/i,
        operator: /<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\b/i,
        punctuation: /[.,;:()]/
    };
}

});

parcelRequire.register("hoLge", function(module, exports) {
"use strict";
module.exports = $caa95693b5aa8058$var$xquery;
$caa95693b5aa8058$var$xquery.displayName = "xquery";
$caa95693b5aa8058$var$xquery.aliases = [];
function $caa95693b5aa8058$var$xquery(Prism1) {
    (function(Prism) {
        Prism.languages.xquery = Prism.languages.extend("markup", {
            "xquery-comment": {
                pattern: /\(:[\s\S]*?:\)/,
                greedy: true,
                alias: "comment"
            },
            string: {
                pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
                greedy: true
            },
            extension: {
                pattern: /\(#.+?#\)/,
                alias: "symbol"
            },
            variable: /\$[-\w:]+/,
            axis: {
                pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
                lookbehind: true,
                alias: "operator"
            },
            "keyword-operator": {
                pattern: /(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
                lookbehind: true,
                alias: "operator"
            },
            keyword: {
                pattern: /(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
                lookbehind: true
            },
            function: /[\w-]+(?::[\w-]+)*(?=\s*\()/,
            "xquery-element": {
                pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
                lookbehind: true,
                alias: "tag"
            },
            "xquery-attribute": {
                pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
                lookbehind: true,
                alias: "attr-name"
            },
            builtin: {
                pattern: /(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
                lookbehind: true
            },
            number: /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
            operator: [
                /[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/,
                {
                    pattern: /(\s)-(?=\s)/,
                    lookbehind: true
                }
            ],
            punctuation: /[[\](){},;:/]/
        });
        Prism.languages.xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
        Prism.languages.xquery["tag"].inside["attr-value"].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/;
        Prism.languages.xquery["tag"].inside["attr-value"].inside["punctuation"] = /^="|"$/;
        Prism.languages.xquery["tag"].inside["attr-value"].inside["expression"] = {
            // Allow for two levels of nesting
            pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
            inside: Prism.languages.xquery,
            alias: "language-xquery"
        } // The following will handle plain text inside tags
        ;
        var stringifyToken = function(token) {
            if (typeof token === "string") return token;
            if (typeof token.content === "string") return token.content;
            return token.content.map(stringifyToken).join("");
        };
        var walkTokens = function(tokens) {
            var openedTags = [];
            for(var i = 0; i < tokens.length; i++){
                var token = tokens[i];
                var notTagNorBrace = false;
                if (typeof token !== "string") {
                    if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
                        // We found a tag, now find its kind
                        if (token.content[0].content[0].content === "</") // Closing tag
                        {
                            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) // Pop matching opening tag
                            openedTags.pop();
                        } else {
                            if (token.content[token.content.length - 1].content === "/>") ;
                            else // Opening tag
                            openedTags.push({
                                tagName: stringifyToken(token.content[0].content[1]),
                                openedBraces: 0
                            });
                        }
                    } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{" && (!tokens[i + 1] || tokens[i + 1].type !== "punctuation" || tokens[i + 1].content !== "{") && (!tokens[i - 1] || tokens[i - 1].type !== "plain-text" || tokens[i - 1].content !== "{")) // Here we might have entered an XQuery expression inside a tag
                    openedTags[openedTags.length - 1].openedBraces++;
                    else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") // Here we might have left an XQuery expression inside a tag
                    openedTags[openedTags.length - 1].openedBraces--;
                    else if (token.type !== "comment") notTagNorBrace = true;
                }
                if (notTagNorBrace || typeof token === "string") {
                    if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
                        // Here we are inside a tag, and not inside an XQuery expression.
                        // That's plain text: drop any tokens matched.
                        var plainText = stringifyToken(token) // And merge text with adjacent text
                        ;
                        if (i < tokens.length - 1 && (typeof tokens[i + 1] === "string" || tokens[i + 1].type === "plain-text")) {
                            plainText += stringifyToken(tokens[i + 1]);
                            tokens.splice(i + 1, 1);
                        }
                        if (i > 0 && (typeof tokens[i - 1] === "string" || tokens[i - 1].type === "plain-text")) {
                            plainText = stringifyToken(tokens[i - 1]) + plainText;
                            tokens.splice(i - 1, 1);
                            i--;
                        }
                        if (/^\s+$/.test(plainText)) tokens[i] = plainText;
                        else tokens[i] = new Prism.Token("plain-text", plainText, null, plainText);
                    }
                }
                if (token.content && typeof token.content !== "string") walkTokens(token.content);
            }
        };
        Prism.hooks.add("after-tokenize", function(env) {
            if (env.language !== "xquery") return;
            walkTokens(env.tokens);
        });
    })(Prism1);
}

});

parcelRequire.register("ke4lE", function(module, exports) {
"use strict";
module.exports = $eb987ce54366db1c$var$yang;
$eb987ce54366db1c$var$yang.displayName = "yang";
$eb987ce54366db1c$var$yang.aliases = [];
function $eb987ce54366db1c$var$yang(Prism) {
    Prism.languages.yang = {
        // https://tools.ietf.org/html/rfc6020#page-34
        // http://www.yang-central.org/twiki/bin/view/Main/YangExamples
        comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
        string: {
            pattern: /"(?:[^\\"]|\\.)*"|'[^']*'/,
            greedy: true
        },
        keyword: {
            pattern: /(^|[{};\r\n][ \t]*)[a-z_][\w.-]*/i,
            lookbehind: true
        },
        namespace: {
            pattern: /(\s)[a-z_][\w.-]*(?=:)/i,
            lookbehind: true
        },
        boolean: /\b(?:false|true)\b/,
        operator: /\+/,
        punctuation: /[{};:]/
    };
}

});

parcelRequire.register("dmftH", function(module, exports) {
"use strict";
module.exports = $9b99560e586c3aa0$var$zig;
$9b99560e586c3aa0$var$zig.displayName = "zig";
$9b99560e586c3aa0$var$zig.aliases = [];
function $9b99560e586c3aa0$var$zig(Prism1) {
    (function(Prism) {
        function literal(str) {
            return function() {
                return str;
            };
        }
        var keyword = /\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/;
        var IDENTIFIER = "\\b(?!" + keyword.source + ")(?!\\d)\\w+\\b";
        var ALIGN = /align\s*\((?:[^()]|\([^()]*\))*\)/.source;
        var PREFIX_TYPE_OP = /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(/<ALIGN>/g, literal(ALIGN));
        var SUFFIX_EXPR = /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(/<ID>/g, literal(IDENTIFIER));
        var TYPE = "(?!\\s)(?:!?\\s*(?:" + PREFIX_TYPE_OP + "\\s*)*" + SUFFIX_EXPR + ")+";
        /*
     * A simplified grammar for Zig compile time type literals:
     *
     * TypeExpr = ( "!"? PREFIX_TYPE_OP* SUFFIX_EXPR )+
     *
     * SUFFIX_EXPR = ( \b "promise" \b | ( \b "error" "." )? IDENTIFIER ( "." IDENTIFIER )* (?! \s+ IDENTIFIER ) )
     *
     * PREFIX_TYPE_OP = "?"
     *                | \b "promise" "->"
     *                | ( "[" [^\[\]]* "]" | "*" | "**" ) ( ALIGN | "const" \b | "volatile" \b | "allowzero" \b )*
     *
     * ALIGN = "align" "(" ( [^()] | "(" [^()]* ")" )* ")"
     *
     * IDENTIFIER = \b (?! KEYWORD ) [a-zA-Z_] \w* \b
     *
     */ Prism.languages.zig = {
            comment: [
                {
                    pattern: /\/\/[/!].*/,
                    alias: "doc-comment"
                },
                /\/{2}.*/
            ],
            string: [
                {
                    // "string" and c"string"
                    pattern: /(^|[^\\@])c?"(?:[^"\\\r\n]|\\.)*"/,
                    lookbehind: true,
                    greedy: true
                },
                {
                    // multiline strings and c-strings
                    pattern: /([\r\n])([ \t]+c?\\{2}).*(?:(?:\r\n?|\n)\2.*)*/,
                    lookbehind: true,
                    greedy: true
                }
            ],
            char: {
                // characters 'a', '\n', '\xFF', '\u{10FFFF}'
                pattern: /(^|[^\\])'(?:[^'\\\r\n]|[\uD800-\uDFFF]{2}|\\(?:.|x[a-fA-F\d]{2}|u\{[a-fA-F\d]{1,6}\}))'/,
                lookbehind: true,
                greedy: true
            },
            builtin: /\B@(?!\d)\w+(?=\s*\()/,
            label: {
                pattern: /(\b(?:break|continue)\s*:\s*)\w+\b|\b(?!\d)\w+\b(?=\s*:\s*(?:\{|while\b))/,
                lookbehind: true
            },
            "class-name": [
                // const Foo = struct {};
                /\b(?!\d)\w+(?=\s*=\s*(?:(?:extern|packed)\s+)?(?:enum|struct|union)\s*[({])/,
                {
                    // const x: i32 = 9;
                    // var x: Bar;
                    // fn foo(x: bool, y: f32) void {}
                    pattern: RegExp(/(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),
                    lookbehind: true,
                    inside: null // see below
                },
                {
                    // extern fn foo(x: f64) f64; (optional alignment)
                    pattern: RegExp(/(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))),
                    lookbehind: true,
                    inside: null // see below
                }
            ],
            "builtin-type": {
                pattern: /\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\b/,
                alias: "keyword"
            },
            keyword: keyword,
            function: /\b(?!\d)\w+(?=\s*\()/,
            number: /\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\d]+(?:\.[a-fA-F\d]*)?(?:[pP][+-]?[a-fA-F\d]+)?|\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\b/,
            boolean: /\b(?:false|true)\b/,
            operator: /\.[*?]|\.{2,3}|[-=]>|\*\*|\+\+|\|\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,
            punctuation: /[.:,;(){}[\]]/
        };
        Prism.languages.zig["class-name"].forEach(function(obj) {
            if (obj.inside === null) obj.inside = Prism.languages.zig;
        });
    })(Prism1);
}

});


parcelRequire.register("4ewR7", function(module, exports) {

$parcel$export(module.exports, "default", () => $3151f4b102c5f466$export$2e2bcd8739ae039);
var //
// This file has been auto-generated by the `npm run build-languages-prism` task
//
$3151f4b102c5f466$export$2e2bcd8739ae039 = [
    "abap",
    "abnf",
    "actionscript",
    "ada",
    "agda",
    "al",
    "antlr4",
    "apacheconf",
    "apex",
    "apl",
    "applescript",
    "aql",
    "arduino",
    "arff",
    "asciidoc",
    "asm6502",
    "asmatmel",
    "aspnet",
    "autohotkey",
    "autoit",
    "avisynth",
    "avro-idl",
    "bash",
    "basic",
    "batch",
    "bbcode",
    "bicep",
    "birb",
    "bison",
    "bnf",
    "brainfuck",
    "brightscript",
    "bro",
    "bsl",
    "c",
    "cfscript",
    "chaiscript",
    "cil",
    "clike",
    "clojure",
    "cmake",
    "cobol",
    "coffeescript",
    "concurnas",
    "coq",
    "cpp",
    "crystal",
    "csharp",
    "cshtml",
    "csp",
    "css-extras",
    "css",
    "csv",
    "cypher",
    "d",
    "dart",
    "dataweave",
    "dax",
    "dhall",
    "diff",
    "django",
    "dns-zone-file",
    "docker",
    "dot",
    "ebnf",
    "editorconfig",
    "eiffel",
    "ejs",
    "elixir",
    "elm",
    "erb",
    "erlang",
    "etlua",
    "excel-formula",
    "factor",
    "false",
    "firestore-security-rules",
    "flow",
    "fortran",
    "fsharp",
    "ftl",
    "gap",
    "gcode",
    "gdscript",
    "gedcom",
    "gherkin",
    "git",
    "glsl",
    "gml",
    "gn",
    "go-module",
    "go",
    "graphql",
    "groovy",
    "haml",
    "handlebars",
    "haskell",
    "haxe",
    "hcl",
    "hlsl",
    "hoon",
    "hpkp",
    "hsts",
    "http",
    "ichigojam",
    "icon",
    "icu-message-format",
    "idris",
    "iecst",
    "ignore",
    "inform7",
    "ini",
    "io",
    "j",
    "java",
    "javadoc",
    "javadoclike",
    "javascript",
    "javastacktrace",
    "jexl",
    "jolie",
    "jq",
    "js-extras",
    "js-templates",
    "jsdoc",
    "json",
    "json5",
    "jsonp",
    "jsstacktrace",
    "jsx",
    "julia",
    "keepalived",
    "keyman",
    "kotlin",
    "kumir",
    "kusto",
    "latex",
    "latte",
    "less",
    "lilypond",
    "liquid",
    "lisp",
    "livescript",
    "llvm",
    "log",
    "lolcode",
    "lua",
    "magma",
    "makefile",
    "markdown",
    "markup-templating",
    "markup",
    "matlab",
    "maxscript",
    "mel",
    "mermaid",
    "mizar",
    "mongodb",
    "monkey",
    "moonscript",
    "n1ql",
    "n4js",
    "nand2tetris-hdl",
    "naniscript",
    "nasm",
    "neon",
    "nevod",
    "nginx",
    "nim",
    "nix",
    "nsis",
    "objectivec",
    "ocaml",
    "opencl",
    "openqasm",
    "oz",
    "parigp",
    "parser",
    "pascal",
    "pascaligo",
    "pcaxis",
    "peoplecode",
    "perl",
    "php-extras",
    "php",
    "phpdoc",
    "plsql",
    "powerquery",
    "powershell",
    "processing",
    "prolog",
    "promql",
    "properties",
    "protobuf",
    "psl",
    "pug",
    "puppet",
    "pure",
    "purebasic",
    "purescript",
    "python",
    "q",
    "qml",
    "qore",
    "qsharp",
    "r",
    "racket",
    "reason",
    "regex",
    "rego",
    "renpy",
    "rest",
    "rip",
    "roboconf",
    "robotframework",
    "ruby",
    "rust",
    "sas",
    "sass",
    "scala",
    "scheme",
    "scss",
    "shell-session",
    "smali",
    "smalltalk",
    "smarty",
    "sml",
    "solidity",
    "solution-file",
    "soy",
    "sparql",
    "splunk-spl",
    "sqf",
    "sql",
    "squirrel",
    "stan",
    "stylus",
    "swift",
    "systemd",
    "t4-cs",
    "t4-templating",
    "t4-vb",
    "tap",
    "tcl",
    "textile",
    "toml",
    "tremor",
    "tsx",
    "tt2",
    "turtle",
    "twig",
    "typescript",
    "typoscript",
    "unrealscript",
    "uorazor",
    "uri",
    "v",
    "vala",
    "vbnet",
    "velocity",
    "verilog",
    "vhdl",
    "vim",
    "visual-basic",
    "warpscript",
    "wasm",
    "web-idl",
    "wiki",
    "wolfram",
    "wren",
    "xeora",
    "xml-doc",
    "xojo",
    "xquery",
    "yaml",
    "yang",
    "zig"
];

});



parcelRequire.register("eZCyD", function(module, exports) {

$parcel$export(module.exports, "default", () => $aea4abec48a6349f$export$2e2bcd8739ae039);
var $aea4abec48a6349f$export$2e2bcd8739ae039 = {
    'code[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "none",
        "fontFamily": "\"Fira Code\", Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
    },
    'pre[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "#2E3440",
        "fontFamily": "\"Fira Code\", Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em"
    },
    ':not(pre) > code[class*="language-"]': {
        "background": "#2E3440",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
    },
    "comment": {
        "color": "#636f88"
    },
    "prolog": {
        "color": "#636f88"
    },
    "doctype": {
        "color": "#636f88"
    },
    "cdata": {
        "color": "#636f88"
    },
    "punctuation": {
        "color": "#81A1C1"
    },
    ".namespace": {
        "Opacity": ".7"
    },
    "property": {
        "color": "#81A1C1"
    },
    "tag": {
        "color": "#81A1C1"
    },
    "constant": {
        "color": "#81A1C1"
    },
    "symbol": {
        "color": "#81A1C1"
    },
    "deleted": {
        "color": "#81A1C1"
    },
    "number": {
        "color": "#B48EAD"
    },
    "boolean": {
        "color": "#81A1C1"
    },
    "selector": {
        "color": "#A3BE8C"
    },
    "attr-name": {
        "color": "#A3BE8C"
    },
    "string": {
        "color": "#A3BE8C"
    },
    "char": {
        "color": "#A3BE8C"
    },
    "builtin": {
        "color": "#A3BE8C"
    },
    "inserted": {
        "color": "#A3BE8C"
    },
    "operator": {
        "color": "#81A1C1"
    },
    "entity": {
        "color": "#81A1C1",
        "cursor": "help"
    },
    "url": {
        "color": "#81A1C1"
    },
    ".language-css .token.string": {
        "color": "#81A1C1"
    },
    ".style .token.string": {
        "color": "#81A1C1"
    },
    "variable": {
        "color": "#81A1C1"
    },
    "atrule": {
        "color": "#88C0D0"
    },
    "attr-value": {
        "color": "#88C0D0"
    },
    "function": {
        "color": "#88C0D0"
    },
    "class-name": {
        "color": "#88C0D0"
    },
    "keyword": {
        "color": "#81A1C1"
    },
    "regex": {
        "color": "#EBCB8B"
    },
    "important": {
        "color": "#EBCB8B",
        "fontWeight": "bold"
    },
    "bold": {
        "fontWeight": "bold"
    },
    "italic": {
        "fontStyle": "italic"
    }
};

});




//# sourceMappingURL=payment.86357596.js.map
