{"mappings":"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","sources":["src/ui/components/increment-number/increment-number.mdx","src/ui/components/increment-number/increment-number.tsx","node_modules/bezier-easing/src/index.js"],"sourcesContent":["import {ReactHtmlRender} from \"../../react-html-render\";\nimport \"./increment-number.tsx\"\nimport {html} from \"lit\";\nconst template = html`\n    <increment-number from=\"2\"\n                      to=\"0\"\n                      min-decimals=\"2\"\n                      max-decimals=\"2\"\n                      seconds-duration=\"5\"\n                      bezier=\"1,0,1,0.41\">0</increment-number>%\n`\n\n<ReactHtmlRender html={template}/>","import {CustomElement} from \"../../ui-types\";\nimport {component} from \"haunted\";\nimport {useEffect, useRef, useState} from \"haunted/lib/core\";\nimport BezierEasing from \"bezier-easing\";\nimport {Nullable} from \"../../../_/types\";\n\nconst attributes = [\n    \"from\",\n    \"to\",\n    \"bezier\",\n    \"seconds-duration\",\n    \"max-decimals\",\n    \"min-decimals\",\n    \"once\"\n];\n\ntype IncrementNumberType = { from: string, to: string, bezier: string, secondsDuration: string, maxDecimals: string, minDecimals: string, once: boolean | string };\n\nexport const IncrementNumber:CustomElement<IncrementNumberType> = function({from, to, bezier, secondsDuration, maxDecimals, minDecimals, once}) {\n    const attr = {\n        bezier: bezier ?? \"1, 0, 1, 1\",\n        secondsDuration: secondsDuration ?? \"2\",\n        maxDecimals: maxDecimals ?? \"0\",\n        minDecimals: minDecimals ?? \"0\",\n        from: from ?? \"0\",\n        to: to\n    };\n\n    if (!attr.to) console.warn(this, \"Expected input 'to'\")\n\n    const fromTimeRef = useRef(null as Nullable<number>)\n    const bezierRef = useRef(null as Nullable<BezierEasing.EasingFunction>);\n    const updateCurrentRef = useRef(null as Nullable<() => void>);\n\n    useEffect(() => {\n        const updateCurrent = () => {\n            bezierRef.current = BezierEasing(...attr.bezier.split(\",\") as unknown as [number, number, number, number])\n            fromTimeRef.current = Date.now();\n            const fmt = new Intl.NumberFormat(undefined, {maximumFractionDigits: +attr.maxDecimals, minimumFractionDigits: +attr.minDecimals})\n\n            const potato = () => {\n                const duration = +attr.secondsDuration * 1000;\n                const toTime = fromTimeRef.current! + duration\n                const pointInLinearCurve = (duration - (toTime - Date.now())) / duration\n                const pointInBezier = bezierRef.current!(pointInLinearCurve > 1 ? 1 : pointInLinearCurve < 0 ? 0 : pointInLinearCurve)\n\n\n                const numberFrom = +attr.from;\n                const numberTo = +attr.to;\n                const diff = numberTo - numberFrom;\n\n                const current = (pointInBezier * (diff) + numberFrom);\n                this.textContent = fmt.format(current);\n\n                if (pointInBezier < 1) {\n                    requestAnimationFrame(potato);\n                }\n            };\n\n            potato()\n        }\n\n        updateCurrentRef.current = updateCurrent;\n    }, [from, to])\n\n    useEffect(() => {\n        const observerEnter = new IntersectionObserver((elms) => {\n            if (elms[0]?.isIntersecting) updateCurrentRef.current?.();\n            if (elms[0]?.isIntersecting && once) observerEnter.disconnect();\n        }, {threshold: 1});\n        observerEnter.observe(this);\n\n        if (once) return\n\n        const observerExit = new IntersectionObserver((elms) => {\n            if (!elms[0]?.isIntersecting) this.textContent = attr.from;\n        });\n        observerExit.observe(this);\n\n\n    }, [])\n}\n\ncustomElements.define(\"increment-number\", component(IncrementNumber, {useShadowDOM: false, observedAttributes: attributes as any}));\n\ndeclare global {\n    interface HTMLElementTagNameMap {\n        \"increment-number\": IncrementNumberType\n    }\n}","/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n   var currentSlope = getSlope(aGuessT, mX1, mX2);\n   if (currentSlope === 0.0) {\n     return aGuessT;\n   }\n   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n   aGuessT -= currentX / currentSlope;\n }\n return aGuessT;\n}\n\nfunction LinearEasing (x) {\n  return x;\n}\n\nmodule.exports = function bezier (mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n\n  // Precompute samples table\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing (x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n"],"names":["parcelRequire","$a7edb88169da87ad$var$template","html","$a7edb88169da87ad$var$layoutProps","$a7edb88169da87ad$export$2e2bcd8739ae039","components","props","$di58i","mdx","mdxType","$dlCTC","ReactHtmlRender","isMDXComponent","$9so9i","customElements","define","component","from","to","bezier","secondsDuration","maxDecimals","minDecimals","once","attr","console","warn","this","fromTimeRef","$2NXZw","useRef","bezierRef","updateCurrentRef","useEffect","current","$parcel$interopDefault","$lzqXA","split","Date","now","fmt","Intl","NumberFormat","undefined","maximumFractionDigits","minimumFractionDigits","potato","duration","pointInLinearCurve","pointInBezier","numberFrom","textContent","format","requestAnimationFrame","observerEnter","IntersectionObserver","elms","isIntersecting","disconnect","threshold","observe","useShadowDOM","observedAttributes","$fb41c7946c519673$var$kSampleStepSize","$fb41c7946c519673$var$float32ArraySupported","Float32Array","$fb41c7946c519673$var$A","aA1","aA2","$fb41c7946c519673$var$B","$fb41c7946c519673$var$C","$fb41c7946c519673$var$calcBezier","aT","$fb41c7946c519673$var$getSlope","$fb41c7946c519673$var$LinearEasing","x","module","exports","mX1","mY1","mX2","mY2","Error","sampleValues","Array","i","getTForX","aX","intervalStart","currentSample","$fb41c7946c519673$var$kSplineTableSize","guessForT","initialSlope","aGuessT","currentSlope","$fb41c7946c519673$var$newtonRaphsonIterate","aA","aB","currentX","currentT","Math","abs","$fb41c7946c519673$var$binarySubdivide"],"version":3,"file":"increment-number.ffeabc8e.js.map"}