{"mappings":"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","sources":["src/lib/index.ts","src/lib/state.ts","src/app/state/index.ts","inline-error.ts"],"sourcesContent":["export * from \"./state\";","export {State} from \"../app/state\"","import produce from \"immer\";\nimport {inlineErr} from \"../../../inline-error\";\nimport {Dictionary, Undefinable} from \"../../../types\";\nimport {DeepReadonly} from \"utility-types\";\n\ntype Subscription<T = any> = (prev:Undefinable<StateData<T>>, current:StateData<T>) => void;\n\ntype Updater<T extends Dictionary<any>> = (() => T | Promise<T>) | ((draftState: T) => void | Promise<void>);\n\ntype StateData<T> = {\n    state: T,\n    isUpdating: boolean,\n    error: any\n}\n\nexport class State<T extends Dictionary<any>> {\n\n    private state: T;\n    private prevState: Undefinable<StateData<T>>;\n\n    private subscriptions: Subscription<T>[] = [];\n    private readonly initialState: T;\n    private hold = false;\n    private queue: (() => void)[] = [];\n\n    public isUpdating = false;\n    public error: any;\n\n    private static instances: State<any>[] = []\n\n    constructor(public readonly id: string, state: T, opts?: {preventInstanceTracking: boolean}) {\n        this.state = state;\n        this.initialState = state;\n        if (!opts?.preventInstanceTracking) {\n            State.instances.push(this);\n        }\n    }\n\n    static getInstances() {\n        return State.instances;\n    }\n\n    getState(): T {\n        return this.state\n    }\n\n    private getStateData(): StateData<T> {\n        return {\n            state: this.state,\n            error: this.error,\n            isUpdating: this.isUpdating\n        }\n    }\n\n    resetState() {\n        this.prevState = this.getStateData();\n        this.state = {...this.initialState};\n        this.runSubscribers();\n    }\n\n    getInitialState(): DeepReadonly<T> {\n        return this.initialState as DeepReadonly<T>;\n    }\n\n    /**\n     * This method defers updates for the next `releaseUpdates()` call.\n     *\n     * Very useful for apps startup, where you may want to start with external data, but since it's an async task,\n     * you do not want your subscribers reacting until you fetch it\n     *\n     * @example using hold\n     *     //counter-state.js\n     *     const state = new State({count: 0}));\n     *     state.hold();\n     *\n     *     //counter-ui.js\n     *     state.update(s => {s.count = s.count + 1});\n     *\n     *     //counter-fetcher.js\n     *     const userCount = await loadUserCount(); //10\n     *     state.releaseUpdates(s = > {s.count = userCount});\n     *\n     *     //result.js (after all is run)\n     *     state.getState().count //RESULT IS: 11\n     */\n    holdUpdates(): void {\n        this.hold = true;\n    }\n\n    /**\n     * This method release all updates that were on hold, check `holdUpdate()` to learn more\n     * @param priorUpdate Queued tasks will be run against the result of this param\n     */\n    async releaseUpdates(priorUpdate?: Updater<T>): Promise<void> {\n        const queue = this.queue;\n        this.queue = [];\n\n        this.hold = false;\n\n        if (priorUpdate) {\n            await this.update(priorUpdate);\n        }\n\n        for (let queueElement of queue) {\n            //Each loop will trigger this state subscriber, it's intentional\n            //if one of the update takes too long as it's async\n            //we want the respective subscribers listen to the changes as soon as possible\n            await this.update(queueElement);\n        }\n    }\n\n    async update(updater: Updater<T>, opts?: {}): Promise<void> {\n        if (this.hold) {\n            return new Promise<void>((resolve, reject) => {\n                this.queue.push(() => {\n                    this.update(updater).then(resolve).catch(reject);\n                });\n            })\n        }\n\n        const produceResult = produce(this.state, updater as any);\n\n        if (produceResult instanceof Promise) {\n            this.prevState = this.getStateData();\n            this.isUpdating = true;\n            this.runSubscribers();\n        }\n\n        const [result, err] = await inlineErr(produceResult);\n        this.prevState = this.getStateData();\n\n        this.isUpdating = false;\n        if (err) {\n            this.error = err;\n            this.runSubscribers();\n            throw err;\n        } else {\n            this.state = result!;\n            this.runSubscribers();\n        }\n    }\n\n    clearError() {\n        this.prevState = this.getStateData();\n        this.error = undefined;\n        this.runSubscribers();\n    }\n\n    subscribe(subscription: Subscription<T>): () => Boolean {\n        this.subscriptions.push(subscription);\n        subscription(this.prevState, this.getStateData());\n        return () => this.unsubscribe(subscription);\n    }\n\n    runSubscribers() {\n        this.subscriptions.forEach(it => it(this.prevState, this.getStateData()));\n    }\n\n    unsubscribe(subscription: Subscription): Boolean {\n        const indexFound = this.subscriptions.indexOf(subscription);\n        const deletedItem = this.subscriptions.splice(indexFound, 1);\n        return Boolean(deletedItem);\n    }\n}\n\nexport const stateLoggerInjector = (logName: string, state: State<any>) => {\n    console.log(stateLoggerInjector.name, \"Started\");\n\n    state.subscribe(() => {\n        console.groupCollapsed(`State ${logName}`);\n        console.log(\"data:\", state.getState());\n        console.log(\"updating:\", state.isUpdating);\n        console.log(\"error:\", state.error);\n        console.groupEnd();\n    })\n}","export async function inlineErr<T = any>(arg: Promise<T> | T, preventLog?: boolean): Promise<[T | undefined, Error?]> {\n    try {\n        return [await arg];\n    } catch (err) {\n        if (!preventLog) {\n            console.error(err);\n        }\n        return [undefined, err as any];\n    }\n}"],"names":[],"version":3,"file":"index.js.map"}