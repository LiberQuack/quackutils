{"mappings":"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","sources":["src/ui.ts","src/ui/components/increment-number/increment-number.tsx","node_modules/haunted/lib/haunted.js","node_modules/haunted/lib/lit-haunted.js","node_modules/haunted/lib/core.js","node_modules/haunted/lib/component.js","node_modules/haunted/lib/scheduler.js","node_modules/haunted/lib/state.js","node_modules/haunted/lib/interface.js","node_modules/haunted/lib/symbols.js","node_modules/haunted/lib/create-context.js","node_modules/haunted/lib/use-context.js","node_modules/haunted/lib/hook.js","node_modules/haunted/lib/use-effect.js","node_modules/haunted/lib/create-effect.js","node_modules/haunted/lib/use-callback.js","node_modules/haunted/lib/use-memo.js","node_modules/haunted/lib/use-controller.js","node_modules/haunted/lib/use-layout-effect.js","node_modules/haunted/lib/use-state.js","node_modules/haunted/lib/use-reducer.js","node_modules/haunted/lib/use-ref.js","node_modules/haunted/lib/virtual.js","node_modules/lit-html/src/directive.ts","node_modules/lit-html/src/async-directive.ts","node_modules/lit-html/src/directive-helpers.ts","node_modules/bezier-easing/src/index.js","src/ui/components/timer-element/timer-element.tsx","src/ui/components/payments/stripe/stripe-context.tsx","src/ui/components/payments/stripe/stripe-form.tsx","src/ui/util/hooks/use-await.ts","src/_/inline-error.ts","src/ui/util/css.ts","node_modules/@parcel/runtime-js/lib/runtime-07f0e9e0dbab7610.js","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","src/ui/components/payments/stripe/stripe-elements.tsx"],"sourcesContent":["export * from \"./ui/components/increment-number/increment-number\"\nexport * from \"./ui/components/timer-element/timer-element\"\nexport * from \"./ui/components/payments/stripe/stripe-context\"\nexport * from \"./ui/components/payments/stripe/stripe-form\"\nexport * from \"./ui/components/payments/stripe/stripe-elements\"","import {CustomElement, CustomElementDefinition} from \"../../ui-types\";\nimport {component} from \"haunted\";\nimport {useEffect, useRef, useState} from \"haunted/lib/core\";\nimport BezierEasing from \"bezier-easing\";\nimport {Nullable} from \"../../../_/types\";\n\nconst attributes = [\n    \"from\",\n    \"to\",\n    \"bezier\",\n    \"seconds-duration\",\n    \"max-decimals\",\n    \"min-decimals\",\n    \"once\"\n];\n\ntype IncrementNumberType = { from: string, to: string, bezier: string, secondsDuration: string, maxDecimals: string, minDecimals: string, once: boolean | string };\n\nexport const IncrementNumber:CustomElementDefinition<IncrementNumberType> = function({from, to, bezier, secondsDuration, maxDecimals, minDecimals, once}) {\n    const attr = {\n        bezier: bezier ?? \"1, 0, 1, 1\",\n        secondsDuration: secondsDuration ?? \"2\",\n        maxDecimals: maxDecimals ?? \"0\",\n        minDecimals: minDecimals ?? \"0\",\n        from: from ?? \"0\",\n        to: to\n    };\n\n    if (!attr.to) console.warn(this, \"Expected input 'to'\")\n\n    const fromTimeRef = useRef(null as Nullable<number>)\n    const bezierRef = useRef(null as Nullable<BezierEasing.EasingFunction>);\n    const updateCurrentRef = useRef(null as Nullable<() => void>);\n\n    useEffect(() => {\n        const updateCurrent = () => {\n            bezierRef.current = BezierEasing(...attr.bezier.split(\",\") as unknown as [number, number, number, number])\n            fromTimeRef.current = Date.now();\n            const fmt = new Intl.NumberFormat(undefined, {maximumFractionDigits: +attr.maxDecimals, minimumFractionDigits: +attr.minDecimals})\n\n            const potato = () => {\n                const duration = +attr.secondsDuration * 1000;\n                const toTime = fromTimeRef.current! + duration\n                const pointInLinearCurve = (duration - (toTime - Date.now())) / duration\n                const pointInBezier = bezierRef.current!(pointInLinearCurve > 1 ? 1 : pointInLinearCurve < 0 ? 0 : pointInLinearCurve)\n\n\n                const numberFrom = +attr.from;\n                const numberTo = +attr.to;\n                const diff = numberTo - numberFrom;\n\n                const current = (pointInBezier * (diff) + numberFrom);\n                this.textContent = fmt.format(current);\n\n                if (pointInBezier < 1) {\n                    requestAnimationFrame(potato);\n                }\n            };\n\n            potato()\n        }\n\n        updateCurrentRef.current = updateCurrent;\n    }, [from, to])\n\n    useEffect(() => {\n        const observerEnter = new IntersectionObserver((elms) => {\n            if (elms[0]?.isIntersecting) updateCurrentRef.current?.();\n            if (elms[0]?.isIntersecting && once) observerEnter.disconnect();\n        }, {threshold: 1});\n        observerEnter.observe(this);\n\n        if (once) return\n\n        const observerExit = new IntersectionObserver((elms) => {\n            if (!elms[0]?.isIntersecting) this.textContent = attr.from;\n        });\n        observerExit.observe(this);\n\n\n    }, [])\n}\n\ncustomElements.define(\"increment-number\", component(IncrementNumber, {useShadowDOM: false, observedAttributes: attributes as any}));\n\ndeclare global {\n    interface HTMLElementTagNameMap {\n        \"increment-number\": CustomElement<IncrementNumberType>\n    }\n}","export { html, render, component, createContext, virtual } from './lit-haunted.js';\nexport * from './core.js';\nexport { default } from './core.js';\n","import { html, render } from 'lit';\nimport haunted from './core.js';\nimport { makeVirtual } from './virtual.js';\nconst { component, createContext } = haunted({ render });\nconst virtual = makeVirtual();\nexport { component, createContext, virtual, html, render };\n","import { makeComponent } from './component.js';\nimport { makeContext } from './create-context.js';\nfunction haunted({ render }) {\n    const component = makeComponent(render);\n    const createContext = makeContext(component);\n    return { component, createContext };\n}\nexport { haunted as default };\nexport { useCallback } from './use-callback.js';\nexport { useController } from './use-controller.js';\nexport { useEffect } from './use-effect.js';\nexport { useLayoutEffect } from './use-layout-effect.js';\nexport { useState } from './use-state.js';\nexport { useReducer } from './use-reducer.js';\nexport { useMemo } from './use-memo.js';\nexport { useContext } from './use-context.js';\nexport { useRef } from './use-ref.js';\nexport { hook, Hook } from './hook.js';\nexport { BaseScheduler } from './scheduler.js';\nexport { State } from './state.js';\n","import { BaseScheduler } from './scheduler.js';\nconst toCamelCase = (val = '') => val.replace(/-+([a-z])?/g, (_, char) => char ? char.toUpperCase() : '');\nfunction makeComponent(render) {\n    class Scheduler extends BaseScheduler {\n        frag;\n        constructor(renderer, frag, host) {\n            super(renderer, (host || frag));\n            this.frag = frag;\n        }\n        commit(result) {\n            render(result, this.frag);\n        }\n    }\n    function component(renderer, baseElementOrOptions, options) {\n        const BaseElement = (options || baseElementOrOptions || {}).baseElement || HTMLElement;\n        const { observedAttributes = [], useShadowDOM = true, shadowRootInit = {} } = options || baseElementOrOptions || {};\n        class Element extends BaseElement {\n            _scheduler;\n            static get observedAttributes() {\n                return renderer.observedAttributes || observedAttributes || [];\n            }\n            constructor() {\n                super();\n                if (useShadowDOM === false) {\n                    this._scheduler = new Scheduler(renderer, this);\n                }\n                else {\n                    this.attachShadow({ mode: 'open', ...shadowRootInit });\n                    this._scheduler = new Scheduler(renderer, this.shadowRoot, this);\n                }\n            }\n            connectedCallback() {\n                this._scheduler.update();\n            }\n            disconnectedCallback() {\n                this._scheduler.teardown();\n            }\n            attributeChangedCallback(name, oldValue, newValue) {\n                if (oldValue === newValue) {\n                    return;\n                }\n                let val = newValue === '' ? true : newValue;\n                Reflect.set(this, toCamelCase(name), val);\n            }\n        }\n        ;\n        function reflectiveProp(initialValue) {\n            let value = initialValue;\n            let isSetup = false;\n            return Object.freeze({\n                enumerable: true,\n                configurable: true,\n                get() {\n                    return value;\n                },\n                set(newValue) {\n                    // Avoid scheduling update when prop value hasn't changed\n                    if (isSetup && value === newValue)\n                        return;\n                    isSetup = true;\n                    value = newValue;\n                    if (this._scheduler) {\n                        this._scheduler.update();\n                    }\n                }\n            });\n        }\n        const proto = new Proxy(BaseElement.prototype, {\n            getPrototypeOf(target) {\n                return target;\n            },\n            set(target, key, value, receiver) {\n                let desc;\n                if (key in target) {\n                    desc = Object.getOwnPropertyDescriptor(target, key);\n                    if (desc && desc.set) {\n                        desc.set.call(receiver, value);\n                        return true;\n                    }\n                    Reflect.set(target, key, value, receiver);\n                    return true;\n                }\n                if (typeof key === 'symbol' || key[0] === '_') {\n                    desc = {\n                        enumerable: true,\n                        configurable: true,\n                        writable: true,\n                        value\n                    };\n                }\n                else {\n                    desc = reflectiveProp(value);\n                }\n                Object.defineProperty(receiver, key, desc);\n                if (desc.set) {\n                    desc.set.call(receiver, value);\n                }\n                return true;\n            }\n        });\n        Object.setPrototypeOf(Element.prototype, proto);\n        return Element;\n    }\n    return component;\n}\nexport { makeComponent };\n","import { State } from './state.js';\nimport { commitSymbol, phaseSymbol, updateSymbol, effectsSymbol, layoutEffectsSymbol } from './symbols.js';\nconst defer = Promise.resolve().then.bind(Promise.resolve());\nfunction runner() {\n    let tasks = [];\n    let id;\n    function runTasks() {\n        id = null;\n        let t = tasks;\n        tasks = [];\n        for (var i = 0, len = t.length; i < len; i++) {\n            t[i]();\n        }\n    }\n    return function (task) {\n        tasks.push(task);\n        if (id == null) {\n            id = defer(runTasks);\n        }\n    };\n}\nconst read = runner();\nconst write = runner();\nclass BaseScheduler {\n    renderer;\n    host;\n    state;\n    [phaseSymbol];\n    _updateQueued;\n    constructor(renderer, host) {\n        this.renderer = renderer;\n        this.host = host;\n        this.state = new State(this.update.bind(this), host);\n        this[phaseSymbol] = null;\n        this._updateQueued = false;\n    }\n    update() {\n        if (this._updateQueued)\n            return;\n        read(() => {\n            let result = this.handlePhase(updateSymbol);\n            write(() => {\n                this.handlePhase(commitSymbol, result);\n                write(() => {\n                    this.handlePhase(effectsSymbol);\n                });\n            });\n            this._updateQueued = false;\n        });\n        this._updateQueued = true;\n    }\n    handlePhase(phase, arg) {\n        this[phaseSymbol] = phase;\n        switch (phase) {\n            case commitSymbol:\n                this.commit(arg);\n                this.runEffects(layoutEffectsSymbol);\n                return;\n            case updateSymbol: return this.render();\n            case effectsSymbol: return this.runEffects(effectsSymbol);\n        }\n    }\n    render() {\n        return this.state.run(() => this.renderer.call(this.host, this.host));\n    }\n    runEffects(phase) {\n        this.state._runEffects(phase);\n    }\n    teardown() {\n        this.state.teardown();\n    }\n}\nexport { BaseScheduler };\n","import { setCurrent, clear } from './interface.js';\nimport { hookSymbol, effectsSymbol, layoutEffectsSymbol } from './symbols.js';\nclass State {\n    update;\n    host;\n    virtual;\n    [hookSymbol];\n    [effectsSymbol];\n    [layoutEffectsSymbol];\n    constructor(update, host) {\n        this.update = update;\n        this.host = host;\n        this[hookSymbol] = new Map();\n        this[effectsSymbol] = [];\n        this[layoutEffectsSymbol] = [];\n    }\n    run(cb) {\n        setCurrent(this);\n        let res = cb();\n        clear();\n        return res;\n    }\n    _runEffects(phase) {\n        let effects = this[phase];\n        setCurrent(this);\n        for (let effect of effects) {\n            effect.call(this);\n        }\n        clear();\n    }\n    runEffects() {\n        this._runEffects(effectsSymbol);\n    }\n    runLayoutEffects() {\n        this._runEffects(layoutEffectsSymbol);\n    }\n    teardown() {\n        let hooks = this[hookSymbol];\n        hooks.forEach(hook => {\n            if (typeof hook.teardown === 'function') {\n                hook.teardown();\n            }\n        });\n    }\n}\nexport { State };\n","let current;\nlet currentId = 0;\nfunction setCurrent(state) {\n    current = state;\n}\nfunction clear() {\n    current = null;\n    currentId = 0;\n}\nfunction notify() {\n    return currentId++;\n}\nexport { clear, current, setCurrent, notify };\n","const phaseSymbol = Symbol('haunted.phase');\nconst hookSymbol = Symbol('haunted.hook');\nconst updateSymbol = Symbol('haunted.update');\nconst commitSymbol = Symbol('haunted.commit');\nconst effectsSymbol = Symbol('haunted.effects');\nconst layoutEffectsSymbol = Symbol('haunted.layoutEffects');\nconst contextEvent = 'haunted.context';\nexport { phaseSymbol, hookSymbol, updateSymbol, commitSymbol, effectsSymbol, layoutEffectsSymbol, contextEvent, };\n","import { contextEvent } from './symbols.js';\nimport { useContext } from './use-context.js';\nfunction makeContext(component) {\n    return (defaultValue) => {\n        const Context = {\n            Provider: class extends HTMLElement {\n                listeners;\n                _value;\n                constructor() {\n                    super();\n                    this.listeners = new Set();\n                    this.addEventListener(contextEvent, this);\n                }\n                disconnectedCallback() {\n                    this.removeEventListener(contextEvent, this);\n                }\n                handleEvent(event) {\n                    const { detail } = event;\n                    if (detail.Context === Context) {\n                        detail.value = this.value;\n                        detail.unsubscribe = this.unsubscribe.bind(this, detail.callback);\n                        this.listeners.add(detail.callback);\n                        event.stopPropagation();\n                    }\n                }\n                unsubscribe(callback) {\n                    this.listeners.delete(callback);\n                }\n                set value(value) {\n                    this._value = value;\n                    for (let callback of this.listeners) {\n                        callback(value);\n                    }\n                }\n                get value() {\n                    return this._value;\n                }\n            },\n            Consumer: component(function ({ render }) {\n                const context = useContext(Context);\n                return render(context);\n            }),\n            defaultValue,\n        };\n        return Context;\n    };\n}\nexport { makeContext };\n","import { hook, Hook } from './hook.js';\nimport { contextEvent } from './symbols.js';\nimport { setEffects } from './use-effect.js';\n/**\n * @function\n * @template T\n * @param    {Context<T>} context\n * @return   {T}\n */\nconst useContext = hook(class extends Hook {\n    Context;\n    value;\n    _ranEffect;\n    _unsubscribe;\n    constructor(id, state, _) {\n        super(id, state);\n        this._updater = this._updater.bind(this);\n        this._ranEffect = false;\n        this._unsubscribe = null;\n        setEffects(state, this);\n    }\n    update(Context) {\n        if (this.state.virtual) {\n            throw new Error('can\\'t be used with virtual components');\n        }\n        if (this.Context !== Context) {\n            this._subscribe(Context);\n            this.Context = Context;\n        }\n        return this.value;\n    }\n    call() {\n        if (!this._ranEffect) {\n            this._ranEffect = true;\n            if (this._unsubscribe)\n                this._unsubscribe();\n            this._subscribe(this.Context);\n            this.state.update();\n        }\n    }\n    _updater(value) {\n        this.value = value;\n        this.state.update();\n    }\n    _subscribe(Context) {\n        const detail = { Context, callback: this._updater };\n        this.state.host.dispatchEvent(new CustomEvent(contextEvent, {\n            detail,\n            bubbles: true,\n            cancelable: true,\n            composed: true, // to pass ShadowDOM boundaries\n        }));\n        const { unsubscribe = null, value } = detail;\n        this.value = unsubscribe ? value : Context.defaultValue;\n        this._unsubscribe = unsubscribe;\n    }\n    teardown() {\n        if (this._unsubscribe) {\n            this._unsubscribe();\n        }\n    }\n});\nexport { useContext };\n","import { current, notify } from './interface.js';\nimport { hookSymbol } from './symbols.js';\nclass Hook {\n    id;\n    state;\n    constructor(id, state) {\n        this.id = id;\n        this.state = state;\n    }\n}\nfunction use(Hook, ...args) {\n    let id = notify();\n    let hooks = current[hookSymbol];\n    let hook = hooks.get(id);\n    if (!hook) {\n        hook = new Hook(id, current, ...args);\n        hooks.set(id, hook);\n    }\n    return hook.update(...args);\n}\nfunction hook(Hook) {\n    return use.bind(null, Hook);\n}\nexport { hook, Hook };\n","import { effectsSymbol } from './symbols.js';\nimport { createEffect } from './create-effect.js';\nfunction setEffects(state, cb) {\n    state[effectsSymbol].push(cb);\n}\n/**\n * @function\n * @param {() => void} effect - callback function that runs each time dependencies change\n * @param {unknown[]} [dependencies] - list of dependencies to the effect\n * @return {void}\n */\nconst useEffect = createEffect(setEffects);\nexport { setEffects, useEffect };\n","import { Hook, hook } from './hook.js';\nfunction createEffect(setEffects) {\n    return hook(class extends Hook {\n        callback;\n        lastValues;\n        values;\n        _teardown;\n        constructor(id, state, ignored1, ignored2) {\n            super(id, state);\n            setEffects(state, this);\n        }\n        update(callback, values) {\n            this.callback = callback;\n            this.values = values;\n        }\n        call() {\n            if (!this.values || this.hasChanged()) {\n                this.run();\n            }\n            this.lastValues = this.values;\n        }\n        run() {\n            this.teardown();\n            this._teardown = this.callback.call(this.state);\n        }\n        teardown() {\n            if (typeof this._teardown === 'function') {\n                this._teardown();\n            }\n        }\n        hasChanged() {\n            return !this.lastValues || this.values.some((value, i) => this.lastValues[i] !== value);\n        }\n    });\n}\nexport { createEffect };\n","import { useMemo } from './use-memo.js';\n/**\n * @function\n * @template {Function} T\n * @param    {T} fn - callback to memoize\n * @param    {unknown[]} inputs - dependencies to callback memoization\n * @return   {T}\n */\nconst useCallback = (fn, inputs) => useMemo(() => fn, inputs);\nexport { useCallback };\n","import { hook, Hook } from './hook.js';\n/**\n * @function\n * @template T\n * @param  {() => T} fn function to memoize\n * @param  {unknown[]} values dependencies to the memoized computation\n * @return {T} The next computed value\n */\nconst useMemo = hook(class extends Hook {\n    value;\n    values;\n    constructor(id, state, fn, values) {\n        super(id, state);\n        this.value = fn();\n        this.values = values;\n    }\n    update(fn, values) {\n        if (this.hasChanged(values)) {\n            this.values = values;\n            this.value = fn();\n        }\n        return this.value;\n    }\n    hasChanged(values = []) {\n        return values.some((value, i) => this.values[i] !== value);\n    }\n});\nexport { useMemo };\n","/**\n * @license\n * Portions Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { useLayoutEffect } from './use-layout-effect.js';\nimport { useState } from './use-state.js';\nconst microtask = Promise.resolve();\n/**\n * An implementation of ReactiveControllerHost that is driven by Haunted hooks\n * and `useController()`.\n */\nclass HauntedControllerHost {\n    count;\n    kick;\n    _controllers = [];\n    _updatePending = true;\n    _updateCompletePromise;\n    _resolveUpdate;\n    constructor(count, kick) {\n        this.count = count;\n        this.kick = kick;\n        this._updateCompletePromise = new Promise(res => {\n            this._resolveUpdate = res;\n        });\n    }\n    addController(controller) {\n        this._controllers.push(controller);\n    }\n    removeController(controller) {\n        // Note, if the indexOf is -1, the >>> will flip the sign which makes the\n        // splice do nothing.\n        this._controllers && this._controllers.splice(this._controllers.indexOf(controller) >>> 0, 1);\n    }\n    requestUpdate() {\n        if (!this._updatePending) {\n            this._updatePending = true;\n            microtask.then(() => this.kick(this.count + 1));\n        }\n    }\n    get updateComplete() {\n        return this._updateCompletePromise;\n    }\n    connected() {\n        this._controllers.forEach(c => c.hostConnected && c.hostConnected());\n    }\n    disconnected() {\n        this._controllers.forEach(c => c.hostDisconnected && c.hostDisconnected());\n    }\n    update() {\n        this._controllers.forEach(c => c.hostUpdate && c.hostUpdate());\n    }\n    updated() {\n        this._updatePending = false;\n        const resolve = this._resolveUpdate;\n        // Create a new updateComplete Promise for the next update,\n        // before resolving the current one.\n        this._updateCompletePromise = new Promise(res => {\n            this._resolveUpdate = res;\n        });\n        this._controllers.forEach(c => c.hostUpdated && c.hostUpdated());\n        resolve(this._updatePending);\n    }\n}\n/**\n * Creates and stores a stateful ReactiveController instance and provides it\n * with a ReactiveControllerHost that drives the controller lifecycle.\n *\n * Use this hook to convert a ReactiveController into a Haunted hook.\n *\n * @param {<C extends ReactiveController>(host: ReactiveControllerHost) => C} createController A function that creates a controller instance.\n * This function is given a HauntedControllerHost to pass to the controller. The\n * create function is only called once per component.\n * @return {ReactiveController} the controller instance\n */\nexport function useController(createController) {\n    const [count, kick] = useState(0);\n    const [host] = useState(() => {\n        const host = new HauntedControllerHost(count, kick);\n        const controller = createController(host);\n        host.primaryController = controller;\n        host.connected();\n        return host;\n    });\n    // We use useLayoutEffect because we need updated() called synchronously\n    // after rendering.\n    useLayoutEffect(() => host.updated());\n    // Returning a cleanup function simulates hostDisconnected timing. An empty\n    // deps array tells Haunted to only call this once: on mount with the cleanup\n    // called on unmount.\n    useLayoutEffect(() => () => host.disconnected(), []);\n    host.update();\n    return host.primaryController;\n}\n","import { layoutEffectsSymbol } from './symbols.js';\nimport { createEffect } from './create-effect.js';\nfunction setLayoutEffects(state, cb) {\n    state[layoutEffectsSymbol].push(cb);\n}\n/**\n * @function\n * @param  {Effect} callback effecting callback\n * @param  {unknown[]} [values] dependencies to the effect\n * @return {void}\n */\nconst useLayoutEffect = createEffect(setLayoutEffects);\nexport { useLayoutEffect };\n","import { hook, Hook } from './hook.js';\n/**\n * @function\n * @template {*} T\n * @param {T} [initialState] - Optional initial state\n * @return {readonly [state: T, updaterFn: StateUpdater<T>]} stateTuple - Tuple of current state and state updater function\n */\nconst useState = hook(class extends Hook {\n    args;\n    constructor(id, state, initialValue) {\n        super(id, state);\n        this.updater = this.updater.bind(this);\n        if (typeof initialValue === 'function') {\n            initialValue = initialValue();\n        }\n        this.makeArgs(initialValue);\n    }\n    update() {\n        return this.args;\n    }\n    updater(value) {\n        if (typeof value === 'function') {\n            const updaterFn = value;\n            const [previousValue] = this.args;\n            value = updaterFn(previousValue);\n        }\n        this.makeArgs(value);\n        this.state.update();\n    }\n    makeArgs(value) {\n        this.args = Object.freeze([value, this.updater]);\n    }\n});\n;\nexport { useState };\n","import { hook, Hook } from './hook.js';\n/**\n * Given a reducer function, initial state, and optional state initializer function, returns a tuple of state and dispatch function.\n * @function\n * @template S State\n * @template I Initial State\n * @template A Action\n * @param {Reducer<S, A>} reducer - reducer function to compute the next state given the previous state and the action\n * @param {I} initialState - the initial state of the reducer\n * @param {(init: I) => S} [init=undefined] - Optional initializer function, called on initialState if provided\n * @return {readonly [S, (action: A) => void]}\n */\nconst useReducer = hook(class extends Hook {\n    reducer;\n    currentState;\n    constructor(id, state, _, initialState, init) {\n        super(id, state);\n        this.dispatch = this.dispatch.bind(this);\n        this.currentState = init !== undefined ? init(initialState) : initialState;\n    }\n    update(reducer) {\n        this.reducer = reducer;\n        return [this.currentState, this.dispatch];\n    }\n    dispatch(action) {\n        this.currentState = this.reducer(this.currentState, action);\n        this.state.update();\n    }\n});\nexport { useReducer };\n","import { useMemo } from './use-memo.js';\n/**\n * @function\n * @template T\n * @param   {T} initialValue\n * @return  {{ current: T }} Ref\n */\nconst useRef = (initialValue) => useMemo(() => ({\n    current: initialValue\n}), []);\nexport { useRef };\n","import { directive } from 'lit/directive.js';\nimport { noChange } from 'lit';\nimport { AsyncDirective } from 'lit/async-directive.js';\nimport { BaseScheduler } from './scheduler.js';\nconst includes = Array.prototype.includes;\nconst partToScheduler = new WeakMap();\nconst schedulerToPart = new WeakMap();\nclass Scheduler extends BaseScheduler {\n    args;\n    setValue;\n    constructor(renderer, part, setValue) {\n        super(renderer, part);\n        this.state.virtual = true;\n        this.setValue = setValue;\n    }\n    render() {\n        return this.state.run(() => this.renderer.apply(this.host, this.args));\n    }\n    commit(result) {\n        this.setValue(result);\n    }\n    teardown() {\n        super.teardown();\n        let part = schedulerToPart.get(this);\n        partToScheduler.delete(part);\n    }\n}\nfunction makeVirtual() {\n    function virtual(renderer) {\n        class VirtualDirective extends AsyncDirective {\n            cont;\n            constructor(partInfo) {\n                super(partInfo);\n                this.cont = undefined;\n            }\n            update(part, args) {\n                this.cont = partToScheduler.get(part);\n                if (!this.cont || this.cont.renderer !== renderer) {\n                    this.cont = new Scheduler(renderer, part, (r) => { this.setValue(r); });\n                    partToScheduler.set(part, this.cont);\n                    schedulerToPart.set(this.cont, part);\n                    teardownOnRemove(this.cont, part);\n                }\n                this.cont.args = args;\n                this.cont.update();\n                return this.render(args);\n            }\n            render(args) {\n                return noChange;\n            }\n        }\n        return directive(VirtualDirective);\n    }\n    return virtual;\n}\nfunction teardownOnRemove(cont, part, node = part.startNode) {\n    let frag = node.parentNode;\n    let mo = new MutationObserver(mutations => {\n        for (let mutation of mutations) {\n            if (includes.call(mutation.removedNodes, node)) {\n                mo.disconnect();\n                if (node.parentNode instanceof ShadowRoot) {\n                    teardownOnRemove(cont, part);\n                }\n                else {\n                    cont.teardown();\n                }\n                break;\n            }\n            else if (includes.call(mutation.addedNodes, node.nextSibling)) {\n                mo.disconnect();\n                teardownOnRemove(cont, part, node.nextSibling || undefined);\n                break;\n            }\n        }\n    });\n    mo.observe(frag, { childList: true });\n}\nexport { makeVirtual };\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Disconnectable, Part} from './lit-html.js';\n\nexport {\n  AttributePart,\n  BooleanAttributePart,\n  ChildPart,\n  ElementPart,\n  EventPart,\n  Part,\n  PropertyPart,\n} from './lit-html.js';\n\nexport interface DirectiveClass {\n  new (part: PartInfo): Directive;\n}\n\n/**\n * This utility type extracts the signature of a directive class's render()\n * method so we can use it for the type of the generated directive function.\n */\nexport type DirectiveParameters<C extends Directive> = Parameters<C['render']>;\n\n/**\n * A generated directive function doesn't evaluate the directive, but just\n * returns a DirectiveResult object that captures the arguments.\n */\nexport interface DirectiveResult<C extends DirectiveClass = DirectiveClass> {\n  /**\n   * This property needs to remain unminified.\n   * @internal */\n  ['_$litDirective$']: C;\n  /** @internal */\n  values: DirectiveParameters<InstanceType<C>>;\n}\n\nexport const PartType = {\n  ATTRIBUTE: 1,\n  CHILD: 2,\n  PROPERTY: 3,\n  BOOLEAN_ATTRIBUTE: 4,\n  EVENT: 5,\n  ELEMENT: 6,\n} as const;\n\nexport type PartType = typeof PartType[keyof typeof PartType];\n\nexport interface ChildPartInfo {\n  readonly type: typeof PartType.CHILD;\n}\n\nexport interface AttributePartInfo {\n  readonly type:\n    | typeof PartType.ATTRIBUTE\n    | typeof PartType.PROPERTY\n    | typeof PartType.BOOLEAN_ATTRIBUTE\n    | typeof PartType.EVENT;\n  readonly strings?: ReadonlyArray<string>;\n  readonly name: string;\n  readonly tagName: string;\n}\n\nexport interface ElementPartInfo {\n  readonly type: typeof PartType.ELEMENT;\n}\n\n/**\n * Information about the part a directive is bound to.\n *\n * This is useful for checking that a directive is attached to a valid part,\n * such as with directive that can only be used on attribute bindings.\n */\nexport type PartInfo = ChildPartInfo | AttributePartInfo | ElementPartInfo;\n\n/**\n * Creates a user-facing directive function from a Directive class. This\n * function has the same parameters as the directive's render() method.\n */\nexport const directive =\n  <C extends DirectiveClass>(c: C) =>\n  (...values: DirectiveParameters<InstanceType<C>>): DirectiveResult<C> => ({\n    // This property needs to remain unminified.\n    ['_$litDirective$']: c,\n    values,\n  });\n\n/**\n * Base class for creating custom directives. Users should extend this class,\n * implement `render` and/or `update`, and then pass their subclass to\n * `directive`.\n */\nexport abstract class Directive implements Disconnectable {\n  //@internal\n  __part!: Part;\n  //@internal\n  __attributeIndex: number | undefined;\n  //@internal\n  __directive?: Directive;\n\n  //@internal\n  _$parent!: Disconnectable;\n\n  // These will only exist on the AsyncDirective subclass\n  //@internal\n  _$disconnectableChildren?: Set<Disconnectable>;\n  // This property needs to remain unminified.\n  //@internal\n  ['_$notifyDirectiveConnectionChanged']?(isConnected: boolean): void;\n\n  constructor(_partInfo: PartInfo) {}\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  /** @internal */\n  _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    this.__part = part;\n    this._$parent = parent;\n    this.__attributeIndex = attributeIndex;\n  }\n  /** @internal */\n  _$resolve(part: Part, props: Array<unknown>): unknown {\n    return this.update(part, props);\n  }\n\n  abstract render(...props: Array<unknown>): unknown;\n\n  update(_part: Part, props: Array<unknown>): unknown {\n    return this.render(...props);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Overview:\n *\n * This module is designed to add support for an async `setValue` API and\n * `disconnected` callback to directives with the least impact on the core\n * runtime or payload when that feature is not used.\n *\n * The strategy is to introduce a `AsyncDirective` subclass of\n * `Directive` that climbs the \"parent\" tree in its constructor to note which\n * branches of lit-html's \"logical tree\" of data structures contain such\n * directives and thus need to be crawled when a subtree is being cleared (or\n * manually disconnected) in order to run the `disconnected` callback.\n *\n * The \"nodes\" of the logical tree include Parts, TemplateInstances (for when a\n * TemplateResult is committed to a value of a ChildPart), and Directives; these\n * all implement a common interface called `DisconnectableChild`. Each has a\n * `_$parent` reference which is set during construction in the core code, and a\n * `_$disconnectableChildren` field which is initially undefined.\n *\n * The sparse tree created by means of the `AsyncDirective` constructor\n * crawling up the `_$parent` tree and placing a `_$disconnectableChildren` Set\n * on each parent that includes each child that contains a\n * `AsyncDirective` directly or transitively via its children. In order to\n * notify connection state changes and disconnect (or reconnect) a tree, the\n * `_$notifyConnectionChanged` API is patched onto ChildParts as a directive\n * climbs the parent tree, which is called by the core when clearing a part if\n * it exists. When called, that method iterates over the sparse tree of\n * Set<DisconnectableChildren> built up by AsyncDirectives, and calls\n * `_$notifyDirectiveConnectionChanged` on any directives that are encountered\n * in that tree, running the required callbacks.\n *\n * A given \"logical tree\" of lit-html data-structures might look like this:\n *\n *  ChildPart(N1) _$dC=[D2,T3]\n *   ._directive\n *     AsyncDirective(D2)\n *   ._value // user value was TemplateResult\n *     TemplateInstance(T3) _$dC=[A4,A6,N10,N12]\n *      ._parts[]\n *        AttributePart(A4) _$dC=[D5]\n *         ._directives[]\n *           AsyncDirective(D5)\n *        AttributePart(A6) _$dC=[D7,D8]\n *         ._directives[]\n *           AsyncDirective(D7)\n *           Directive(D8) _$dC=[D9]\n *            ._directive\n *              AsyncDirective(D9)\n *        ChildPart(N10) _$dC=[D11]\n *         ._directive\n *           AsyncDirective(D11)\n *         ._value\n *           string\n *        ChildPart(N12) _$dC=[D13,N14,N16]\n *         ._directive\n *           AsyncDirective(D13)\n *         ._value // user value was iterable\n *           Array<ChildPart>\n *             ChildPart(N14) _$dC=[D15]\n *              ._value\n *                string\n *             ChildPart(N16) _$dC=[D17,T18]\n *              ._directive\n *                AsyncDirective(D17)\n *              ._value // user value was TemplateResult\n *                TemplateInstance(T18) _$dC=[A19,A21,N25]\n *                 ._parts[]\n *                   AttributePart(A19) _$dC=[D20]\n *                    ._directives[]\n *                      AsyncDirective(D20)\n *                   AttributePart(A21) _$dC=[22,23]\n *                    ._directives[]\n *                      AsyncDirective(D22)\n *                      Directive(D23) _$dC=[D24]\n *                       ._directive\n *                         AsyncDirective(D24)\n *                   ChildPart(N25) _$dC=[D26]\n *                    ._directive\n *                      AsyncDirective(D26)\n *                    ._value\n *                      string\n *\n * Example 1: The directive in ChildPart(N12) updates and returns `nothing`. The\n * ChildPart will _clear() itself, and so we need to disconnect the \"value\" of\n * the ChildPart (but not its directive). In this case, when `_clear()` calls\n * `_$notifyConnectionChanged()`, we don't iterate all of the\n * _$disconnectableChildren, rather we do a value-specific disconnection: i.e.\n * since the _value was an Array<ChildPart> (because an iterable had been\n * committed), we iterate the array of ChildParts (N14, N16) and run\n * `setConnected` on them (which does recurse down the full tree of\n * `_$disconnectableChildren` below it, and also removes N14 and N16 from N12's\n * `_$disconnectableChildren`). Once the values have been disconnected, we then\n * check whether the ChildPart(N12)'s list of `_$disconnectableChildren` is empty\n * (and would remove it from its parent TemplateInstance(T3) if so), but since\n * it would still contain its directive D13, it stays in the disconnectable\n * tree.\n *\n * Example 2: In the course of Example 1, `setConnected` will reach\n * ChildPart(N16); in this case the entire part is being disconnected, so we\n * simply iterate all of N16's `_$disconnectableChildren` (D17,T18) and\n * recursively run `setConnected` on them. Note that we only remove children\n * from `_$disconnectableChildren` for the top-level values being disconnected\n * on a clear; doing this bookkeeping lower in the tree is wasteful since it's\n * all being thrown away.\n *\n * Example 3: If the LitElement containing the entire tree above becomes\n * disconnected, it will run `childPart.setConnected()` (which calls\n * `childPart._$notifyConnectionChanged()` if it exists); in this case, we\n * recursively run `setConnected()` over the entire tree, without removing any\n * children from `_$disconnectableChildren`, since this tree is required to\n * re-connect the tree, which does the same operation, simply passing\n * `isConnected: true` down the tree, signaling which callback to run.\n */\n\nimport {AttributePart, ChildPart, Disconnectable, Part} from './lit-html.js';\nimport {isSingleExpression} from './directive-helpers.js';\nimport {Directive, PartInfo, PartType} from './directive.js';\nexport {directive} from './directive.js';\n\nconst DEV_MODE = true;\n\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (\n  parent: Disconnectable,\n  isConnected: boolean\n): boolean => {\n  const children = parent._$disconnectableChildren;\n  if (children === undefined) {\n    return false;\n  }\n  for (const obj of children) {\n    // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n    // disambiguate AsyncDirectives from other DisconnectableChildren\n    // (as opposed to using an instanceof check to know when to call it); the\n    // redundancy of \"Directive\" in the API name is to avoid conflicting with\n    // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n    // this list\n    // Disconnect Directive (and any nested directives contained within)\n    // This property needs to remain unminified.\n    (obj as AsyncDirective)['_$notifyDirectiveConnectionChanged']?.(\n      isConnected,\n      false\n    );\n    // Disconnect Part/TemplateInstance\n    notifyChildrenConnectedChanged(obj, isConnected);\n  }\n  return true;\n};\n\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = (obj: Disconnectable) => {\n  let parent, children;\n  do {\n    if ((parent = obj._$parent) === undefined) {\n      break;\n    }\n    children = parent._$disconnectableChildren!;\n    children.delete(obj);\n    obj = parent;\n  } while (children?.size === 0);\n};\n\nconst addDisconnectableToParent = (obj: Disconnectable) => {\n  // Climb the parent tree, creating a sparse tree of children needing\n  // disconnection\n  for (let parent; (parent = obj._$parent); obj = parent) {\n    let children = parent._$disconnectableChildren;\n    if (children === undefined) {\n      parent._$disconnectableChildren = children = new Set();\n    } else if (children.has(obj)) {\n      // Once we've reached a parent that already contains this child, we\n      // can short-circuit\n      break;\n    }\n    children.add(obj);\n    installDisconnectAPI(parent);\n  }\n};\n\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(this: ChildPart, newParent: Disconnectable) {\n  if (this._$disconnectableChildren !== undefined) {\n    removeDisconnectableFromParent(this);\n    this._$parent = newParent;\n    addDisconnectableToParent(this);\n  } else {\n    this._$parent = newParent;\n  }\n}\n\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(\n  this: ChildPart,\n  isConnected: boolean,\n  isClearingValue = false,\n  fromPartIndex = 0\n) {\n  const value = this._$committedValue;\n  const children = this._$disconnectableChildren;\n  if (children === undefined || children.size === 0) {\n    return;\n  }\n  if (isClearingValue) {\n    if (Array.isArray(value)) {\n      // Iterable case: Any ChildParts created by the iterable should be\n      // disconnected and removed from this ChildPart's disconnectable\n      // children (starting at `fromPartIndex` in the case of truncation)\n      for (let i = fromPartIndex; i < value.length; i++) {\n        notifyChildrenConnectedChanged(value[i], false);\n        removeDisconnectableFromParent(value[i]);\n      }\n    } else if (value != null) {\n      // TemplateInstance case: If the value has disconnectable children (will\n      // only be in the case that it is a TemplateInstance), we disconnect it\n      // and remove it from this ChildPart's disconnectable children\n      notifyChildrenConnectedChanged(value as Disconnectable, false);\n      removeDisconnectableFromParent(value as Disconnectable);\n    }\n  } else {\n    notifyChildrenConnectedChanged(this, isConnected);\n  }\n}\n\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = (obj: Disconnectable) => {\n  if ((obj as ChildPart).type == PartType.CHILD) {\n    (obj as ChildPart)._$notifyConnectionChanged ??=\n      notifyChildPartConnectedChanged;\n    (obj as ChildPart)._$reparentDisconnectables ??= reparentDisconnectables;\n  }\n};\n\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport abstract class AsyncDirective extends Directive {\n  // As opposed to other Disconnectables, AsyncDirectives always get notified\n  // when the RootPart connection changes, so the public `isConnected`\n  // is a locally stored variable initialized via its part's getter and synced\n  // via `_$notifyDirectiveConnectionChanged`. This is cheaper than using\n  // the _$isConnected getter, which has to look back up the tree each time.\n  /**\n   * The connection state for this Directive.\n   */\n  isConnected!: boolean;\n\n  // @internal\n  override _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /**\n   * Initialize the part with internal fields\n   * @param part\n   * @param parent\n   * @param attributeIndex\n   */\n  override _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    super._$initialize(part, parent, attributeIndex);\n    addDisconnectableToParent(this);\n    this.isConnected = part._$isConnected;\n  }\n  // This property needs to remain unminified.\n  /**\n   * Called from the core code when a directive is going away from a part (in\n   * which case `shouldRemoveFromParent` should be true), and from the\n   * `setChildrenConnected` helper function when recursively changing the\n   * connection state of a tree (in which case `shouldRemoveFromParent` should\n   * be false).\n   *\n   * @param isConnected\n   * @param isClearingDirective - True when the directive itself is being\n   *     removed; false when the tree is being disconnected\n   * @internal\n   */\n  override ['_$notifyDirectiveConnectionChanged'](\n    isConnected: boolean,\n    isClearingDirective = true\n  ) {\n    if (isConnected !== this.isConnected) {\n      this.isConnected = isConnected;\n      if (isConnected) {\n        this.reconnected?.();\n      } else {\n        this.disconnected?.();\n      }\n    }\n    if (isClearingDirective) {\n      notifyChildrenConnectedChanged(this, isConnected);\n      removeDisconnectableFromParent(this);\n    }\n  }\n\n  /**\n   * Sets the value of the directive's Part outside the normal `update`/`render`\n   * lifecycle of a directive.\n   *\n   * This method should not be called synchronously from a directive's `update`\n   * or `render`.\n   *\n   * @param directive The directive to update\n   * @param value The value to set\n   */\n  setValue(value: unknown) {\n    if (isSingleExpression(this.__part as unknown as PartInfo)) {\n      this.__part._$setValue(value, this);\n    } else {\n      // this.__attributeIndex will be defined in this case, but\n      // assert it in dev mode\n      if (DEV_MODE && this.__attributeIndex === undefined) {\n        throw new Error(`Expected this.__attributeIndex to be a number`);\n      }\n      const newValues = [...(this.__part._$committedValue as Array<unknown>)];\n      newValues[this.__attributeIndex!] = value;\n      (this.__part as AttributePart)._$setValue(newValues, this, 0);\n    }\n  }\n\n  /**\n   * User callbacks for implementing logic to release any resources/subscriptions\n   * that may have been retained by this directive. Since directives may also be\n   * re-connected, `reconnected` should also be implemented to restore the\n   * working state of the directive prior to the next render.\n   */\n  protected disconnected() {}\n  protected reconnected() {}\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {_$LH, Part, DirectiveParent, TemplateResult} from './lit-html.js';\nimport {\n  DirectiveResult,\n  DirectiveClass,\n  PartInfo,\n  AttributePartInfo,\n} from './directive.js';\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\n\nconst {_ChildPart: ChildPart} = _$LH;\n\ntype ChildPart = InstanceType<typeof ChildPart>;\n\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  window.ShadyDOM?.inUse &&\n  window.ShadyDOM?.noPatch === true\n    ? window.ShadyDOM!.wrap\n    : (node: Node) => node;\n\n/**\n * Tests if a value is a primitive value.\n *\n * See https://tc39.github.io/ecma262/#sec-typeof-operator\n */\nexport const isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\n\nexport const TemplateResultType = {\n  HTML: 1,\n  SVG: 2,\n} as const;\n\nexport type TemplateResultType =\n  typeof TemplateResultType[keyof typeof TemplateResultType];\n\n/**\n * Tests if a value is a TemplateResult.\n */\nexport const isTemplateResult = (\n  value: unknown,\n  type?: TemplateResultType\n): value is TemplateResult =>\n  type === undefined\n    ? // This property needs to remain unminified.\n      (value as TemplateResult)?.['_$litType$'] !== undefined\n    : (value as TemplateResult)?.['_$litType$'] === type;\n\n/**\n * Tests if a value is a DirectiveResult.\n */\nexport const isDirectiveResult = (value: unknown): value is DirectiveResult =>\n  // This property needs to remain unminified.\n  (value as DirectiveResult)?.['_$litDirective$'] !== undefined;\n\n/**\n * Retrieves the Directive class for a DirectiveResult\n */\nexport const getDirectiveClass = (value: unknown): DirectiveClass | undefined =>\n  // This property needs to remain unminified.\n  (value as DirectiveResult)?.['_$litDirective$'];\n\n/**\n * Tests whether a part has only a single-expression with no strings to\n * interpolate between.\n *\n * Only AttributePart and PropertyPart can have multiple expressions.\n * Multi-expression parts have a `strings` property and single-expression\n * parts do not.\n */\nexport const isSingleExpression = (part: PartInfo) =>\n  (part as AttributePartInfo).strings === undefined;\n\nconst createMarker = () => document.createComment('');\n\n/**\n * Inserts a ChildPart into the given container ChildPart's DOM, either at the\n * end of the container ChildPart, or before the optional `refPart`.\n *\n * This does not add the part to the containerPart's committed value. That must\n * be done by callers.\n *\n * @param containerPart Part within which to add the new ChildPart\n * @param refPart Part before which to add the new ChildPart; when omitted the\n *     part added to the end of the `containerPart`\n * @param part Part to insert, or undefined to create a new part\n */\nexport const insertPart = (\n  containerPart: ChildPart,\n  refPart?: ChildPart,\n  part?: ChildPart\n): ChildPart => {\n  const container = wrap(containerPart._$startNode).parentNode!;\n\n  const refNode =\n    refPart === undefined ? containerPart._$endNode : refPart._$startNode;\n\n  if (part === undefined) {\n    const startNode = wrap(container).insertBefore(createMarker(), refNode);\n    const endNode = wrap(container).insertBefore(createMarker(), refNode);\n    part = new ChildPart(\n      startNode,\n      endNode,\n      containerPart,\n      containerPart.options\n    );\n  } else {\n    const endNode = wrap(part._$endNode!).nextSibling;\n    const oldParent = part._$parent;\n    const parentChanged = oldParent !== containerPart;\n    if (parentChanged) {\n      part._$reparentDisconnectables?.(containerPart);\n      // Note that although `_$reparentDisconnectables` updates the part's\n      // `_$parent` reference after unlinking from its current parent, that\n      // method only exists if Disconnectables are present, so we need to\n      // unconditionally set it here\n      part._$parent = containerPart;\n      // Since the _$isConnected getter is somewhat costly, only\n      // read it once we know the subtree has directives that need\n      // to be notified\n      let newConnectionState;\n      if (\n        part._$notifyConnectionChanged !== undefined &&\n        (newConnectionState = containerPart._$isConnected) !==\n          oldParent!._$isConnected\n      ) {\n        part._$notifyConnectionChanged(newConnectionState);\n      }\n    }\n    if (endNode !== refNode || parentChanged) {\n      let start: Node | null = part._$startNode;\n      while (start !== endNode) {\n        const n: Node | null = wrap(start!).nextSibling;\n        wrap(container).insertBefore(start!, refNode);\n        start = n;\n      }\n    }\n  }\n\n  return part;\n};\n\n/**\n * Sets the value of a Part.\n *\n * Note that this should only be used to set/update the value of user-created\n * parts (i.e. those created using `insertPart`); it should not be used\n * by directives to set the value of the directive's container part. Directives\n * should return a value from `update`/`render` to update their part state.\n *\n * For directives that require setting their part value asynchronously, they\n * should extend `AsyncDirective` and call `this.setValue()`.\n *\n * @param part Part to set\n * @param value Value to set\n * @param index For `AttributePart`s, the index to set\n * @param directiveParent Used internally; should not be set by user\n */\nexport const setChildPartValue = <T extends ChildPart>(\n  part: T,\n  value: unknown,\n  directiveParent: DirectiveParent = part\n): T => {\n  part._$setValue(value, directiveParent);\n  return part;\n};\n\n// A sentinal value that can never appear as a part value except when set by\n// live(). Used to force a dirty-check to fail and cause a re-render.\nconst RESET_VALUE = {};\n\n/**\n * Sets the committed value of a ChildPart directly without triggering the\n * commit stage of the part.\n *\n * This is useful in cases where a directive needs to update the part such\n * that the next update detects a value change or not. When value is omitted,\n * the next update will be guaranteed to be detected as a change.\n *\n * @param part\n * @param value\n */\nexport const setCommittedValue = (part: Part, value: unknown = RESET_VALUE) =>\n  (part._$committedValue = value);\n\n/**\n * Returns the committed value of a ChildPart.\n *\n * The committed value is used for change detection and efficient updates of\n * the part. It can differ from the value set by the template or directive in\n * cases where the template value is transformed before being commited.\n *\n * - `TemplateResult`s are committed as a `TemplateInstance`\n * - Iterables are committed as `Array<ChildPart>`\n * - All other types are committed as the template value or value returned or\n *   set by a directive.\n *\n * @param part\n */\nexport const getCommittedValue = (part: ChildPart) => part._$committedValue;\n\n/**\n * Removes a ChildPart from the DOM, including any of its content.\n *\n * @param part The Part to remove\n */\nexport const removePart = (part: ChildPart) => {\n  part._$notifyConnectionChanged?.(false, true);\n  let start: ChildNode | null = part._$startNode;\n  const end: ChildNode | null = wrap(part._$endNode!).nextSibling;\n  while (start !== end) {\n    const n: ChildNode | null = wrap(start!).nextSibling;\n    (wrap(start!) as ChildNode).remove();\n    start = n;\n  }\n};\n\nexport const clearPart = (part: ChildPart) => {\n  part._$clear();\n};\n","/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n   var currentSlope = getSlope(aGuessT, mX1, mX2);\n   if (currentSlope === 0.0) {\n     return aGuessT;\n   }\n   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n   aGuessT -= currentX / currentSlope;\n }\n return aGuessT;\n}\n\nfunction LinearEasing (x) {\n  return x;\n}\n\nmodule.exports = function bezier (mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n\n  // Precompute samples table\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing (x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n","import {CustomElementDefinition} from \"../../ui-types\";\nimport {component, useMemo} from \"haunted\";\nimport {html} from \"lit\";\nimport {useEffect, useState} from \"haunted/lib/core\";\n\nconst second = 1000;\nconst minute = second * 60;\nconst hour = minute * 60;\nconst day = hour * 24;\n\ntype TimerElementType = CustomElementDefinition<{ targetDate: string }>;\n\nexport const TimerElement:TimerElementType = ({targetDate}) => {\n\n    const initialDiff = useMemo(() => targetDate && fmtTime(calcTimeDiff(targetDate)), [])\n    const [time, setTime] = useState(initialDiff || \"00:00:00\");\n    const [lastInterval, setLastInterval] = useState(0);\n\n    const [hours, minutes, seconds] = time.split(\":\");\n\n    useEffect(() => {\n        window.clearInterval(lastInterval);\n        setInterval(() => {\n            if (targetDate) {\n                setTime(fmtTime(calcTimeDiff(targetDate)));\n            }\n        }, 1000);\n    }, [targetDate])\n\n    return html`<span>${hours}</span>:<span>${minutes}</span>:<span>${seconds}</span>`\n}\n\nfunction calcTimeDiff(targetDate: string) {\n    const timeNow = Date.now();\n    const targetDatee = new Date(targetDate);\n    const target = targetDatee.getTime() + (targetDatee.getTimezoneOffset() * minute);\n    const diff = target - timeNow;\n    return diff\n}\n\nfunction fmtTime(time: number) {\n    const hours = Math.floor(time / hour).toString();\n    const minutes = Math.floor((time % hour) / minute).toString();\n    const seconds = Math.floor((time % minute) / second).toString();\n    return `${hours}:${minutes.padStart(2, \"0\")}:${seconds.padStart(2, \"0\")}`\n}\n\ncustomElements.define(\"timer-element\", component(TimerElement, {useShadowDOM: false, observedAttributes: [\"target-date\"] as any}));","import {createContext} from \"haunted\";\nimport {Nullable} from \"../../../../_/types\";\nimport {StripeContextType} from \"./types\";\nimport {CustomElement} from \"../../../ui-types\";\n\nexport const StripeContext = createContext(null as Nullable<StripeContextType>);\ncustomElements.define(\"stripe-provider\", StripeContext.Provider);\n\ndeclare global {\n    interface HTMLElementTagNameMap {\n        'stripe-provider': CustomElement<typeof StripeContext.Provider>\n    }\n}","import \"./stripe-context\"\n\nimport StripeTypes from \"@stripe/stripe-js\";\nimport {CustomElement, CustomElementDefinition, CustomEventType} from \"../../../ui-types\";\nimport {useEffect, useRef} from \"haunted/lib/core\";\nimport {Nullable} from \"../../../../_/types\";\nimport {useAwait} from \"../../../util/hooks/use-await\";\nimport {component} from \"haunted\";\nimport {StripeContextType} from \"./types\";\nimport {StripeContext} from \"./stripe-context\";\nimport {css} from \"../../../util/css\";\n\nexport const fmt = {\n    err: (...args: any[]) => args\n}\n\nexport type StripeCardformEvents = {\n    onformready: (e: CustomEvent) => void,\n    onelementready: (e: CustomEvent<{ elementType: string }>) => void,\n    onsendcardtoken: (e: CustomEvent<{ token: StripeTypes.Token }>) => void,\n};\n\nexport type StripeCardFormType = CustomElementDefinition<{ forceLoading?: boolean, btnContent?: any, stripePublicKey: string, value: StripeContextType}, Partial<StripeCardformEvents>>;\n\ncss`stripe-form { display: block }`\nexport const StripeForm: StripeCardFormType = function (props) {\n    const stripeRef = useRef(null as Nullable<StripeContextType>);\n\n    const useSubmit = useAwait(async () => {\n            if (stripeRef.current) {\n                const {stripeClient, stripeElements} = stripeRef.current;\n                const stripeTokenizableElm = stripeElements.getElement(\"cardNumber\") || stripeElements.getElement(\"card\");\n\n                if (!stripeTokenizableElm) {\n                    throw \"Input not found\"\n                }\n\n                const tokenResult = await stripeClient.createToken(stripeTokenizableElm);\n\n                if (tokenResult.token) {\n                    const sendTokenEvent: CustomEventType<StripeCardformEvents, \"onsendcardtoken\"> = new CustomEvent(\"sendcardtoken\", {detail: {token: tokenResult.token}, bubbles: true});\n                    this.dispatchEvent(sendTokenEvent)\n                }\n\n                if (tokenResult.error) {\n                    console.warn(tokenResult.error)\n                    throw tokenResult.error;\n                }\n            }\n        }\n        , (data) => {\n            if (this.value) {\n                this.value = {...this.value, useSubmit: {...data}};\n            }\n        });\n\n    const stripeCb = useAwait(async () => {\n        const stripeImport = await import('@stripe/stripe-js');\n        const stripe = await stripeImport.loadStripe(props.stripePublicKey);\n\n        if (!stripe) {\n            throw \"Could not load stripe\";\n        }\n\n        const stripeElements = stripe.elements();\n\n        stripeRef.current = {\n            stripeClient: stripe,\n            stripeElements: stripeElements,\n            useSubmit: useSubmit\n        };\n\n        this.value = stripeRef.current;\n    });\n\n    useEffect(() => {\n        if (!stripeRef.current) {\n            stripeCb.run();\n        }\n    }, []);\n}\n\ncustomElements.define(\"stripe-form\", component(StripeForm, {useShadowDOM: false, baseElement: StripeContext.Provider}))\n\ndeclare global {\n    interface HTMLElementTagNameMap {\n        'stripe-form': CustomElement<StripeCardFormType>\n    }\n}","import {useState} from \"haunted/lib/core\";\nimport {inlineErr} from \"../../../_/inline-error\";\nimport {Undefinable} from \"../../../_/types\";\n\ntype useAwaitReturnType<T extends ((...args: any[]) => Promise<R>), R> = { run: T, result: Undefinable<R>, loading: boolean, err: undefined | Error };\ntype useAwaitType<T extends ((...args: any[]) => Promise<R>), R> = useAwaitReturnType<T, R>;\n\n/**\n *\n * @param job Async function to be executed\n * @param cb Callback executed everytime the stats change\n */\nexport function useAwait<R, T extends ((...args: any[]) => Promise<R>)>(job: T, cb?: (stats: useAwaitReturnType<T, R>) => void): useAwaitType<T, R> {\n    const [loading, setLoading] = useState(false);\n    const [err, setErr] = useState(undefined as undefined | Error);\n    const [result, setResult] = useState(undefined as Undefinable<R>);\n\n    const run = (async (...args) => {\n        if (!loading) {\n            setLoading(true);\n            setErr(undefined as any);\n            const [result, err] = await inlineErr(job(...args));\n            setErr(err as any);\n            setResult(result as any);\n            setLoading(false);\n            return result;\n        }\n    }) as T;\n\n    const awaitStats: useAwaitReturnType<T, R> = {\n        run,\n        loading,\n        result: result as Undefinable<R>,\n        err\n    };\n\n    if (cb) {\n        cb(awaitStats);\n    }\n\n    return awaitStats;\n}","export async function inlineErr<T = any>(arg: Promise<T> | T, preventLog?: boolean): Promise<[T | undefined, Error?]> {\n    try {\n        return [await arg];\n    } catch (err) {\n        if (!preventLog) {\n            console.error(err);\n        }\n        return [undefined, err as any];\n    }\n}","let memory: string[] = [];\n\nexport const css = (template: TemplateStringsArray | string, ...values: (string | number)[]) => {\n\n    let text = \"\";\n\n    if (Array.isArray(template)) {\n        for (let i = 0; i < template.length; i++) {\n            text += template[i];\n            text += i === template.length - 1 ? \"\" : values[i];\n        }\n    } else {\n        text = template as string\n    }\n\n    if (memory.indexOf(text) > -1) return\n\n    let styleElement = document.createElement(\"style\");\n    styleElement.innerHTML = text;\n    document.head.appendChild(styleElement);\n\n    memory.push(text);\n};","module.exports = (__parcel__import__(\"./\" + require('./helpers/bundle-manifest').resolve(\"532Ah\"))).then(() => parcelRequire('e8NUo'));","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","import {CustomElement, CustomElementDefinition, CustomEventType} from \"../../../ui-types\";\nimport {useContext, useEffect, useState} from \"haunted/lib/core\";\nimport {StripeContext} from \"./stripe-context\";\nimport {component} from \"haunted\";\nimport {css} from \"../../../util/css\";\nimport {StripeContextType} from \"./types\";\nimport {fmt, StripeCardformEvents} from \"./stripe-form\";\nimport {Nullable} from \"../../../../_/types\";\nimport {html} from \"lit\";\n\ntype CardTypes = \"cardNumber\" | \"cardExpiry\" | \"cardCvc\" | \"card\";\n\nfunction defineComponent(tagName: string, func: CustomElementDefinition) {\n    css`${tagName} {display: block}`\n    customElements.define(tagName, component(func, {useShadowDOM: false}));\n    return func;\n}\n\nfunction defineStripeInputElm(tagName: string, type: CardTypes, opts?: any) {\n\n    const StripeInputElm: CustomElementDefinition = function () {\n        const stripeContext = useContext(StripeContext);\n        const [stripeElm, setStripeElm] = useState(null as Nullable<HTMLElement>);\n\n        useEffect(() => {\n            if (stripeContext) {\n                setStripeElm(buildStripeElement(this, stripeContext, type, opts));\n            }\n        }, [stripeContext])\n\n        return stripeElm\n    };\n\n    return defineComponent(tagName, StripeInputElm)\n}\n\nfunction buildStripeElement(host: HTMLElement, stripeRef: StripeContextType, type: CardTypes, opts: any) {\n    const stripeElm = stripeRef.stripeElements.create(type as any, opts);\n    const container = document.createElement(\"div\");\n    stripeElm.mount(container);\n\n    stripeElm.on(\"ready\", (e) => {\n        let onElementReadyEvent: CustomEventType<StripeCardformEvents, \"onelementready\"> = new CustomEvent(\"elementready\", {detail: e, bubbles: true});\n        host.dispatchEvent(onElementReadyEvent);\n    })\n\n    return container\n}\n\nexport const StripeCard = defineStripeInputElm(\"stripe-card\", \"card\");\nexport const StripeCardNumber = defineStripeInputElm(\"stripe-card-number\", \"cardNumber\")\nexport const StripeCardCvc = defineStripeInputElm(\"stripe-card-cvc\", \"cardCvc\");\nexport const StripeCardExpiry = defineStripeInputElm(\"stripe-card-expiry\", \"cardExpiry\");\n\nexport const StripeSubmitErr = defineComponent(\"stripe-submit-error\", function() {\n    const stripeContext = useContext(StripeContext);\n    const err = stripeContext?.useSubmit?.err;\n\n    if (!err) {\n        return undefined\n    }\n\n    return html`${fmt.err(err)}`\n})\n\nexport const StripeSubmit = defineComponent(\"stripe-submit\", function() {\n    const stripeContext = useContext(StripeContext);\n    const submitCb = stripeContext?.useSubmit?.run;\n\n    useEffect(() => {\n        if (submitCb) {\n            this.addEventListener(\"click\", submitCb);\n            return () => this.removeEventListener(\"click\", submitCb);\n        }\n    }, [submitCb])\n})\n\n\ndeclare global {\n    interface HTMLElementTagNameMap {\n        'stripe-card': CustomElement<typeof StripeCard>\n        'stripe-card-number': CustomElement<typeof StripeCardNumber>\n        'stripe-card-cvc': CustomElement<typeof StripeCardCvc>\n        'stripe-card-expiry': CustomElement<typeof StripeCardExpiry>\n    }\n}"],"names":["parcelRequire","$5GEES","customElements","define","component","from","to","bezier","secondsDuration","maxDecimals","minDecimals","once","attr","console","warn","this","fromTimeRef","$j0FIF","useRef","bezierRef","updateCurrentRef","$2SpgD","useEffect","current","$parcel$interopDefault","$lzqXA","split","Date","now","fmt","Intl","NumberFormat","undefined","maximumFractionDigits","minimumFractionDigits","potato","duration","pointInLinearCurve","pointInBezier","numberFrom","textContent","format","requestAnimationFrame","observerEnter","IntersectionObserver","elms","isIntersecting","disconnect","threshold","observe","useShadowDOM","observedAttributes","$jkSQt","$424069e151f06ddd$export$d8556a2a8f973135","createContext","$424069e151f06ddd$export$fd42f52fd3ae1109","$2NXZw","default","render","$2VV2X","makeVirtual","$jLzhG","$20aeb169c3f87979$export$2e2bcd8739ae039","makeComponent","$dTsG0","makeContext","$8JgR8","$e63dc6caf9b6fac8$export$3bc26eec1cc2439f","Scheduler","BaseScheduler","frag","constructor","renderer","host","super","commit","result","baseElementOrOptions","options","BaseElement","baseElement","HTMLElement","shadowRootInit","Element","_scheduler","attachShadow","mode","shadowRoot","connectedCallback","update","disconnectedCallback","teardown","attributeChangedCallback","name","oldValue","newValue","val","Reflect","set","replace","_","char","toUpperCase","$e63dc6caf9b6fac8$var$toCamelCase","proto","Proxy","prototype","getPrototypeOf","target","key","value","receiver","desc","Object","getOwnPropertyDescriptor","call","enumerable","configurable","writable","initialValue","isSetup","freeze","get","reflectiveProp","defineProperty","setPrototypeOf","$636ai","$65af99f4a944e48f$var$defer","Promise","resolve","then","bind","$65af99f4a944e48f$var$runner","id","tasks","runTasks","t","i","len","length","task","push","$65af99f4a944e48f$var$read","$65af99f4a944e48f$var$write","$65af99f4a944e48f$export$61cd7faa6f3316a3","state","$95d4u","phaseSymbol","_updateQueued","State","handlePhase","updateSymbol","commitSymbol","effectsSymbol","phase","arg","runEffects","layoutEffectsSymbol","run","_runEffects","$1bhDk","$4677ce260efeb307$export$7254cc27399e90bd","virtual","hookSymbol","Map","cb","setCurrent","res","clear","effects","effect","runLayoutEffects","forEach","hook","$0dc47f238fcdf29d$export$97aac956da55dae9","$0dc47f238fcdf29d$var$currentId","$0dc47f238fcdf29d$export$5f80f094fd31fffd","$0dc47f238fcdf29d$export$42ffd38884aecdac","$0dc47f238fcdf29d$export$5e14cdade93d6f7b","$69ceb8632136ff6c$export$225ab0e0febd92b1","Symbol","$69ceb8632136ff6c$export$819a7f3d5f1d869d","$69ceb8632136ff6c$export$e3a0ce117547085d","$69ceb8632136ff6c$export$c3840c26fe093fdb","$69ceb8632136ff6c$export$8e8d58c9b17fea3e","$69ceb8632136ff6c$export$db08efd2f456c5bf","$69ceb8632136ff6c$export$c1645e5fb9a50701","$a1d6a7f884bb1ab2$export$2d2e2a019c76af3","defaultValue","Context","Provider","listeners","_value","Set","addEventListener","contextEvent","removeEventListener","handleEvent","event","detail","unsubscribe","callback","add","stopPropagation","delete","Consumer","$7we7d","useContext","$4EZYf","$579678923af3f43f$export$fae74005e78b1a27","Hook","_ranEffect","_unsubscribe","_updater","setEffects","Error","_subscribe","dispatchEvent","CustomEvent","bubbles","cancelable","composed","$364af7f7e0ebf567$export$e594a57fbda5c090","$364af7f7e0ebf567$var$use","Hook1","args","notify","hooks","hook1","$364af7f7e0ebf567$export$1062a250c78723ea","Hook2","$21843974b20fb708$export$2ff5f1970029d8ea","$21843974b20fb708$export$6d9c69b0de29b591","createEffect","$15f72000e7457bdb$export$7ea7134f704deda4","lastValues","values","_teardown","ignored1","ignored2","hasChanged","some","$bf7a78ed2e5439ca$export$1538c33de8887b59","fn","$e54d69a0a1ecab4d$export$e5c5a5f917a5871c","$8fb7939c9206c8e4$export$60241385465d0a34","updater","makeArgs","updaterFn","previousValue","reducer","currentState","initialState","init","dispatch","action","$grezC","$dd6e610786b1cbc8$export$b8f5890fc79d6aca","useMemo","$3IoIg","$222d27ef593df812$var$includes","Array","includes","$222d27ef593df812$var$partToScheduler","WeakMap","$222d27ef593df812$var$schedulerToPart","$222d27ef593df812$var$Scheduler","setValue","part","apply","$222d27ef593df812$export$3b9595dc33c67676","VirtualDirective","$3fi3k","AsyncDirective","cont","partInfo","r","$222d27ef593df812$var$teardownOnRemove","noChange","directive","node","startNode","parentNode","mo","MutationObserver","mutations","mutation","removedNodes","ShadowRoot","addedNodes","nextSibling","childList","PartType","ATTRIBUTE","CHILD","PROPERTY","BOOLEAN_ATTRIBUTE","EVENT","ELEMENT","c","_$litDirective$","Directive","_partInfo","_$isConnected","_$parent","_$initialize","parent","attributeIndex","__part","__attributeIndex","_$resolve","props","_part","notifyChildrenConnectedChanged","isConnected","children","_$disconnectableChildren","obj","_b","_a","_$AO","o1","s1","removeDisconnectableFromParent","size","addDisconnectableToParent","has","installDisconnectAPI","reparentDisconnectables","newParent","notifyChildPartConnectedChanged","isClearingValue","fromPartIndex","_$committedValue","isArray","type","_c","_$notifyConnectionChanged","_d","_$reparentDisconnectables","isClearingDirective","s6","n4","reconnected","disconnected","isSingleExpression","_$setValue","newValues","_ChildPart","ChildPart","_$LH","strings","$fb41c7946c519673$var$kSampleStepSize","$fb41c7946c519673$var$float32ArraySupported","Float32Array","$fb41c7946c519673$var$A","aA1","aA2","$fb41c7946c519673$var$B","$fb41c7946c519673$var$C","$fb41c7946c519673$var$calcBezier","aT","$fb41c7946c519673$var$getSlope","$fb41c7946c519673$var$LinearEasing","x","module","exports","mX1","mY1","mX2","mY2","sampleValues","getTForX","aX","intervalStart","currentSample","$fb41c7946c519673$var$kSplineTableSize","guessForT","initialSlope","aGuessT","currentSlope","$fb41c7946c519673$var$newtonRaphsonIterate","aA","aB","currentX","currentT","Math","abs","$fb41c7946c519673$var$binarySubdivide","$43fcccd4077a86d6$var$minute","$43fcccd4077a86d6$var$second","$43fcccd4077a86d6$var$hour","$43fcccd4077a86d6$var$calcTimeDiff","targetDate","timeNow","targetDatee","getTime","getTimezoneOffset","$43fcccd4077a86d6$var$fmtTime","time","hours","floor","toString","minutes","seconds","padStart","initialDiff","setTime","$cl0au","useState","lastInterval","setLastInterval","window","clearInterval","setInterval","html","$b850749c718dd4e8$export$bdc250ccffdc5290","$1haoc","$116738dae7e6201e$export$bc71a178fd8db0f","err","$gxpVb","css","stripeRef","useSubmit","$30Ln9","useAwait","async","stripeClient","stripeElements","stripeTokenizableElm","getElement","tokenResult","createToken","token","sendTokenEvent","error","data","stripeCb","stripeImport","stripe","loadStripe","stripePublicKey","elements","StripeContext","$632fd89768f41ead$export$6de935e3b3681947","job","loading","setLoading","err1","setErr","result1","setResult","awaitStats","$9Rmcj","inlineErr","$eceb28fbd7ed915d$export$19af69b8fa933a33","preventLog","$b6625843b310f923$var$memory","$b6625843b310f923$export$dbf350e5966cf602","template","text","indexOf","styleElement","document","createElement","innerHTML","head","appendChild","import","$7c0507e57172cb5a$export$f7ad0328861e2f03","$7c0507e57172cb5a$var$mapping","resolved","$644907f21b7f8784$var$defineComponent","tagName","func","$644907f21b7f8784$var$defineStripeInputElm","opts","stripeContext","stripeElm","setStripeElm","create","container","mount","on","e","onElementReadyEvent","$644907f21b7f8784$var$buildStripeElement","$95n3w","submitCb"],"version":3,"file":"increment-number.38ce552d.js.map"}