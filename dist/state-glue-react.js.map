{"mappings":";;AEmBO,MAAM,wCAAY,GAAG,CAAC,QAA8B,EAAE,SAAgC,GAAK,SAAS,OAAO,CAAI,aAAuB,EAAE,KAAc,EAAiB;QAE1K,MAAM,YAAY,GAAkB;YAAC,aAAa,CAAC,QAAQ,EAAE;YAAE;gBAAC,KAAK,EAAE,SAAS;gBAAE,UAAU,EAAE,KAAK;aAAC;SAAC,AAAC;QAEtG,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,GAAG,QAAQ,CAAC,YAAY,CAAC,AAAC;QAEjD,SAAS,CAAC,IAAM;YACZ,IAAI,KAAK,EACL,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,aAAa,CAAC,EAAE,CAAC,eAAe,CAAC,CAAC,CAAC;YAGzE,MAAM,YAAY,GAAG,IAAM;gBACvB,MAAM,SAAS,GAAG,aAAa,CAAC,QAAQ,EAAE,AAAC;gBAC3C,MAAM,cAAc,GAAkB;oBAAC,SAAS;oBAAE;wBAAC,KAAK,EAAE,aAAa,CAAC,KAAK;wBAAE,UAAU,EAAE,aAAa,CAAC,UAAU;qBAAC;iBAAC,AAAC;gBAEtH,IAAI,KAAK,EACL,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,aAAa,CAAC,EAAE,CAAC,wBAAwB,CAAC,CAAC,CAAC;gBAGlF,QAAQ,CAAC,cAAc,CAAC,CAAC;YACzB,wGAAwG;YACxG,mDAAmD;YACnD,6HAA6H;aAChI,AAAC;YAEF,aAAa,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;YAGtC,OAAO,IAAM;gBACT,IAAI,KAAK,EACL,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,yBAAyB,EAAE,aAAa,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBAG7E,aAAa,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;aAC3C,CAAC;SACL,EAAE,EAAE,CAAC,CAAC;QAEP,OAAO,KAAK,CAAA;KACf;;ADzDD;;AAGO,MAAM,yCAAO,GAAG,CAAA,GAAA,wCAAY,CAAA,CAAC,CAAA,GAAA,eAAQ,CAAA,EAAE,CAAA,GAAA,gBAAS,CAAA,CAAC;;ADHxD","sources":["src/lib/state-glue-react.ts","src/app/state/state-glue-react.ts","src/app/state/state-glue-generator.ts"],"sourcesContent":["export {useGlue} from \"../app/state/state-glue-react\"","import {generateGlue} from \"./state-glue-generator\";\nimport {useEffect, useState} from \"react\";\n\nexport const useGlue = generateGlue(useState, useEffect)","import {State} from \"./state\";\nimport {DeepReadonly} from \"utility-types\";\nimport type {useEffect as reactUseEffect, useState as reactUseState} from \"react\";\n\nexport type GlueStatus = {\n    error: any,\n    isUpdating: boolean\n}\n\nexport type GlueResult<T> = [T, DeepReadonly<GlueStatus>];\n\nexport type ExternalState<T> = State<T>\n\n/**\n * Usage example:\n * ```\n *     const [fooGlue, fooStatus] = useGlue(fooState)\n * ```\n */\nexport const generateGlue = (useState: typeof reactUseState, useEffect: typeof reactUseEffect) => function useGlue<Z>(externalState: State<Z>, logId?: string): GlueResult<Z> {\n\n    const initialState: GlueResult<Z> = [externalState.getState(), {error: undefined, isUpdating: false}];\n\n    const [state, setState] = useState(initialState);\n\n    useEffect(() => {\n        if (logId) {\n            console.log(`${logId}:`, `State ${externalState.id} is being glued`);\n        }\n\n        const subscription = () => {\n            const selection = externalState.getState();\n            const selectorResult: GlueResult<Z> = [selection, {error: externalState.error, isUpdating: externalState.isUpdating}];\n\n            if (logId) {\n                console.log(`${logId}:`, `State ${externalState.id} is updating the element`);\n            }\n\n            setState(selectorResult);\n            //TODO: Maybe it's good to do a hacky workaround of changing above declaration to: let [state, setState]\n            //      and add here bellow: state = selectorResult\n            //      It seems that during the element rendering, setState didn't trigger a new render when this callback ran synchronously\n        };\n\n        externalState.subscribe(subscription);\n\n\n        return () => {\n            if (logId) {\n                console.log(`${logId}:`, `Disconnecting from state ${externalState.id}`);\n            }\n\n            externalState.unsubscribe(subscription);\n        };\n    }, []);\n\n    return state\n}"],"names":[],"version":3,"file":"state-glue-react.js.map"}